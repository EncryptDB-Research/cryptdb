Only in cryptdb-popa: bins
Only in Practical-Cryptdb: cdbclient.sh
Only in Practical-Cryptdb: cdbserver.sh
Only in cryptdb-popa: conf
Only in cryptdb-popa: CryptDBdoxgen
Only in Practical-Cryptdb/crypto: all
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/crypto/BasicCrypto.cc Practical-Cryptdb/crypto/BasicCrypto.cc
                                                                >      if (l == SECLEVEL::OPEFOREIGN){
                                                                >          return getKey(mKey,"foreignjoin",l);
                                                                >      }
                                                                >
                                                                >
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/crypto/gfe.hh Practical-Cryptdb/crypto/gfe.hh
                                                                >  #include <crypto/hmac.hh>
                                                                >
                                                                >  using std::make_pair;
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/crypto/Makefrag Practical-Cryptdb/crypto/Makefrag
        $(CXX) -shared -o $@ $(CRYPTOOBJ) $(LDFLAGS) $(LDRPATH) |          $(CXX) -fPIC -shared -o $@ $(CRYPTOOBJ) $(LDFLAGS) $(LD
install: install_crypto                                         |  #install: install_crypto
.PHONY: install_crypto                                          |  #.PHONY: install_crypto
install_crypto: $(OBJDIR)/libedbcrypto.so                       |  #install_crypto: $(OBJDIR)/libedbcrypto.so
        install -m 644 $(OBJDIR)/libedbcrypto.so /usr/lib       |  #       install -m 644 $(OBJDIR)/libedbcrypto.so /usr/lib
Only in cryptdb-popa/crypto: .vimrc
Only in cryptdb-popa/crypto: x.cc
Only in Practical-Cryptdb: debug
Only in cryptdb-popa: demoqueries
Only in cryptdb-popa: doc
Only in cryptdb-popa: eval
Only in Practical-Cryptdb: .gitignore
Only in cryptdb-popa: GNUmakefile
Only in Practical-Cryptdb: insert.sh
Only in Practical-Cryptdb: INSTALL.sh
Only in cryptdb-popa: logs
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/alter_sub_handler.cc Practical-Cryptdb/main/alter_sub_handler.cc
                                                                >  // ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                                >  //     These handlers expect a LEX that they
                                                                >  //            can update in place.
                                                                >  // ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                                >
    virtual LEX *rewriteAndUpdate(Analysis &a, LEX *lex,        |      virtual LEX *
                                  const ProxyState &ps,         |          rewriteAndUpdate(Analysis &a, LEX *lex, const Preamble 
                                  const Preamble &preamble) con |              const {
    {                                                           <
                                                                |          /*collect the keys (and their types) as they may affect
                                                                >          const auto &key_data = collectKeyData(*lex);
                [&a, &ps, &tm] (List<Create_field> out_list,    |                  [&a, &tm, &key_data] (List<Create_field> out_li
                                Create_field *cf)               |                                        Create_field *cf){
            {                                                   |                      return createAndRewriteField(a, cf, &tm, fa
                    return createAndRewriteField(a, ps, cf, &tm |                                                   out_list);
                                                 false, out_lis <
    virtual LEX *rewriteAndUpdate(Analysis &a, LEX *lex,        |      virtual LEX *
                                  const ProxyState &ps,         |          rewriteAndUpdate(Analysis &a, LEX *lex, const Preamble 
                                  const Preamble &preamble) con |              const
            FieldMeta const &fm =                               <
                a.getFieldMeta(preamble.dbname, preamble.table, <
                               adrop->name);                    <
                                                                >              FieldMeta const &fm = a.getFieldMeta(tm, adrop->nam
        THD *thd = current_thd;                                 |          THD *const thd = current_thd;
        for (auto om_it = fm.children.begin(); om_it != fm.chil |          for (const auto &om_it : fm.getChildren()) {
             om_it++) {                                         <
            OnionMeta *const om = (*om_it).second.get();        |              OnionMeta *const om = om_it.second.get();
                                                                >
    virtual LEX *rewriteAndUpdate(Analysis &a, LEX *lex,        |      virtual LEX *
                                  const ProxyState &ps,         |          rewriteAndUpdate(Analysis &a, LEX *lex, const Preamble 
                                  const Preamble &preamble) con |              const{
    {                                                           |          FAIL_TextMessageError("implement ChangeColumnSubHandler
        assert(false);                                          <
class ForeignKeySubHandler : public AlterSubHandler {           |
    virtual LEX *rewriteAndUpdate(Analysis &a, LEX *lex,        |  /*added should update inplace*/
                                  const ProxyState &ps,         |  LEX * ForeignKeySubHandler::rewriteAndUpdate(Analysis &a, LEX *
                                  const Preamble &preamble) con |              const{
    {                                                           |         TableMeta const &ctm =
        throw CryptDBError("implement ForeignKeySubHandler!");  |              a.getTableMeta(preamble.dbname, preamble.table);
                                                                >          //find essential information from froeign key
                                                                >         auto it =
                                                                >               List_iterator<Key>(lex->alter_info.key_list);
                                                                >
                                                                >         while(auto cur = it++){
                                                                >             if(cur->type==Key::FOREIGN_KEY){
                                                                >                     Table_ident* ref_table = ((Foreign_key*)cur)
                                                                >                     std::string ref_table_name = convert_lex_str
                                                                >                     TableMeta const &reftm =
                                                                >                          a.getTableMeta(preamble.dbname, ref_tab
                                                                >                     auto it_ref_columns = List_iterator<Key_part
                                                                >                     //should find Only ope, and adjust it to OPE
                                                                >                     while(auto cur_ref_columns=it_ref_columns++)
                                                                >                          std::string ref_column_name = convert_l
                                                                >                          OnionMeta *om = a.getOnionMeta2(preambl
                                                                >                          FieldMeta &reffm = a.getFieldMeta(reftm
                                                                >                          assert(om!=NULL);
                                                                >                          if(om->getLayerBack()->level()==SECLEVE
                                                                >                             om->getLayerBack()->level()==SECLEVE
                                                                >                             OnionAdjustExcept oje(reftm,reffm,oO
                                                                >                             throw oje; 
                                                                >                          }else if(om->getLayerBack()->level()==S
                                                                >                             //nothing here
                                                                >                          }else{
                                                                >                              assert(0);
                                                                >                          }
                                                                >                     }
                                                                >            }else if(cur->type==Key::MULTIPLE){//adjust to OPEFRO
                                                                >                auto it_columns = List_iterator<Key_part_spec>(cu
                                                                >                while(auto go = it_columns++){
                                                                >                    std::string current_field_name = convert_lex_
                                                                >                    OnionMeta *om = a.getOnionMeta2(preamble.dbna
                                                                >                    if(om!=NULL){ 
                                                                >                        if(om->getLayerBack()->level()==SECLEVEL:
                                                                >                          om->getLayerBack()->level()==SECLEVEL::
                                                                >                            const FieldMeta &fm = a.getFieldMeta(
                                                                >                            OnionAdjustExcept oje(ctm,fm,oOPE,SEC
                                                                >                            throw oje;
                                                                >                        }else if(om->getLayerBack()->level()==SEC
                                                                >                            //nothing
                                                                >                        }else{
                                                                >                           assert(0);
};                                                              |                    }
                                                                >               }
                                                                >            }else{
                                                                >                assert(0);
                                                                >                return NULL;
                                                                >            }
                                                                >         }
                                                                >         highLevelRewriteKey(ctm, *lex, lex, a);
                                                                >         highLevelRewriteForeignKey(ctm,*lex,lex,a,preamble.table
class AddIndexSubHandler : public AlterSubHandler {             |         return lex;
    virtual LEX *rewriteAndUpdate(Analysis &a, LEX *lex,        |  }
                                  const ProxyState &ps,         |
                                  const Preamble &preamble) con |
    {                                                           |  LEX * AddIndexSubHandler::rewriteAndUpdate(Analysis &a, LEX *le
                                                                >      
                                                                >          if(lex->alter_info.flags & ALTER_FOREIGN_KEY) return le
                                                                >          //LEX *const new_lex = copyWithTHD(lex);
                                                                |          //before rewriting key, we should check the layers of t
        // Add each new index.                                  |          auto it =
        auto key_it =                                           <
        lex->alter_info.key_list =                              |          while(auto cur = it++){
            accumList<Key>(key_it,                              |              //for each key, find the columns
                [&tm, &a] (List<Key> out_list, Key *const key)  |              switch(cur->type){
                    // -----------------------------            |                  case Key::PRIMARY:
                    //         Rewrite INDEX                    |                  case Key::UNIQUE:
                    // -----------------------------            |                  case Key::MULTIPLE:
                    auto new_keys = rewrite_key(tm, key, a);    |                  case Key::FULLTEXT:
                    out_list.concat(vectorToListWithTHD(new_key |                  case Key::SPATIAL:{
                                                                |                      //for each column, find the 
                    return out_list;    /* lambda */            |                      auto it_columns = List_iterator<Key_part_sp
            });                                                 |                      while(auto go = it_columns++){
                                                                >                          std::string current_field_name = conver
                                                                >                          OnionMeta *om = a.getOnionMeta2(preambl
                                                                >                          if(om!=NULL){
                                                                >                              //Remove RND here(reference rewrite
                                                                >                             if(om->getLayerBack()->level()==SECL
                                                                >                                  const TableMeta &tm = a.getTabl
                                                                >                                  const FieldMeta &fm = a.getFiel
                                                                >                                  OnionAdjustExcept oje(tm,fm,oDE
                                                                >                                  throw oje;
                                                                >                             }
                                                                >                          }
                                                                >                          om = a.getOnionMeta2(preamble.dbname,pr
                                                                >                          if(om!=NULL){
                                                                >                              //Still remove RND here
                                                                >                              if(om->getLayerBack()->level()==SEC
                                                                >                                  const TableMeta &tm = a.getTabl
                                                                >                                  const FieldMeta &fm = a.getFiel
                                                                >                                  OnionAdjustExcept oje(tm,fm,oOP
                                                                >                                  throw oje;
                                                                >                              }
                                                                >                          }
                                                                >                      }
                                                                >                      break;
                                                                >                  }
                                                                >                  case Key::FOREIGN_KEY:{
                                                                >                      //assert(0);
                                                                >                      //do nothing here
                                                                >                  }
                                                                >              }
                                                                >          }
                                                                >          //if we have foreign, then no need to rewrite here
                                                                >          highLevelRewriteKey(tm, *lex, lex, a);
};                                                              |
    virtual LEX *rewriteAndUpdate(Analysis &a, LEX *lex,        |      virtual LEX *
                                  const ProxyState &ps,         |          rewriteAndUpdate(Analysis &a, LEX *lex, const Preamble 
                                  const Preamble &preamble) con |              const
    virtual LEX *rewriteAndUpdate(Analysis &a, LEX *const lex,  |      virtual LEX *
                                  const ProxyState &ps,         |          rewriteAndUpdate(Analysis &a, LEX *const lex,
LEX *AlterSubHandler::transformLex(Analysis &a, LEX *lex,       |  LEX *AlterSubHandler::
                                   const ProxyState &ps) const  |  transformLex(Analysis &a, LEX *const lex) const
    return this->rewriteAndUpdate(a, lex, ps, preamble);        |      return this->rewriteAndUpdate(a, lex, preamble);
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/alter_sub_handler.hh Practical-Cryptdb/main/alter_sub_handler.hh
struct Preamble {                                               |  class AlterSubHandler {
    Preamble(const std::string &dbname, const std::string &tabl <
        : dbname(dbname), table(table) {}                       <
    const std::string dbname;                                   <
    const std::string table;                                    <
};                                                              <
                                                                <
class AlterSubHandler : public SQLHandler {                     <
    virtual LEX *transformLex(Analysis &a, LEX *lex,            |      virtual LEX *
                              const ProxyState &ps) const;      |          transformLex(Analysis &a, LEX *lex) const;
                                  const ProxyState &ps,         <
                                                                >
                                                                >  class AddIndexSubHandler : public AlterSubHandler {
                                                                >      virtual LEX *
                                                                >          rewriteAndUpdate(Analysis &a, LEX *lex, const Preamble 
                                                                >
                                                                >  };
                                                                >
                                                                >  class ForeignKeySubHandler : public AlterSubHandler{
                                                                >      virtual LEX *
                                                                >          rewriteAndUpdate(Analysis &a, LEX *lex, const Preamble 
                                                                >  };
                                                                >
                                                                >
                                                                >
                                                                >
                                                                >
                                                                >
                                                                >
                                                                >
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/Analysis.cc Practical-Cryptdb/main/Analysis.cc
                                                                |  #include <util/util.hh>
// FIXME: Memory leaks when we allocate MetaKey<...>, use smart <
    TEST_TextMessageError(0 != fm->children.size(),             |      TEST_TextMessageError(0 != fm->getChildren().size(),
                                                                <
    for (auto pair = fm->children.begin(); pair != fm->children |      for (const auto &pair : fm->getChildren()) {
         pair++) {                                              |          OnionMeta *const om = pair.second.get();
        OnionMeta *const om = (*pair).second.get();             |          OnionMetaKey const &key = pair.first;
        OnionMetaKey const &key = (*pair).first;                |          //就是当前的onionmeta的back 对应的level
    for (auto it2 = es2.osl.begin();                            |      for (const auto &it2 : es2.osl) {
            it2 != es2.osl.end(); ++it2) {                      |          auto it = osl.find(it2.first);
        auto it = osl.find(it2->first);                         <
            FieldMeta * const fm2 = it2->second.second;         |              FieldMeta * const fm2 = it2.second.second;
            const onion o2 = it2->first;                        |              const onion o2 = it2.first;
                            static_cast<int>(it2->second.first) |                              static_cast<int>(it2.second.first))
            << ", field `" << (it.second.second == NULL ? "*" : |              << ", field `" << (it.second.second == NULL ? "*" :
EncSet::chooseOne() const                                       |  EncSet::chooseOne() const {
{                                                               <
    out << r.item << " PRODUCES encset " << r.encset << std::en |      out << r.string_item << " PRODUCES encset " << r.encset << 
                                                                <
/*                                                              <
void                                                            <
RewritePlan::restrict(const EncSet & es) {                      <
    es_out = es_out.intersect(es);                              <
    assert_s(!es_out.empty(), "after restrict rewrite plan has  <
                                                                <
    if (plan.size()) { //node has children                      <
        for (auto pair = plan.begin(); pair != plan.end(); pair <
            if (!es.contains(pair->first)) {                    <
            plan.erase(pair);                                   <
            }                                                   <
        }                                                       <
    }                                                           <
}                                                               <
*/                                                              <
                                                                <
                                                                >      assert((0 == l[0]) == (NULL == row[0]));
        assert(0 == l[0] && NULL == row[0]);                    <
    const std::string query = "USE " + db + ";";                |      const std::string query = "USE " + quoteText(db) + ";";
                                                                >  //建立cryptdb_udf,保持当前db,删除原有的函数,create一系列的funct
ProxyState::ProxyState(ConnectionInfo ci, const std::string &em |  SharedProxyState::SharedProxyState(ConnectionInfo ci,
                                                                >                                     const std::string &embed_dir
      mysql_dummy(ProxyState::db_init(embed_dir)), // HACK: All |        embed_dir(embed_dir),
                                                                >        mysql_dummy(SharedProxyState::db_init(embed_dir)), // HAC
      e_conn(Connect::getEmbedded(embed_dir)),                  |        default_sec_rating(default_sec_rating),
      default_sec_rating(default_sec_rating)                    |        cache(std::move(SchemaCache()))
    assert(conn && e_conn);                                     <
    const std::string &prefix =                                 |      // make sure the server was not started in SQL_SAFE_UPDATES
                                                                >      // > it might not even be possible to start the server in t
                                                                >      //   better to be safe
                                                                >      {
                                                                >          std::unique_ptr<DBResult> dbres;
                                                                >          assert(conn->execute("SELECT @@sql_safe_updates", &dbre
                                                                >          assert(1 == mysql_num_rows(dbres->n));
                                                                >
                                                                >          const MYSQL_ROW row = mysql_fetch_row(dbres->n);
                                                                >          const unsigned long *const l = mysql_fetch_lengths(dbre
                                                                >          const unsigned long value = std::stoul(std::string(row[
                                                                >          assert(0 == value);
                                                                >      }
                                                                >
                                                                >      std::unique_ptr<Connect>
                                                                >          init_e_conn(Connect::getEmbedded(embed_dir));
                                                                >      assert(conn && init_e_conn);
                                                                >
                                                                >      const std::string prefix = 
    assert(MetaData::initialize(conn, e_conn, prefix));         |      //初始化embedded的表
                                                                |      assert(MetaData::initialize(conn, init_e_conn, prefix));
    TEST_TextMessageError(synchronizeDatabases(conn, e_conn),   |      //两头的defaultdb是一样的
                                                                >      TEST_TextMessageError(synchronizeDatabases(conn, init_e_con
ProxyState::~ProxyState()                                       |  SharedProxyState::~SharedProxyState() {
{                                                               |
    // mysql_library_end();                                     <
int ProxyState::db_init(const std::string &embed_dir)           |  int
                                                                >  SharedProxyState::db_init(const std::string &embed_dir)
std::string Delta::tableNameFromType(TableType table_type) cons |  ProxyState::~ProxyState() {}
                                                                >
                                                                >  SECURITY_RATING
                                                                >  ProxyState::defaultSecurityRating() const
    switch (table_type) {                                       |      return shared.defaultSecurityRating();
        case REGULAR_TABLE: {                                   <
            return MetaData::Table::metaObject();               <
        case BLEEDING_TABLE: {                                  |
            return MetaData::Table::bleedingMetaObject();       |  const std::unique_ptr<AES_KEY> &
                                                                >  ProxyState::getMasterKey() const
                                                                >  {
                                                                >      return shared.getMasterKey();
        default: {                                              |
            FAIL_TextMessageError("Unrecognized table type!");  |  const std::unique_ptr<Connect> &
                                                                >  ProxyState::getConn() const
                                                                >  {
                                                                >      return shared.getConn();
                                                                >
                                                                >  const std::unique_ptr<Connect> &
                                                                >  ProxyState::getEConn() const
                                                                >  {
                                                                >      return e_conn;
                                                                >
                                                                >  static void
                                                                >  embeddedTHDCleanup(THD *thd)
                                                                >  {
                                                                >      thd->clear_data_list();
                                                                >      --thread_count;
                                                                >      // thd->unlink() is called in by THD destructor
                                                                >      // > THD::~THD()
                                                                >      //     ilink::~ilink()
                                                                >      //       ilink::unlink()
                                                                >      // free_root(thd->main_mem_root, 0) is called in THD::~THD
                                                                >      delete thd;
// Recursive.                                                   |  void
bool CreateDelta::apply(const std::unique_ptr<Connect> &e_conn, |  ProxyState::safeCreateEmbeddedTHD()
                        TableType table_type)                   <
    const std::string table_name = tableNameFromType(table_type |      //THD is created by new, so there is no Lex or other things
    std::function<bool(const DBMeta &, const DBMeta &,          |      THD *thd = static_cast<THD *>(create_embedded_thd(0));
                       const AbstractMetaKey * const,           |      assert(thd);
                       const unsigned int * const)> helper =    |      thds.push_back(std::unique_ptr<THD,
        [&e_conn, &helper, table_name] (const DBMeta &object,   |                                     void (*)(THD *)>(thd,
                                        const DBMeta &parent,   |                                         &embeddedTHDCleanup));
                                        const AbstractMetaKey * |      return;
                               const unsigned int * const ptr_p <
    {                                                           <
        const std::string child_serial = object.serialize(paren <
        assert(0 == object.getDatabaseID());                    <
        unsigned int parent_id;                                 <
        if (ptr_parent_id) {                                    <
            parent_id = *ptr_parent_id;                         <
        } else {                                                <
            parent_id = parent.getDatabaseID();                 <
        std::function<std::string(const DBMeta &, const DBMeta  |  void ProxyState::dumpTHDs()
                                  const AbstractMetaKey *const) <
            getSerialKey =                                      <
                [] (const DBMeta &p, const DBMeta &o,           <
                    const AbstractMetaKey *const keee)          <
                if (NULL == keee) {                             |      for (auto &it : thds) {
                    return p.getKey(o).getSerial();  /* lambda  |          it.release();
                                                                >      thds.clear();
                return keee->getSerial();      /* lambda */     |      assert(0 == thds.size());
            };                                                  |  }
        const std::string serial_key = getSerialKey(parent, obj |  std::string Delta::tableNameFromType(TableType table_type) cons
        const std::string esc_serial_key =                      |      switch (table_type) {
            escapeString(e_conn, serial_key);                   |          case REGULAR_TABLE: {
                                                                >              return MetaData::Table::metaObject();
                                                                >          }
                                                                >          case BLEEDING_TABLE: {
                                                                >              return MetaData::Table::bleedingMetaObject();
                                                                >          }
                                                                >          default: {
                                                                >              FAIL_TextMessageError("Unrecognized table type!");
                                                                >          }
                                                                >      }
                                                                >  }
        // ------------------------                             <
        //    Build the queries.                                <
        // ------------------------                             <
        // On CREATE, the database generates a unique ID for us |  /*insert into the metadata table (kv) and then apply this to ch
        const std::string esc_child_serial =                    |  static 
                                                                >  bool create_delta_helper(CreateDelta* this_is, const std::uniqu
                                                                >                 const AbstractMetaKey &meta_me_key, const unsign
                                                                >          /*serialize the metame and meta_me_key, and escape*/
                                                                >          const std::string &child_serial = meta_me.serialize(par
                                                                >          assert(0 == meta_me.getDatabaseID());
                                                                >          const std::string &serial_key = meta_me_key.getSerial()
                                                                >          const std::string &esc_serial_key =
                                                                >              escapeString(e_conn, serial_key);
                                                                >          const std::string &esc_child_serial =
        const std::string query =                               |          /*id is 0 for the first time, and after that we can fet
                                                                >          AssignOnce<unsigned int> old_object_id;
                                                                >          if (Delta::BLEEDING_TABLE == table_type){
                                                                >              old_object_id = 0;
                                                                >          } else {
                                                                >              assert(Delta::REGULAR_TABLE == table_type);
                                                                >              auto const &cached = this_is->get_id_cache().find(&
                                                                >              assert(cached != this_is->get_id_cache().end());
                                                                >              old_object_id = cached->second;
                                                                >          }
                                                                >          /*(serial_object, serial_key, parent_id, id) is (meta_m
                                                                >          const std::string &query =
            "    (serial_object, serial_key, parent_id) VALUES  |              "    (serial_object, serial_key, parent_id, id) VAL
            " " + std::to_string(parent_id) + ");";             |              " " + std::to_string(parent_id) + ","
                                                                >              " " + std::to_string(old_object_id.get()) + ");";
                                                                >
                                                                >          //this is the id of meta_me, which should be the parent
                                                                >          /*we first insert into bleeding_table {meta_me,last_ins
                                                                >          if (Delta::BLEEDING_TABLE == table_type) {
                                                                >              assert(this_is->get_id_cache().find(&meta_me) == th
                                                                >              this_is->get_id_cache()[&meta_me] = object_id;
                                                                >          } else {
                                                                >              /*and then erase the item from cache*/
                                                                >              assert(Delta::REGULAR_TABLE == table_type);
                                                                >              // should only be used one time
                                                                >              this_is->get_id_cache().erase(&meta_me);
                                                                >          }
            [&object, object_id, &helper]                       |              [&meta_me, object_id, this_is,&e_conn,table_type,ta
                (const DBMeta &child)                           |                  (const DBMeta &child){
            {                                                   |                  return create_delta_helper(this_is,e_conn, tabl
                return helper(child, object, NULL, &object_id); |                               child, meta_me, meta_me.getKey(chi
            };                                                  <
        return object.applyToChildren(localCreateHandler);      <
                                                                >          return meta_me.applyToChildren(localCreateHandler);
                                                                >  }
    return helper(*meta.get(), parent_meta, &key, NULL);        |  // Recursive.
                                                                >  // > the hackery around BLEEDING v REGULAR ensures that both ta
                                                                >  //   same ID for equivalent objects regardless of differences b
                                                                >  //   auto_increment on the BLEEDING and REGULAR tables
                                                                >  bool CreateDelta::apply(const std::unique_ptr<Connect> &e_conn,
                                                                >                          Delta::TableType table_type){
                                                                >      //第一次apply,先写bleeding table.这个时候,map里面没有内容.
                                                                >      if (BLEEDING_TABLE == table_type) {
                                                                >          assert(0 == id_cache.size());
                                                                >      }
                                                                >      const std::string &table_name = tableNameFromType(table_typ
                                                                >      const bool b =
                                                                >          create_delta_helper(this,e_conn,table_type,table_name,
                                                                >                    *meta.get(), parent_meta, key, parent_meta.ge
                                                                >      if (BLEEDING_TABLE == table_type) {
                                                                >          assert(0 != this->id_cache.size());
                                                                >      } else {
                                                                >          assert(REGULAR_TABLE == table_type);
                                                                >          assert(0 == this->id_cache.size());
                                                                >      return b;
                                                                >  }
                                                                >
                                                                >  // FIXME: used incorrectly, as we should be doing copy construc
                                                                >  // on the original object; not modifying it in place
                        TableType table_type)                   |                          TableType table_type){
{                                                               <
    helper(meta, parent_meta);                                  |      return helper(meta, parent_meta);
    return true;                                                <
}                                                               <
                                                                <
RewriteOutput::~RewriteOutput()                                 <
{;}                                                             <
                                                                <
bool RewriteOutput::doDecryption() const                        <
{                                                               <
    return true;                                                <
}                                                               <
                                                                <
bool RewriteOutput::stalesSchema() const                        <
{                                                               <
    return false;                                               <
}                                                               <
                                                                <
bool RewriteOutput::multipleResultSets() const                  <
{                                                               <
    return false;                                               <
}                                                               <
                                                                <
QueryAction                                                     <
RewriteOutput::queryAction(const std::unique_ptr<Connect> &conn <
{                                                               <
    return QueryAction::VANILLA;                                <
RewriteOutput::usesEmbeddedDB() const                           |  writeDeltas(const std::unique_ptr<Connect> &e_conn,
{                                                               |              const std::vector<std::unique_ptr<Delta> > &deltas,
    return false;                                               |              Delta::TableType table_type)
}                                                               <
                                                                <
void                                                            <
SimpleOutput::beforeQuery(const std::unique_ptr<Connect> &conn, <
                          const std::unique_ptr<Connect> &e_con <
{                                                               <
    return;                                                     <
}                                                               <
                                                                <
void                                                            <
SimpleOutput::getQuery(std::list<std::string> *const queryz,    <
                       SchemaInfo const &) const                <
{                                                               <
    queryz->clear();                                            <
    queryz->push_back(original_query);                          <
                                                                <
    return;                                                     <
}                                                               <
                                                                <
void                                                            <
SimpleOutput::afterQuery(const std::unique_ptr<Connect> &e_conn <
{                                                               <
    return;                                                     <
}                                                               <
                                                                <
bool SimpleOutput::doDecryption() const                         <
    return false;                                               |      for (const auto &it : deltas) {
                                                                >          RFIF(it->apply(e_conn, table_type));
                                                                <
void                                                            <
DMLOutput::beforeQuery(const std::unique_ptr<Connect> &conn,    <
                       const std::unique_ptr<Connect> &e_conn)  <
{                                                               <
    return;                                                     <
}                                                               <
                                                                <
void                                                            <
DMLOutput::getQuery(std::list<std::string> * const queryz,      <
                    SchemaInfo const &) const                   <
{                                                               <
    queryz->clear();                                            <
    queryz->push_back(new_query);                               <
                                                                <
    return;                                                     <
}                                                               <
                                                                <
void                                                            <
DMLOutput::afterQuery(const std::unique_ptr<Connect> &e_conn) c <
{                                                               <
    return;                                                     <
}                                                               <
                                                                <
void                                                            <
SpecialUpdate::beforeQuery(const std::unique_ptr<Connect> &conn <
                           const std::unique_ptr<Connect> &e_co <
{                                                               <
    // Retrieve rows from database.                             <
    const std::string select_q =                                <
        " SELECT * FROM " + this->plain_table +                 <
        " WHERE " + this->where_clause + ";";                   <
    std::unique_ptr<SchemaCache> schema_cache(new SchemaCache() <
    // Onion adjustment will never occur in this nested execute <
    // because the WHERE clause will trigger the adjustment in  <
    // UpdateHandler when it tries to rewrite the filters.      <
    const EpilogueResult epi_result =                           <
        executeQuery(this->ps, select_q, this->default_db,      <
                     schema_cache.get());                       <
    TEST_Sync(schema_cache->cleanupStaleness(e_conn),           <
              "failed to cleanup schema cache after nested quer <
    assert(QueryAction::VANILLA == epi_result.action);          <
    const ResType select_res_type = epi_result.res_type;        <
    assert(select_res_type.success());                          <
    if (select_res_type.rows.size() == 0) { // No work to be do <
        this->do_nothing = true;                                <
        return;                                                 <
    }                                                           <
    this->do_nothing = false;                                   <
                                                                <
    const auto pullItemPtr = [](std::shared_ptr<Item> p) -> con <
    {                                                           <
        return *p;                                              <
    };                                                          <
    const std::function<std::string(std::shared_ptr<Item>)>     <
        sharedItemToStringWithQuotes =                          <
            fnCompose<std::shared_ptr<Item>, const Item &,      <
                      std::string>(ItemToStringWithQuotes, pull <
    const auto itemJoin =                                       <
        [&sharedItemToStringWithQuotes]                         <
            (std::vector<std::shared_ptr<Item> > row) -> std::s <
    {                                                           <
        return "(" +                                            <
               vector_join<std::shared_ptr<Item> >(row, ",",    <
                                        sharedItemToStringWithQ <
               ")";                                             <
    };                                                          <
                                                                <
    const std::string values_string =                           <
        vector_join<std::vector<std::shared_ptr<Item> > >(      <
                                            select_res_type.row <
                                            itemJoin);          <
                                                                <
    // Do the query on the embedded database inside of a transa <
    // so that we can prevent failure artifacts from populating <
    // embedded dabase.                                         <
    TEST_Sync(e_conn->execute("START TRANSACTION;"),            <
              "failed to start transaction");                   <
                                                                <
    // Push the plaintext rows to the embedded database.        <
    const std::string push_q =                                  <
        " INSERT INTO " + this->plain_table +                   <
        " VALUES " + values_string + ";";                       <
    SYNC_IF_FALSE(e_conn->execute(push_q), e_conn);             <
                                                                <
    // Run the original (unmodified) query on the data in the e <
    // database.                                                <
    SYNC_IF_FALSE(e_conn->execute(this->original_query), e_conn <
                                                                <
    // > Collect the results from the embedded database.        <
    // > This code relies on single threaded access to the data <
    //   and on the fact that the database is cleaned up after  <
    //   every such operation.                                  <
    std::unique_ptr<DBResult> dbres;                            <
    const std::string select_results_q =                        <
        " SELECT * FROM " + this->plain_table + ";";            <
    SYNC_IF_FALSE(e_conn->execute(select_results_q, &dbres), e_ <
    const ResType interim_res = ResType(dbres->unpack());       <
    this->output_values =                                       <
        vector_join<std::vector<std::shared_ptr<Item> > >(      <
                                        interim_res.rows, ",",  <
                                        itemJoin);              <
    // Cleanup the embedded database.                           <
    const std::string cleanup_q =                               <
        "DELETE FROM " + this->plain_table + ";";               <
    SYNC_IF_FALSE(e_conn->execute(cleanup_q), e_conn);          <
                                                                <
    SYNC_IF_FALSE(e_conn->execute("COMMIT;"), e_conn);          <
                                                                <
    return;                                                     <
}                                                               <
                                                                <
void                                                            <
SpecialUpdate::getQuery(std::list<std::string> * const queryz,  <
                        SchemaInfo const &schema) const         <
{                                                               <
    assert(queryz);                                             <
                                                                <
    queryz->clear();                                            <
                                                                <
    if (true == this->do_nothing.get()) {                       <
        queryz->push_back(mysql_noop());                        <
        return;                                                 <
    }                                                           <
                                                                <
    // This query is necessary to propagate a transaction into  <
    // INFORMATION_SCHEMA.                                      <
    queryz->push_back("SELECT NULL FROM " + this->crypted_table <
                                                                <
    // DELETE the rows matching the WHERE clause from the datab <
    const std::string delete_q =                                <
        " DELETE FROM " + this->plain_table +                   <
        " WHERE " + this->where_clause + ";";                   <
    const std::string re_delete =                               <
        rewriteAndGetSingleQuery(ps, delete_q, schema, this->de <
                                                                <
    // > Add each row from the embedded database to the data da <
    const std::string insert_q =                                <
        " INSERT INTO " + this->plain_table +                   <
        " VALUES " + this->output_values.get() + ";";           <
    const std::string re_insert =                               <
        rewriteAndGetSingleQuery(ps, insert_q, schema, this->de <
                                                                <
    const std::string hom_addition_transaction =                <
        MetaData::Proc::homAdditionTransaction();               <
    queryz->push_back(" CALL " + hom_addition_transaction + " ( <
                      " '" + escapeString(ps.getConn(), re_dele <
                      " '" + escapeString(ps.getConn(),         <
                                          re_insert) + "');");  <
                                                                <
    return;                                                     <
}                                                               <
                                                                <
void                                                            <
SpecialUpdate::afterQuery(const std::unique_ptr<Connect> &e_con <
{                                                               <
    return;                                                     <
}                                                               <
                                                                <
bool                                                            <
SpecialUpdate::multipleResultSets() const                       <
{                                                               <
SpecialUpdate::usesEmbeddedDB() const                           |  deltaOutputBeforeQuery(const std::unique_ptr<Connect> &e_conn,
                                                                >                         const std::string &original_query,
                                                                >                         const std::string &rewritten_query,
                                                                >                         const std::vector<std::unique_ptr<Delta>
                                                                >                         CompletionType completion_type,
                                                                >                         uint64_t *const embedded_completion_id)
    return true;                                                <
}                                                               <
DeltaOutput::~DeltaOutput()                                     |      const std::string &escaped_original_query =
{;}                                                             |          escapeString(e_conn, original_query);
                                                                >      const std::string &escaped_rewritten_query =
                                                                >          escapeString(e_conn, rewritten_query);
bool DeltaOutput::stalesSchema() const                          <
{                                                               <
    return true;                                                <
}                                                               <
void                                                            |
DeltaOutput::beforeQuery(const std::unique_ptr<Connect> &conn,  |      RFIF(escaped_original_query.length()  <= STORED_QUERY_LENGT
                         const std::unique_ptr<Connect> &e_conn |        && escaped_rewritten_query.length() <= STORED_QUERY_LENGT
{                                                               |
    TEST_Sync(e_conn->execute("START TRANSACTION;"),            |      RFIF(e_conn->execute("START TRANSACTION;"));
              "failed to start transaction");                   <
    const CompletionType &completion_type = this->getCompletion |      // FIXME: NOTE: was previously escaping against remote data
        "   (begin, complete, original_query, default_db, abort |          "   (complete, original_query, rewritten_query, default
        "   VALUES (TRUE,  FALSE,"                              |          "   VALUES (FALSE, '" + escaped_original_query + "',"
        "    '" + escapeString(conn, this->original_query) + "' |          "          '" + escaped_rewritten_query + "',"
        "    '" + TypeText<CompletionType>::toText(completion_t |          "           '" + TypeText<CompletionType>::toText(compl
            + "');";                                            |          "          );";
    SYNC_IF_FALSE(e_conn->execute(q_completion), e_conn);       |      ROLLBACK_AND_RFIF(e_conn->execute(q_completion), e_conn);
    this->embedded_completion_id = e_conn->last_insert_id();    |      *embedded_completion_id = e_conn->last_insert_id();
                                                                >      assert(*embedded_completion_id);
    for (auto it = deltas.begin(); it != deltas.end(); it++) {  |      ROLLBACK_AND_RFIF(writeDeltas(e_conn, deltas, Delta::BLEEDI
        const bool b = (*it)->apply(e_conn, Delta::BLEEDING_TAB <
        SYNC_IF_FALSE(b, e_conn);                               <
    }                                                           <
    SYNC_IF_FALSE(e_conn->execute("COMMIT;"), e_conn);          |      ROLLBACK_AND_RFIF(e_conn->execute("COMMIT;"), e_conn);
    return;                                                     |      return true;
void                                                            |  bool
DeltaOutput::afterQuery(const std::unique_ptr<Connect> &e_conn) |  deltaOutputAfterQuery(const std::unique_ptr<Connect> &e_conn,
                                                                >                        const std::vector<std::unique_ptr<Delta> 
                                                                >                        uint64_t embedded_completion_id)
    TEST_Sync(e_conn->execute("START TRANSACTION;"),            |
              "failed to start transaction");                   |      RFIF(e_conn->execute("START TRANSACTION;"));
                 std::to_string(this->embedded_completion_id.ge |                   std::to_string(embedded_completion_id) + ";";
    SYNC_IF_FALSE(e_conn->execute(q_update), e_conn);           |      ROLLBACK_AND_RFIF(e_conn->execute(q_update), e_conn);
    for (auto it = deltas.begin(); it != deltas.end(); it++) {  |      ROLLBACK_AND_RFIF(writeDeltas(e_conn, deltas, Delta::REGULA
        const bool b = (*it)->apply(e_conn, Delta::REGULAR_TABL <
        SYNC_IF_FALSE(b, e_conn);                               <
    }                                                           <
    SYNC_IF_FALSE(e_conn->execute("COMMIT;"), e_conn);          |      ROLLBACK_AND_RFIF(e_conn->execute("COMMIT;"), e_conn);
    return;                                                     <
}                                                               <
                                                                <
bool                                                            <
DeltaOutput::usesEmbeddedDB() const                             <
{                                                               <
unsigned long                                                   <
DeltaOutput::getEmbeddedCompletionID() const                    <
{                                                               <
    return this->embedded_completion_id.get();                  <
}                                                               <
                                                                <
                                                                >
                                                                >
                                                                >
void                                                            <
DDLOutput::getQuery(std::list<std::string> * const queryz,      <
                    SchemaInfo const &) const                   <
{                                                               <
    queryz->clear();                                            <
                                                                <
    assert(remote_qz().size() == 1);                            <
    const std::string &remote_begin =                           <
        " INSERT INTO " + MetaData::Table::remoteQueryCompletio <
        "   (begin, complete, embedded_completion_id, reissue)  <
        "   (TRUE,  FALSE," +                                   <
             std::to_string(this->getEmbeddedCompletionID()) +  <
        "    , FALSE);";                                        <
    const std::string &remote_complete =                        <
        " UPDATE " + MetaData::Table::remoteQueryCompletion() + <
        "    SET complete = TRUE"                               <
        "  WHERE embedded_completion_id = " +                   <
             std::to_string(this->getEmbeddedCompletionID()) +  <
                                                                <
    queryz->push_back(remote_begin);                            <
    queryz->push_back(remote_qz().back());                      <
    queryz->push_back(remote_complete);                         <
                                                                <
    return;                                                     <
}                                                               <
                                                                <
void                                                            <
DDLOutput::afterQuery(const std::unique_ptr<Connect> &e_conn) c <
{                                                               <
    // Update embedded database.                                <
    // > This is a DDL query so do not put in transaction.      <
    TEST_Sync(e_conn->execute(this->original_query),            <
              "Failed to execute DDL query against embedded dat <
                                                                <
    return DeltaOutput::afterQuery(e_conn);                     <
}                                                               <
                                                                <
const std::list<std::string> DDLOutput::remote_qz() const       <
{                                                               <
    return std::list<std::string>({new_query});                 <
}                                                               <
                                                                <
const std::list<std::string> DDLOutput::local_qz() const        <
{                                                               <
    return std::list<std::string>({original_query});            <
}                                                               <
                                                                <
CompletionType DDLOutput::getCompletionType() const             <
{                                                               <
    return CompletionType::DDLCompletion;                       <
}                                                               <
                                                                <
void                                                            <
AdjustOnionOutput::beforeQuery(const std::unique_ptr<Connect> & <
                               const std::unique_ptr<Connect> & <
{                                                               <
    assert(deltas.size() > 0);                                  <
    return DeltaOutput::beforeQuery(conn, e_conn);              <
}                                                               <
                                                                <
void                                                            <
AdjustOnionOutput::getQuery(std::list<std::string> * const quer <
                            SchemaInfo const &) const           <
{                                                               <
    std::list<std::string> r_qz = remote_qz();                  <
    assert(r_qz.size() == 1 || r_qz.size() == 2);               <
                                                                <
    if (r_qz.size() == 1) {                                     <
        r_qz.push_back(mysql_noop());                           <
    }                                                           <
                                                                <
    // This query is necessary to propagate a transaction into  <
    // INFORMATION_SCHEMA.                                      <
    // > This allows consistent behavior even when adjustment i <
    // query in transaction.                                    <
    const std::string &innodb_table =                           <
        MetaData::Table::remoteQueryCompletion();               <
    queryz->push_back("SELECT NULL FROM " + innodb_table + ";") <
                                                                <
    const std::string q_remote =                                <
        " CALL " + MetaData::Proc::adjustOnion() + " ("         <
        "   "  + std::to_string(this->getEmbeddedCompletionID() <
        "   '" + hackEscape(r_qz.front()) + "', "               <
        "   '" + hackEscape(r_qz.back()) + "');";               <
                                                                <
    queryz->push_back(q_remote);                                <
    return;                                                     <
}                                                               <
                                                                <
void                                                            <
AdjustOnionOutput::afterQuery(const std::unique_ptr<Connect> &e <
    const                                                       <
{                                                               <
    assert(deltas.size() > 0);                                  <
    return DeltaOutput::afterQuery(e_conn);                     <
}                                                               <
                                                                <
const std::list<std::string> AdjustOnionOutput::remote_qz() con <
{                                                               <
    return std::list<std::string>(adjust_queries);              <
}                                                               <
                                                                <
const std::list<std::string> AdjustOnionOutput::local_qz() cons <
{                                                               <
    return std::list<std::string>();                            <
}                                                               <
                                                                <
QueryAction                                                     <
AdjustOnionOutput::queryAction(const std::unique_ptr<Connect> & <
    const                                                       <
{                                                               <
    const std::string q =                                       <
        " SELECT reissue "                                      <
        "   FROM " + MetaData::Table::remoteQueryCompletion() + <
        "  WHERE embedded_completion_id = " +                   <
                 std::to_string(this->getEmbeddedCompletionID() <
                                                                <
    std::unique_ptr<DBResult> db_res;                           <
    // FIXME: Throw exception.                                  <
    assert(conn->execute(q, &db_res));                          <
    assert(1 == mysql_num_rows(db_res->n));                     <
                                                                <
    MYSQL_ROW row = mysql_fetch_row(db_res->n);                 <
    unsigned long *const l = mysql_fetch_lengths(db_res->n);    <
    assert(l != NULL);                                          <
                                                                <
    const bool reissue = string_to_bool(std::string(row[0], l[0 <
                                                                <
    return reissue ? QueryAction::AGAIN : QueryAction::ROLLBACK <
}                                                               <
                                                                <
bool AdjustOnionOutput::doDecryption() const                    <
{                                                               <
    return false;                                               <
}                                                               <
                                                                <
CompletionType AdjustOnionOutput::getCompletionType() const     <
{                                                               <
    return CompletionType::AdjustOnionCompletion;               <
}                                                               <
                                                                <
                                                                >
    TEST_IdentifierNotFound(om, TypeText<onion>::toText(o));    |      //TEST_IdentifierNotFound(om, TypeText<onion>::toText(o)); 
                                                                <
                                                                >  OnionMeta *Analysis::getOnionMeta2(const FieldMeta &fm,
                                                                >                                    onion o) const
                                                                >  {
                                                                >      OnionMeta *const om = fm.getOnionMeta(o);
                                                                >      //TEST_IdentifierNotFound(om, TypeText<onion>::toText(o)); 
                                                                >      return om;
                                                                >  }
                                                                >
                                                                >
                                                                >  OnionMeta *Analysis::getOnionMeta2(const std::string &db,
                                                                >                                    const std::string &table,
                                                                >                                    const std::string &field,
                                                                >                                    onion o) const
                                                                >  {
                                                                >      return this->getOnionMeta2(this->getFieldMeta(db, table, fi
                                                                >  }
                                                                >
                                                                >
                                                                <
                                                                >  //这里的schema是一个层次的结构,通过analysis中的schema来判断data
                                       const std::string &table |                                         const std::string &table
                                                                >                                         bool *const is_alias) co
                                                                >      // tell the caller if you are giving him an alias
                                                                >      if (is_alias) {
                                                                >          *is_alias = this->isAlias(db, table);
                                                                >      }
                                                                >
EncLayer &Analysis::getBackEncLayer(const OnionMeta &om)        |  const EncLayer &Analysis::getBackEncLayer(const OnionMeta &om)
    return *om.layers.back().get();                             |      return *om.getLayers().back().get();
std::vector<std::unique_ptr<EncLayer>> const &                  |  SECLEVEL Analysis::getOnionLevel(const FieldMeta &fm, onion o)
                                                                >  {
                                                                >      if (false == fm.hasOnion(o)) {
                                                                >          return SECLEVEL::INVALID;
                                                                >      }
                                                                >
                                                                >      return Analysis::getOnionLevel(this->getOnionMeta(fm, o));
                                                                >  }
                                                                >
                                                                >  const std::vector<std::unique_ptr<EncLayer> > &
    return om.layers;                                           |      return om.getLayers();
    : RewritePlan(es_out, r), a(std::move(a))                   |      : RewritePlan(es_out, r), a(std::move(a)) {
{}                                                              |
                                                                >  }
                                                                >
                                                                >  std::string
                                                                >  lexToQuery(const LEX &lex)
                                                                >  {
                                                                >      std::ostringstream o;
                                                                >      o << const_cast<LEX &>(lex);
                                                                >      return o.str();
                                                                >  }
                                                                >
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/Analysis.hh Practical-Cryptdb/main/Analysis.hh
                                                                >      //for select 1+1, the field_called value is "1+1", so is th
                                                                >      //of the field.
                                                                >      //if the field is not salt, olk.key should get the fieldmet
                                                                <
                                                                >  class ProxyState;
                                                                >
typedef struct ProxyState {                                     |  typedef struct SharedProxyState {
    ProxyState(ConnectionInfo ci, const std::string &embed_dir, |      SharedProxyState(ConnectionInfo ci, const std::string &embe
               SECURITY_RATING default_sec_rating =             |                       SECURITY_RATING default_sec_rating);
                SECURITY_RATING::SENSITIVE);                    |      ~SharedProxyState();
    ~ProxyState();                                              <
    const std::unique_ptr<Connect> &getEConn() const {return e_ <
                                                                <
                                                                >      friend class ProxyState;
                                                                >
                                                                >      const std::string &embed_dir;
    // connection to remote and embedded server                 <
    const std::unique_ptr<Connect> e_conn;                      <
} ProxyState;                                                   |      const SchemaCache cache;
                                                                >  } SharedProxyState;
                                                                >  class ProxyState {
                                                                >  public:
                                                                >      ProxyState(SharedProxyState &shared)
                                                                >          : shared(shared),
                                                                >            e_conn(Connect::getEmbedded(shared.embed_dir)) {}
                                                                >      ~ProxyState();
                                                                >
                                                                >      SECURITY_RATING defaultSecurityRating() const;
                                                                >      const std::unique_ptr<AES_KEY> &getMasterKey() const;
                                                                >      const std::unique_ptr<Connect> &getConn() const;
                                                                >      const std::unique_ptr<Connect> &getEConn() const;
                                                                >      void safeCreateEmbeddedTHD();
                                                                >      void dumpTHDs();
                                                                >      const SchemaCache &getSchemaCache() const {return shared.ca
                                                                >      //conn 是大家共享, shared里面的, embedded是每个代理自己保持
                                                                >      std::shared_ptr<const SchemaInfo> getSchemaInfo() const
                                                                >          {return shared.cache.getSchema(this->getConn(), this->g
                                                                >
                                                                >  private:
                                                                >      const SharedProxyState &shared;
                                                                >      const std::unique_ptr<Connect> e_conn;
                                                                >      std::vector<std::unique_ptr<THD, void (*)(THD *)> > thds;
                                                                >  };
                                                                >
                                                                >  extern __thread ProxyState *thread_ps;
                                                                >      virtual ~Delta() {}
    bool save(const std::unique_ptr<Connect> &e_conn,           <
              unsigned long * const delta_output_id);           <
    bool destroyRecord(const std::unique_ptr<Connect> &e_conn); |      std::map<const DBMeta *, unsigned int> & get_id_cache(){ret
                                                                <
                                                                >      std::map<const DBMeta *, unsigned int> id_cache;
    bool save(const std::unique_ptr<Connect> &e_conn,           <
              unsigned long * const delta_output_id);           <
    bool destroyRecord(const std::unique_ptr<Connect> &e_conn); <
    bool save(const std::unique_ptr<Connect> &e_conn,           <
              unsigned long * const delta_output_id);           <
    bool destroyRecord(const std::unique_ptr<Connect> &e_conn); <
enum class QueryAction {VANILLA, AGAIN, ROLLBACK};              |  enum class CompletionType {DDL, Onion};
class RewriteOutput {                                           <
public:                                                         <
    RewriteOutput(const std::string &original_query)            <
        : original_query(original_query) {}                     <
    virtual ~RewriteOutput() = 0;                               <
                                                                <
    virtual void beforeQuery(const std::unique_ptr<Connect> &co <
                             const std::unique_ptr<Connect> &e_ <
    virtual void getQuery(std::list<std::string> *const queryz, <
                          SchemaInfo const &schema) const = 0;  <
    virtual void afterQuery(const std::unique_ptr<Connect> &e_c <
        const = 0;                                              <
    // This ASK code is a symptom of returning the rewritten qu <
    // to the proxy which then issues the query. A more TELL po <
    // would likely lead to cleaner execution of queries.       <
    virtual bool doDecryption() const;                          <
    virtual bool stalesSchema() const;                          <
    virtual bool multipleResultSets() const;                    <
    virtual QueryAction queryAction(const std::unique_ptr<Conne <
        const;                                                  <
    virtual bool usesEmbeddedDB() const;                        <
                                                                <
protected:                                                      <
    const std::string original_query;                           <
};                                                              <
class SimpleOutput : public RewriteOutput {                     |  //用于调用apply函数,写数据库
public:                                                         |  bool
    SimpleOutput(const std::string &original_query)             |  writeDeltas(const std::unique_ptr<Connect> &e_conn,
        : RewriteOutput(original_query) {}                      |              const std::vector<std::unique_ptr<Delta> > &deltas,
    ~SimpleOutput() {;}                                         |              Delta::TableType table_type);
                                                                |  bool
    void beforeQuery(const std::unique_ptr<Connect> &conn,      |  deltaOutputBeforeQuery(const std::unique_ptr<Connect> &e_conn,
                     const std::unique_ptr<Connect> &e_conn);   |                         const std::string &original_query,
    void getQuery(std::list<std::string> * const queryz,        |                         const std::string &rewritten_query,
                  SchemaInfo const &schema) const;              |                         const std::vector<std::unique_ptr<Delta>
    void afterQuery(const std::unique_ptr<Connect> &e_conn) con |                         CompletionType completion_type,
    bool doDecryption() const;                                  |                         uint64_t *const embedded_completion_id);
};                                                              <
                                                                <
class DMLOutput : public RewriteOutput {                        <
public:                                                         <
    DMLOutput(const std::string &original_query,                <
              const std::string &new_query)                     <
        : RewriteOutput(original_query), new_query(new_query) { <
    ~DMLOutput() {;}                                            <
                                                                <
    void beforeQuery(const std::unique_ptr<Connect> &conn,      <
                     const std::unique_ptr<Connect> &e_conn);   <
    void getQuery(std::list<std::string> * const queryz,        <
                  SchemaInfo const &schema) const;              <
    void afterQuery(const std::unique_ptr<Connect> &e_conn) con <
                                                                <
private:                                                        <
    const std::string new_query;                                <
};                                                              <
                                                                <
// Special case of DML query.                                   <
class SpecialUpdate : public RewriteOutput {                    <
public:                                                         <
    SpecialUpdate(const std::string &original_query,            <
                  const std::string &plain_table,               <
                  const std::string &crypted_table,             <
                  const std::string &where_clause,              <
                  const std::string &default_db,                <
                  const ProxyState &ps)                         <
    : RewriteOutput(original_query),                            <
      plain_table(plain_table), crypted_table(crypted_table),   <
      where_clause(where_clause), default_db(default_db), ps(ps <
    ~SpecialUpdate() {;}                                        <
                                                                <
    void beforeQuery(const std::unique_ptr<Connect> &conn,      <
                     const std::unique_ptr<Connect> &e_conn);   <
    void getQuery(std::list<std::string> * const queryz,        <
                  SchemaInfo const &schema) const;              <
    void afterQuery(const std::unique_ptr<Connect> &e_conn) con <
    bool multipleResultSets() const;                            <
    bool usesEmbeddedDB() const;                                <
                                                                <
private:                                                        <
    const std::string plain_table;                              <
    const std::string crypted_table;                            <
    const std::string where_clause;                             <
    const std::string default_db;                               <
    const ProxyState &ps;                                       <
                                                                <
    AssignOnce<std::string> output_values;                      <
    AssignOnce<bool> do_nothing;                                <
};                                                              <
                                                                <
enum class CompletionType {DDLCompletion, AdjustOnionCompletion <
                                                                <
class DeltaOutput : public RewriteOutput {                      <
public:                                                         <
    DeltaOutput(const std::string &original_query,              <
                std::vector<std::unique_ptr<Delta> > &&deltas)  <
        : RewriteOutput(original_query), deltas(std::move(delta <
    virtual ~DeltaOutput() = 0;                                 <
                                                                <
    void beforeQuery(const std::unique_ptr<Connect> &conn,      <
                     const std::unique_ptr<Connect> &e_conn);   <
    virtual void getQuery(std::list<std::string> * const queryz <
                          SchemaInfo const &schema) const = 0;  <
    void afterQuery(const std::unique_ptr<Connect> &e_conn) con <
    bool stalesSchema() const;                                  <
    bool usesEmbeddedDB() const;                                <
                                                                <
protected:                                                      <
    const std::vector<std::unique_ptr<Delta> > deltas;          <
                                                                <
    unsigned long getEmbeddedCompletionID() const;              <
    virtual CompletionType getCompletionType() const = 0;       <
                                                                <
private:                                                        <
    AssignOnce<unsigned long> embedded_completion_id;           <
};                                                              <
                                                                <
class DDLOutput : public DeltaOutput {                          <
public:                                                         <
    DDLOutput(const std::string &original_query,                <
              const std::string &new_query,                     <
              std::vector<std::unique_ptr<Delta> > &&deltas)    <
        : DeltaOutput(original_query, std::move(deltas)),       <
          new_query(new_query) {}                               <
    ~DDLOutput() {;}                                            <
                                                                <
    void getQuery(std::list<std::string> * const queryz,        <
                  SchemaInfo const &schema) const;              <
    void afterQuery(const std::unique_ptr<Connect> &e_conn) con <
                                                                <
protected:                                                      <
    CompletionType getCompletionType() const;                   <
private:                                                        |  bool
    const std::string new_query;                                |  deltaOutputAfterQuery(const std::unique_ptr<Connect> &e_conn,
                                                                >                        const std::vector<std::unique_ptr<Delta> 
                                                                >                        uint64_t embedded_completion_id);
    const std::list<std::string> remote_qz() const;             |  bool setRegularTableToBleedingTable(const std::unique_ptr<Conne
    const std::list<std::string> local_qz() const;              |  bool setBleedingTableToRegularTable(const std::unique_ptr<Conne
};                                                              <
class AdjustOnionOutput : public DeltaOutput {                  |  class KillZone {
    AdjustOnionOutput(const std::string &original_query,        |      enum class Where {Before, After};
                      std::vector<std::unique_ptr<Delta> > &&de |      KillZone() : active(false) {}
                      std::list<std::string> adjust_queries,    |      ~KillZone() {}
                      std::function<std::string(const std::stri |      void activate(uint64_t c, Where where) {
                        hackEscape)                             |          TEST_KillZoneFailure(false == active);
        : DeltaOutput(original_query, std::move(deltas)),       |          this->count  = c;
          adjust_queries(adjust_queries), hackEscape(hackEscape |          this->active = true;
    ~AdjustOnionOutput() {;}                                    |          this->where  = where;
    void beforeQuery(const std::unique_ptr<Connect> &conn,      |      }
                     const std::unique_ptr<Connect> &e_conn);   |      void die(Where where) {
    void getQuery(std::list<std::string> * const queryz,        |          if (this->active && this->where == where && !this->coun
                  SchemaInfo const &schema) const;              |              assert(false);
    void afterQuery(const std::unique_ptr<Connect> &e_conn) con |          }
    QueryAction queryAction(const std::unique_ptr<Connect> &con |      }
    bool doDecryption() const;                                  |      bool isActive() const {return active;}
                                                                <
protected:                                                      <
    CompletionType getCompletionType() const;                   <
                                                                <
    const std::list<std::string> adjust_queries;                |      bool active;
                                                                |      uint64_t count;
    const std::list<std::string> remote_qz() const;             |      Where where;
    const std::list<std::string> local_qz() const;              <
                                                                <
    // We don't want to pass a connection parameter to getQuery <
    // creates a misleading interface; but string escaping requ <
    // connection.                                              <
    // > hackEscape is the compromise.                          <
    const std::function<std::string(const std::string &)> hackE <
bool setRegularTableToBleedingTable(const std::unique_ptr<Conne <
bool setBleedingTableToRegularTable(const std::unique_ptr<Conne <
                                                                <
                                                                >
    Analysis(const Analysis &a) = delete;                       <
    Analysis(const std::string &default_db, const SchemaInfo &s |      Analysis(const std::string &default_db, const SchemaInfo &s
        : pos(0), special_update(false), db_name(default_db),   |               const std::unique_ptr<AES_KEY> &master_key,
          schema(schema) {}                                     |               SECURITY_RATING default_sec_rating)
                                                                >          : pos(0), inject_alias(false), summation_hack(false),
                                                                >            db_name(default_db), schema(schema), master_key(maste
                                                                >            default_sec_rating(default_sec_rating) {}
                                                                >      Analysis(const Analysis &analysis)
                                                                >          : pos(0), inject_alias(false), summation_hack(false),
                                                                >            db_name(analysis.getDatabaseName()), schema(analysis.
                                                                >            master_key(analysis.getMasterKey()),
                                                                >            default_sec_rating(analysis.getDefaultSecurityRating(
    unsigned int pos; // > a counter indicating how many projec |      unsigned int pos; // a counter indicating how many projecti
                                                                >      //each field may or may not has a salt field
                                                                >      //each Item has a rewrite plain, which lists possible way t
    bool special_update;                                        |      bool inject_alias;
                                                                >      bool summation_hack;
                                                                >      KillZone kill_zone;
                                                                >
                                                                >      OnionMeta* getOnionMeta2(const std::string &db,
                                                                >                              const std::string &table,
                                                                >                              const std::string &field, onion o) 
                                                                >
                                                                >      OnionMeta* getOnionMeta2(const FieldMeta &fm, onion o) cons
                                                                >
                                                                >
                                                                >
                                                                >
                                 const std::string &table) cons |                                   const std::string &table,
                                                                >                                   bool *const is_alias=NULL) con
                                                                >      //use this function to rewrite functions
    static EncLayer &getBackEncLayer(const OnionMeta &om);      |
                                                                >      static const EncLayer &getBackEncLayer(const OnionMeta &om)
                                                                >
    static std::vector<std::unique_ptr<EncLayer>> const &       |      SECLEVEL getOnionLevel(const FieldMeta &fm, onion o);
                                                                >
                                                                >      static const std::vector<std::unique_ptr<EncLayer> > &
    const SchemaInfo &getSchema() {return schema;}              <
                                                                >      const SchemaInfo &getSchema() const {return schema;}
                                                                <
                                                                >      const std::unique_ptr<AES_KEY> &getMasterKey() const {retur
                                                                >      SECURITY_RATING getDefaultSecurityRating() const
                                                                >          {return default_sec_rating;}
                                                                >      // access to isAlias(...)
                                                                >      friend class MultiDeleteHandler;
                                                                >      //name for the default db
                                                                |      const std::unique_ptr<AES_KEY> &master_key;
                                                                >      const SECURITY_RATING default_sec_rating;
                                                                >
                                                                >  std::string
                                                                >  lexToQuery(const LEX &lex);
Only in Practical-Cryptdb/main: big_proxy.cc
Only in Practical-Cryptdb/main: big_proxy.hh
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/cdb_test.cc Practical-Cryptdb/main/cdb_test.cc
                                                                <
#include <readline/readline.h>                                  <
#include <readline/history.h>                                   <
                                                                <
                                                                >  #include <main/sql_handler.hh>
                                                                >  #include <main/dml_handler.hh>
                                                                >  #include <main/ddl_handler.hh>
                                                                >  #include <main/metadata_tables.hh>
                                                                >  #include <main/macro_util.hh>
                                                                >  #include <main/CryptoHandlers.hh>
                                                                >
                                                                >  #include <parser/lex_util.hh>
                                                                >
                                                                >  #include <readline/readline.h>
                                                                >  #include <readline/history.h>
                                                                >
                                                                >  #include <util/enum_text.hh>
                                                                >  #include <util/yield.hpp>
                                                                >
                                                                >  #include <sstream>
                                                                >  #include <unistd.h>
                                                                >  #include <map>
                                                                >
                                                                >  using std::cout;
                                                                >  using std::cin;
                                                                >  using std::endl;
                                                                >  using std::string;
                                                                >  std::map<SECLEVEL,std::string> gmp;
                                                                >  std::map<onion,std::string> gmp2;
                                                                >
                                                                >
                                                                >  static std::string embeddedDir="/t/cryt/shadow";
                                                                >
                                                                >  //My WrapperState.
                                                                >  class WrapperState {
                                                                >      WrapperState(const WrapperState &other);
                                                                >      WrapperState &operator=(const WrapperState &rhs);
                                                                >      KillZone kill_zone;
                                                                >  public:
                                                                >      std::string last_query;
                                                                >      std::string default_db;
                                                                >
                                                                >      WrapperState() {}
                                                                >      ~WrapperState() {}
                                                                >      const std::unique_ptr<QueryRewrite> &getQueryRewrite() cons
                                                                >          assert(this->qr);
                                                                >          return this->qr;
                                                                >      }
                                                                >      void setQueryRewrite(std::unique_ptr<QueryRewrite> &&in_qr)
                                                                >          this->qr = std::move(in_qr);
                                                                >      }
                                                                >      void selfKill(KillZone::Where where) {
                                                                >          kill_zone.die(where);
                                                                >      }
                                                                >      void setKillZone(const KillZone &kz) {
                                                                >          kill_zone = kz;
                                                                >      }
                                                                >      
                                                                >      std::unique_ptr<ProxyState> ps;
                                                                >      std::vector<SchemaInfoRef> schema_info_refs;
                                                                >
                                                                >  private:
                                                                >      std::unique_ptr<QueryRewrite> qr;
                                                                >  };
                                                                >
                                                                >  //global map, for each client, we have one WrapperState which c
                                                                >  static std::map<std::string, WrapperState*> clients;
                                                                >
                                                                >  //This connection mimics the behaviour of MySQL-Proxy
                                                                >  Connect  *globalConn;
                                                                >  //Return values got by using directly the MySQL c Client
                                                                >  struct rawReturnValue{
                                                                >      std::vector<std::vector<std::string> > rowValues;
                                                                >      std::vector<std::string> fieldNames;
                                                                >      std::vector<int> fieldTypes;
                                                                >  };
static inline std::string user_homedir() {                      |  //must be static, or we get "no previous declaration"
    return getenv("HOME");                                      |  //execute the query and getthe rawReturnVale, this struct can b
                                                                >  static 
                                                                >  rawReturnValue executeAndGetResultRemote(Connect * curConn,std:
                                                                >      std::unique_ptr<DBResult> dbres;
                                                                >      curConn->execute(query, &dbres);
                                                                >      rawReturnValue myRaw;
                                                                >      
                                                                >      if(dbres==nullptr||dbres->n==NULL){
                                                                >          //std::cout<<"no results"<<std::endl;
                                                                >          return myRaw;
                                                                >      }
                                                                >
                                                                >      int num = mysql_num_rows(dbres->n);
                                                                >      if(num!=0)
                                                                >          std::cout<<"num of rows: "<<num<<std::endl;
                                                                >
                                                                >      int numOfFields = mysql_num_fields(dbres->n);
                                                                >      if(numOfFields!=0)
                                                                >          std::cout<<"num of fields: "<<numOfFields<<std::endl;
                                                                >
                                                                >      MYSQL_FIELD *field;
                                                                >      MYSQL_ROW row;
                                                                >
                                                                >      if(num!=0){
                                                                >          while( (row = mysql_fetch_row(dbres->n)) ){
                                                                >              unsigned long * fieldLen = mysql_fetch_lengths(dbre
                                                                >              std::vector<std::string> curRow;
                                                                >              for(int i=0;i<numOfFields;i++){
                                                                >                  if (i == 0) {
                                                                >                      while( (field = mysql_fetch_field(dbres->n)
                                                                >                          myRaw.fieldNames.push_back(std::string(
                                                                >                          myRaw.fieldTypes.push_back(field->type)
                                                                >                      }
                                                                >                  }
                                                                >                  if(row[i]==NULL) curRow.push_back("NULL");
                                                                >                  else curRow.push_back(std::string(row[i],fieldL
                                                                >              }
                                                                >              myRaw.rowValues.push_back(curRow);
                                                                >          }
                                                                >      }
                                                                >      return myRaw;
static inline std::string user_histfile() {                     |  //print RawReturnValue for testing purposes.
    return user_homedir() + "/.cryptdb-history";                |  static
                                                                >  void printrawReturnValue(rawReturnValue & cur) {
                                                                >      int len = cur.fieldTypes.size();
                                                                >      if(len==0){
                                                                >          //std::cout<<"zero output"<<std::endl;
                                                                >          return ;
static void __write_history() {                                 |      if(static_cast<int>(cur.fieldNames.size())!=len||static_cas
    write_history(user_histfile().c_str());                     |          std::cout<<RED_BEGIN<<"size mismatch in printrawReturnV
                                                                >          return ;
static inline std::string &ltrim(std::string &s) {              |      for(int i=0;i<len;i++){
  s.erase(s.begin(), find_if(s.begin(), s.end(), not1(std::ptr_ |          std::cout<<cur.fieldNames[i]<<":"<<cur.fieldTypes[i]<<"
  return s;                                                     <
static inline std::string &rtrim(std::string &s) {              |      std::cout<<std::endl;
  s.erase(find_if(s.rbegin(), s.rend(), not1(std::ptr_fun<int,  |      for(auto row:cur.rowValues){
  return s;                                                     |          for(auto rowItem:row){
                                                                >              std::cout<<rowItem<<"\t";
                                                                >          std::cout<<std::endl;
                                                                >      }
                                                                >  }
                                                                >
                                                                >  //The rewrite phase of cryptdb.
                                                                >
                                                                >  /*
                                                                >  1. getSchemaInfo
                                                                >  2. rewrite => gather/write
                                                                >  3. fetch the executor and put it in wrapperState(std::unique_pt
                                                                >  */
static inline std::string &trim(std::string &s) {               |  static
  return ltrim(rtrim(s));                                       |  bool myRewrite(std::string curQuery,unsigned long long _thread_
                                                                >      assert(0 == mysql_thread_init());
                                                                >      WrapperState *const c_wrapper = clients[client];
                                                                >      ProxyState *const ps = c_wrapper->ps.get();
                                                                >      assert(ps);
                                                                >      c_wrapper->last_query = curQuery;
                                                                >      //std::cout<<RED_BEGIN<<"start my rewrite"<<COLOR_END<<std:
                                                                >      try{
                                                                >          TEST_Text(retrieveDefaultDatabase(_thread_id, ps->getCo
                                                                >                                                &c_wrapper->defau
                                                                >                                    "proxy failed to retrieve def
                                                                >          const std::shared_ptr<const SchemaInfo> &schema =  ps->
                                                                >          c_wrapper->schema_info_refs.push_back(schema);
                                                                >          std::unique_ptr<QueryRewrite> qr =
                                                                >              std::unique_ptr<QueryRewrite>(new QueryRewrite(
                                                                >                      Rewriter::rewrite(curQuery, *schema.get(),
                                                                >                                        c_wrapper->default_db, *p
                                                                >          assert(qr);
                                                                >          c_wrapper->setQueryRewrite(std::move(qr));
                                                                >          }catch(...){
                                                                >              std::cout<<"rewrite exception!!!"<<std::endl;
                                                                >              return false;
                                                                >          }
                                                                >          return true;
/** returns true if should stop, to keep looping */             |  //helper function for transforming the rawReturnValue
static bool handle_line(ProxyState& ps, const std::string& q, b |  static Item_null *
                                                                >  make_null(const std::string &name = ""){
                                                                >      char *const n = current_thd->strdup(name.c_str());
                                                                >      return new Item_null(n);
                                                                >  }
                                                                >  //helper function for transforming the rawReturnValue
                                                                >  static std::vector<Item *>
                                                                >  itemNullVector(unsigned int count)
  if (q == "\\q") {                                             |      std::vector<Item *> out;
    std::cerr << "Goodbye!\n";                                  |      for (unsigned int i = 0; i < count; ++i) {
    return false;                                               |          out.push_back(make_null());
                                                                >      }
                                                                >      return out;
                                                                >  }
                                                                >
                                                                >  //transform rawReturnValue to ResType
                                                                >  static 
                                                                >  ResType MygetResTypeFromLuaTable(bool isNULL,rawReturnValue *in
                                                                >      std::vector<std::string> names;
                                                                >      std::vector<enum_field_types> types;
                                                                >      std::vector<std::vector<Item *> > rows;
                                                                >      //return NULL restype 
                                                                >      if(isNULL){
                                                                >          return ResType(true,0,0,std::move(names),
                                                                >                        std::move(types),std::move(rows));
                                                                >      } else {
                                                                >          for(auto inNames:inRow->fieldNames){
                                                                >              names.push_back(inNames);
                                                                >          }
                                                                >          for(auto inTypes:inRow->fieldTypes){
                                                                >              types.push_back(static_cast<enum_field_types>(inTyp
  add_history(q.c_str());                                       |          for(auto inRows:inRow->rowValues) {
                                                                >              std::vector<Item *> curTempRow = itemNullVector(typ
                                                                >              for(int i=0;i< (int)(inRows.size());i++){
                                                                >                  curTempRow[i] = (MySQLFieldTypeToItem(types[i],
                                                                >              }
                                                                >              rows.push_back(curTempRow);
                                                                >          }
                                                                >          //uint64_t afrow = globalConn->get_affected_rows();
                                                                >          //std::cout<<GREEN_BEGIN<<"Affected rows: "<<afrow<<COL
                                                                >          return ResType(true, 0 ,
                                                                >                                 in_last_insert_id, std::move(nam
                                                                >                                     std::move(types), std::move(
                                                                >      }
                                                                >  }
  // handle meta inputs                                         |  //printResType for testing purposes
  if (q.find(":load") == 0) {                                   |  static 
    std::string filename = q.substr(6);                         |  void parseResType(const ResType &rd) {
    trim(filename);                                             |  //    std::cout<<RED_BEGIN<<"rd.affected_rows: "<<rd.affected_r
    std::cerr << RED_BEGIN << "Loading commands from file: " << |  //    std::cout<<RED_BEGIN<<"rd.insert_id: "<<rd.insert_id<<COL
    std::ifstream f(filename.c_str());                          |      
    if (!f.is_open()) {                                         |      for(auto name:rd.names){
      std::cerr << "ERROR: cannot open file: " << filename << s |          std::cout<<name<<"\t";
    }                                                           <
    while (f.good()) {                                          <
      std::string line;                                         <
      getline(f, line);                                         <
      if (line.empty())                                         <
        continue;                                               <
      std::cerr << GREEN_BEGIN << line << COLOR_END << std::end <
      if (!handle_line(ps, line)) {                             <
        f.close();                                              <
        return false;                                           <
                                                                >      std::cout<<std::endl;    
                                                                >      for(auto row:rd.rows){
                                                                >          for(auto item:row){
                                                                >              std::cout<<ItemToString(*item)<<"\t";
    f.close();                                                  |              std::cout<<std::endl;
    return true;                                                <
                                                                >  }
                                                                >
                                                                >
                                                                >  //the "next" phase of cryptdb
                                                                >  /*
                                                                >  1. call function "next" in the executor
                                                                >  2. process three different return types.
                                                                >  */
                                                                >
                                                                >  static
                                                                >  void myNext(std::string client,bool isFirst,ResType inRes) {
                                                                >      WrapperState *const c_wrapper = clients[client];
                                                                >      ProxyState *const ps = c_wrapper->ps.get();
                                                                >      assert(ps);
                                                                >      ps->safeCreateEmbeddedTHD();
                                                                >     
                                                                >      const ResType &res = inRes;
                                                                >      const std::unique_ptr<QueryRewrite> &qr = c_wrapper->getQue
  static SchemaCache schema_cache;                              <
      const std::string &default_db =                           |          NextParams nparams(*ps, c_wrapper->default_db, c_wrappe
          getDefaultDatabaseForConnection(ps.getConn());        |          const auto &new_results = qr->executor->next(res, npara
      const EpilogueResult &epi_result =                        |          const auto &result_type = new_results.first;
          executeQuery(ps, q, default_db, &schema_cache, pp);   |          switch (result_type){
      if (QueryAction::ROLLBACK == epi_result.action) {         |              //execute the query, fetch the results, and call ne
          std::cout << GREEN_BEGIN << "ROLLBACK issued!" << COL |          case AbstractQueryExecutor::ResultType::QUERY_COME_AGAI
                    << std::endl;                               |          //    std::cout<<RED_BEGIN<<"case one"<<COLOR_END<<std:
      }                                                         |              const auto &output =
      return epi_result.res_type.success();                     |                  std::get<1>(new_results)->extract<std::pair<boo
  } catch (const SynchronizationException &e) {                 |              const auto &next_query = output.second;
      std::cout << e << std::endl;                              |              //here we execute the query against the remote data
      return true;                                              |              rawReturnValue resRemote = executeAndGetResultRemot
  } catch (const AbstractException &e) {                        |              //transform rawReturnValue first
      std::cout << e << std::endl;                              |              const auto &againGet = MygetResTypeFromLuaTable(fal
      return true;                                              |              myNext(client,false,againGet);
  }  catch (const CryptDBError &e) {                            |              break;
      std::cout << "Low level error: " << e.msg << std::endl;   <
      return true;                                              <
  } catch (const std::runtime_error &e) {                       <
      std::cout << "Unexpected Error: " << e.what() << std::end <
      return false;                                             <
                                                                >
                                                                >          //only execute the query, without processing the retult
                                                                >          case AbstractQueryExecutor::ResultType::QUERY_USE_RESUL
                                                                >          //    std::cout<<RED_BEGIN<<"case two"<<COLOR_END<<std:
                                                                >              const auto &new_query =
                                                                >                  std::get<1>(new_results)->extract<std::string>(
                                                                >              auto resRemote = executeAndGetResultRemote(globalCo
                                                                >              printrawReturnValue(resRemote);
                                                                >              break;
int                                                             |          //return the results to the client directly 
main(int ac, char **av)                                         |          case AbstractQueryExecutor::ResultType::RESULTS:{
{                                                               |          //    std::cout<<RED_BEGIN<<"case three"<<COLOR_END<<st
    if (ac != 3) {                                              |              const auto &res = new_results.second->extract<ResTy
        std::cerr << std::endl << "Usage: " << av[0]            |              parseResType(res);
                  << " <embedded-db-path> <to-be-encrypted-db-n <
                  << std::endl << std::endl;                    <
        exit(1);                                                <
    }                                                           <
                                                                <
    using_history();                                            <
    read_history(user_histfile().c_str());                      <
    atexit(__write_history);                                    <
                                                                <
    ConnectionInfo ci("localhost", "root", "letmein");          <
    const std::string master_key = "2392834";                   <
    ProxyState ps(ci, av[1], master_key);                       <
    const std::string create_db =                               <
        "CREATE DATABASE IF NOT EXISTS " + std::string(av[2]);  <
    if (!handle_line(ps, create_db, false)) {                   <
        return 1;                                               <
    }                                                           <
    const std::string use_db = "USE " + std::string(av[2]);     <
    if (!handle_line(ps, use_db, false)) {                      <
        return 1;                                               <
    }                                                           <
                                                                <
    const std::string prompt = BOLD_BEGIN + "CryptDB=#" + COLOR <
                                                                <
    for (;;) {                                                  <
        char *input = readline(prompt.c_str());                 <
        if (!input) break;                                      <
        std::string q(input);                                   <
        if (q.empty()) continue;                                <
        else{                                                   <
            if (!handle_line(ps, q))                            <
                                                                >
                                                                >          default:{
                                                                >              std::cout<<"case default"<<std::endl;
                                                                >          }
                                                                >          }
                                                                >      }catch(...){
                                                                >          std::cout<<"next error"<<std::endl;
                                                                >      }
                                                                >  }
                                                                >
                                                                >  static
                                                                >  void batchTogether(std::string client, std::string curQuery,uns
                                                                >      //the first step is to Rewrite, we abort this session if we
                                                                >      bool resMyRewrite =  myRewrite(curQuery,_thread_id,client);
                                                                >      if(!resMyRewrite){
                                                                >           //std::cout<<"my rewrite error in batch"<<std::endl;
                                                                >           return ; 
                                                                >      }
                                                                >      myNext(client,true, MygetResTypeFromLuaTable(true));
                                                                >  }
                                                                >
                                                                >
                                                                >
                                                                >  static void processLayers(const EncLayer &enc){
                                                                >      //std::cout<<enc.serialize(enc)<<std::endl;
                                                                >      std::cout<<enc.name()<<std::endl;
                                                                >  }
                                                                >
                                                                >
                                                                >
                                                                >  static void processOnionMeta(const OnionMeta &onion){
                                                                >      std::cout<<GREEN_BEGIN<<"PRINT OnionMeta"<<COLOR_END<<std::
                                                                >      std::cout<<"onionmeta->getAnonOnionName(): "<<onion.getAnon
                                                                >      auto &layers = onion.getLayers();
                                                                >      for(auto &slayer:layers){
                                                                >          processLayers(*(slayer.get()));
                                                                >      }
                                                                >  }
                                                                >
                                                                >
                                                                >
                                                                >  static void processFieldMeta(const FieldMeta &field){
                                                                >  //Process general info
                                                                >      if(field.getHasSalt()){
                                                                >          std::cout<<"this field has salt"<<std::endl;
                                                                >      }
                                                                >      std::cout<<"field.getFieldName(): "<<field.getFieldName()<<
                                                                >      std::cout<<"field.getSaltName(): "<<field.getSaltName()<<st
                                                                >      std::cout<<"field.serialize(): "<<field.serialize(field)<<s
                                                                >
                                                                >      for(std::pair<const OnionMetaKey *, OnionMeta *> &ompair:fi
                                                                >          processOnionMeta(*ompair.second);
                                                                >      }
                                                                >  //Process Onions
                                                                >      if(field.hasOnion(oDET)){
                                                                >          field.getOnionMeta(oDET);
                                                                >      }
                                                                >      if(field.hasOnion(oOPE)){
                                                                >          field.getOnionMeta(oOPE);
                                                                >      }
                                                                >      if(field.hasOnion(oAGG)){
                                                                >          field.getOnionMeta(oAGG);
                                                                >      }
                                                                >      return;
                                                                >  //iterate over onions
                                                                >      for(const std::pair<const OnionMetaKey,std::unique_ptr<Onio
                                                                >          std::cout<<onion.second->getDatabaseID()<<":"<<onion.fi
                                                                >      }
                                                                >  }
                                                                >
                                                                >
                                                                >  static void processTableMeta(const TableMeta &table){
                                                                >      std::cout<<GREEN_BEGIN<<"PRINT TableMeta"<<COLOR_END<<std::
                                                                >      for(FieldMeta *cfm:table.orderedFieldMetas()){
                                                                >          processFieldMeta(*cfm);
                                                                >      }
                                                                >  }
                                                                >
                                                                >
                                                                >  static void processDatabaseMeta(const DatabaseMeta & dbm,std::s
                                                                >      TableMeta & tbm = *dbm.getChild(IdentityMetaKey(table));
                                                                >      processTableMeta(tbm);
                                                                >      return;
                                                                >
                                                                >  }
                                                                >
                                                                >  static void processSchemaInfo(SchemaInfo &schema,std::string db
                                                                >       const std::unique_ptr<AES_KEY> &TK = std::unique_ptr<AES_K
                                                                >       Analysis analysis(db,schema,TK,
                                                                >                          SECURITY_RATING::SENSITIVE);
                                                                >       if(analysis.databaseMetaExists(db)){
                                                                >           processDatabaseMeta(analysis.getDatabaseMeta(db));
                                                                >       }else{
                                                                >           std::cout<<"data base not exists"<<std::endl;
                                                                >       }
                                                                >  }
                                                                >
                                                                >  static std::unique_ptr<SchemaInfo> myLoadSchemaInfo() {
                                                                >      std::unique_ptr<Connect> e_conn(Connect::getEmbedded(embedd
                                                                >      std::unique_ptr<SchemaInfo> schema(new SchemaInfo());
                                                                >
                                                                >      std::function<DBMeta *(DBMeta *const)> loadChildren =
                                                                >          [&loadChildren, &e_conn](DBMeta *const parent) {
                                                                >              auto kids = parent->fetchChildren(e_conn);
                                                                >              for (auto it : kids) {
                                                                >                  loadChildren(it);
                                                                >              return parent;
                                                                >          };
                                                                >      //load all metadata and then store it in schema
                                                                >      loadChildren(schema.get());
                                                                >
                                                                >      Analysis analysis(std::string("student"),*schema,std::uniqu
                                                                >                          SECURITY_RATING::SENSITIVE);
                                                                >      return schema;
                                                                >
                                                                >  int
                                                                >  main(int argc,char ** argv) {
                                                                >       gmp[SECLEVEL::INVALID]="INVALID";
                                                                >       gmp[SECLEVEL::PLAINVAL]="PLAINVAL";
                                                                >       gmp[SECLEVEL::OPE]="OPE";
                                                                >       gmp[SECLEVEL::DETJOIN]="DETJOIN";
                                                                >       gmp[SECLEVEL::OPEFOREIGN]="OPEFOREIGN";
                                                                >       gmp[SECLEVEL::DET]="DET";
                                                                >       gmp[SECLEVEL::SEARCH]="SEARCH";
                                                                >       gmp[SECLEVEL::HOM]="HOM";
                                                                >       gmp[SECLEVEL::RND]="RND";
                                                                >       gmp2[oDET]="oDET";
                                                                >       gmp2[oOPE]="oOPE";
                                                                >       gmp2[oAGG]="oAGG";
                                                                >       gmp2[oSWP]="oSWP";
                                                                >       gmp2[oPLAIN]="oPLAIN";
                                                                >       gmp2[oBESTEFFORT]="oBESTEFFORT";
                                                                >       gmp2[oINVALID]="oINVALID";
                                                                >
                                                                >       string targetDb;
                                                                >       if(argc==2){
                                                                >          targetDb = string(argv[1]);
                                                                >       }
                                                                >      std::string client="192.168.1.1:1234";
                                                                >      //one Wrapper per user.
                                                                >      clients[client] = new WrapperState();    
                                                                >      //Connect phase
                                                                >      ConnectionInfo ci("localhost", "root", "letmein",3306);
                                                                >      //const std::string master_key = "113341234";
                                                                >      const std::string master_key = "113341234HEHE";
                                                                >
                                                                >      char *buffer;
                                                                >      if((buffer = getcwd(NULL, 0)) == NULL){  
                                                                >          perror("getcwd error");  
                                                                >      }
                                                                >      embeddedDir = std::string(buffer)+"/shadow";
                                                                >      SharedProxyState *shared_ps = 
                                                                >                          new SharedProxyState(ci, embeddedDir , 
                                                                >      assert(0 == mysql_thread_init());
                                                                >      //we init embedded database here.
                                                                >      clients[client]->ps = std::unique_ptr<ProxyState>(new Proxy
                                                                >      clients[client]->ps->safeCreateEmbeddedTHD();
                                                                >      //Connect end!!
                                                                >      globalConn = new Connect(ci.server, ci.user, ci.passwd, ci.
                                                                >      std::string curQuery = "SHOW DATABASES;";
                                                                >      //int count=0;
                                                                >      //std::cout<<"please input a new query:####################
                                                                >      if(targetDb.size()==0)
                                                                >          std::getline(std::cin,curQuery);
                                                                >
                                                                >      else curQuery = string("use ")+targetDb;
                                                                >      unsigned long long _thread_id = globalConn->get_thread_id()
                                                                >      long long countWrapper = 0;
                                                                >      while(curQuery!="quit"){
                                                                >          if(curQuery.size()==0){
                                                                >              return 0;
                                                                >              std::cout<<std::endl;
                                                                >              std::getline(std::cin,curQuery);
                                                                >              std::unique_ptr<SchemaInfo> schema =  myLoadSchemaI
                                                                >              processSchemaInfo(*schema);
                                                                >              continue;
                                                                >          }
                                                                >          countWrapper++;
                                                                >          batchTogether(client,curQuery,_thread_id);
                                                                >          //std::cout<<GREEN_BEGIN<<"\nplease input a new query:#
                                                                >          std::getline(std::cin,curQuery);
                                                                >          if(countWrapper==3){
                                                                >              cout<<"bingo"<<endl;
                                                                >              countWrapper=0;
                                                                >          }
                                                                >      }
                                                                >      return 0;
                                                                >  }
                                                                >
                                                                >
Only in Practical-Cryptdb/main: change_test.cc
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/Connect.cc Practical-Cryptdb/main/Connect.cc
                                                                >  #include <util/cryptdb_log.hh>
#include <util/cryptdb_log.hh>                                  |  #include <main/Analysis.hh>
#include <main/schema.hh>                                       |  #include <parser/mysql_type_metadata.hh>
                                                                >
                                                                >  __thread ProxyState *thread_ps = NULL;
                                                                >  bool
                                                                >  strictMode(Connect *const c)
                                                                >  {
                                                                >      return c->execute("SET SESSION sql_mode = 'ANSI,TRADITIONAL
                                                                >  }
                                                                >
                                                                >      {
                                                                >          my_bool reconnect = 1;
                                                                >          /* automatically reconnect */
                                                                >          mysql_options(conn, MYSQL_OPT_RECONNECT, &reconnect);
                                                                >      }
                                                                >
        cryptdb_err() << "mysql_real_connect: " << mysql_error( |          thrower() << "mysql_real_connect: " << mysql_error(m);
    Connect *const conn = new Connect(m);                       |      return new Connect(m);
    conn->close_on_destroy = true;                              <
                                                                <
    return conn;                                                <
// > This is a hack that allows us to deal with the two sets wh |  // > This is a hack that allows us to deal with potentially mul
// are returned when CALLing a stored procedure.                |  //   sets returned when CALLing a stored procedure.
        LOG(warn) << "mysql_query: " << mysql_error(conn);      |  //        LOG(warn) << "mysql_query: " << mysql_error(conn);
        LOG(warn) << "on query: " << query;                     |          LOG(warn) << "error on query: " << query;
            *res =                                              |              *res = std::unique_ptr<DBResult>(DBResult::store(co
                std::unique_ptr<DBResult>(DBResult::wrap(mysql_ <
            int status;                                         |              // iterate through each result set; if a query lead
            do {                                                |              // one of the resultsets failed, it will be the las
                                                                >              // so get the error value
                                                                >              const bool errno_success = 0 == mysql_errno(conn);
                                                                >              while (true) {
                                                                >
                                                                >                  const int status = mysql_next_result(conn);
                                                                >                  if (0 == status) {                  // another 
                } else {                                        <
                    assert(mysql_field_count(conn) == 0);       <
                status = mysql_next_result(conn);               |                  } else if (-1 == status) {          // last res
                assert(status <= 0);                            |                      *res = std::unique_ptr<DBResult>(
            } while (0 == status);                              |                          new DBResult(res_native, errno_success,
                                                                >                                       mysql_affected_rows(conn),
                                                                >                                       mysql_insert_id(conn)));
                                                                >                      break;
                                                                >                  } else {                            // error
                                                                >                      thrower() << "error occurred processing mul
                                                                >                                   " query results";
                                                                >                  }
                                                                >              }
    void *const ret = create_embedded_thd(0);                   |      if (thread_ps) {
    if (!ret) assert(false);                                    |          thread_ps->safeCreateEmbeddedTHD();
                                                                >      } else {
                                                                >          assert(create_embedded_thd(0));
                                                                >      }
                                                                >  // because the caller is ignoring the ResType we must account f
                                                                >  // errors encoded in the ResType
    return r;                                                   |      return r && aux->getSuccess();
                                                                >  unsigned long long 
                                                                >  Connect::get_thread_id(){
                                                                >      if(conn!=NULL)
                                                                >          return mysql_thread_id(conn);
                                                                >      else{
                                                                >          std::cout<<"no connection, no id"<<std::endl;
                                                                >          return -1;
                                                                >      }
                                                                >  }
                                                                >
                                                                >
                                                                >
                                                                >  uint64_t 
                                                                >  Connect::get_affected_rows(){
                                                                >      return mysql_affected_rows(conn);
                                                                >  }
                                                                >
                                                                >
DBResult::DBResult()                                            <
{}                                                              <
                                                                <
DBResult::wrap(DBResult_native *const n)                        |  DBResult::store(MYSQL *const mysql)
    DBResult *const r = new DBResult();                         |      const bool success = 0 == mysql_errno(mysql);
    r->n = n;                                                   |      DBResult_native *const n = mysql_store_result(mysql);
    return r;                                                   |      return new DBResult(n, success, mysql_affected_rows(mysql),
                                                                >                          mysql_insert_id(mysql));
    if (IsMySQLTypeNumeric(type)) {                             |      if (isMySQLTypeNumeric(type)) {
                                                                >      // 'n' will be NULL when the mysql statement doesn't return
                                                                >      // > ie INSERT
        return ResType();                                       |          return ResType(this->success, this->affected_rows, this
    const size_t rows = static_cast<size_t>(mysql_num_rows(n)); |      const size_t row_count = static_cast<size_t>(mysql_num_rows
    if (0 == rows) {                                            |      const int col_count    = mysql_num_fields(n);
        return ResType();                                       <
    }                                                           <
                                                                <
    const int cols = mysql_num_fields(n);                       <
                                                                <
    ResType res;                                                <
                                                                >      std::vector<std::string> names;
                                                                >      std::vector<enum_field_types> types;
                                                                >              assert(col_count == j);
        res.names.push_back(field->name);                       |          names.push_back(field->name);
        res.types.push_back(field->type);                       |          types.push_back(field->type);
    for (int index = 0;; index++) {                             |      std::vector<std::vector<Item *> > rows;
        MYSQL_ROW row = mysql_fetch_row(n);                     |      for (size_t index = 0;; index++) {
                                                                >          const MYSQL_ROW row = mysql_fetch_row(n);
                                                                >              assert(row_count == index);
        std::vector<std::shared_ptr<Item> > resrow;             |          std::vector<Item *> resrow;
        for (int j = 0; j < cols; j++) {                        |          for (int j = 0; j < col_count; j++) {
            Item *const item = getItem(row[j], res.types[j], le |              Item *const item = getItem(row[j], types[j], length
            resrow.push_back(std::shared_ptr<Item>(item));      |              resrow.push_back(item);
        res.rows.push_back(resrow);                             |          rows.push_back(resrow);
    return res;                                                 |      return ResType(this->success, this->affected_rows, this->in
                                                                >                     std::move(names), std::move(types), std::mov
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/Connect.hh Practical-Cryptdb/main/Connect.hh
 private:                                                       <
    DBResult();                                                 <
                                                                <
                                                                >      DBResult(DBResult_native *const n, bool success,
                                                                >               uint64_t affected_rows, uint64_t insert_id)
                                                                >          : n(n), success(success), affected_rows(affected_rows),
                                                                >            insert_id(insert_id) {}
                                                                >
    DBResult_native *n;                                         |      DBResult_native *const n;
    static DBResult *wrap(DBResult_native *);                   |      static DBResult *store(MYSQL *const mysql);
                                                                >
                                                                >      bool getSuccess() const {return success;}
                                                                >
                                                                >   private:
                                                                >      const bool success;
                                                                >      const uint64_t affected_rows;
                                                                >      const uint64_t insert_id;
    Connect(MYSQL *const _conn) : conn(_conn), close_on_destroy |      Connect(MYSQL *const _conn) : conn(_conn), close_on_destroy
                                                                >
                                                                >      unsigned long long get_thread_id();
                                                                >      uint64_t get_affected_rows();
                                                                >
                                                                >
                                                                >  bool strictMode(Connect *const c);
                                                                >
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/CryptoHandlers.cc Practical-Cryptdb/main/CryptoHandlers.cc
                                                                >  #include <parser/mysql_type_metadata.hh>
                                                                >  #define BITS_PER_BYTE 8
                                                                >
                                                                >  /*
                                                                >   * ##### STRICT MODE #####
                                                                >   * if we want to more closely match the semantics of mysql when
                                                                >   * out of range value; we must know at runtime if we are in str
                                                                >   * or non strict mode.  Then we can reject or cutoff the value 
                                                                >   * on the current mode.
                                                                >   */
                                                                >
    static EncLayer * create(Create_field * const cf,           |      static std::unique_ptr<EncLayer>
                             const std::string &key) {          |      create(const Create_field &cf, const std::string &key) {
    static EncLayer * deserialize(const SerialLayer &serial) {  |      static std::unique_ptr<EncLayer>
                                                                >      deserialize(const SerialLayer &serial) {
    static EncLayer * create(Create_field * const cf,           |      static std::unique_ptr<EncLayer>
                             const std::string &key);           |          create(const Create_field &cf, const std::string &key);
    static EncLayer * deserialize(unsigned int id,              |      static std::unique_ptr<EncLayer>
                                  const SerialLayer &serial);   |          deserialize(unsigned int id, const SerialLayer &serial)
    static EncLayer * create(Create_field * const cf,           |      static std::unique_ptr<EncLayer>
                             const std::string &key);           |          create(const Create_field &cf, const std::string &key);
    static EncLayer * deserialize(unsigned int id,              |      static std::unique_ptr<EncLayer>
                                  const SerialLayer &serial);   |          deserialize(unsigned int id, const SerialLayer &serial)
    static EncLayer * create(Create_field * const cf,           |      static std::unique_ptr<EncLayer>
                             const std::string &key);           |          create(const Create_field &cf, const std::string &key);
    static EncLayer * deserialize(unsigned int id,              |      static std::unique_ptr<EncLayer>
                                  const SerialLayer &serial);   |          deserialize(unsigned int id, const SerialLayer &serial)
    static EncLayer * create(Create_field * const cf,           |      static std::unique_ptr<EncLayer>
                             const std::string &key);           |          create(const Create_field &cf, const std::string &key);
    static EncLayer * deserialize(unsigned int id,              |      static std::unique_ptr<EncLayer>
                                  const SerialLayer &serial);   |          deserialize(unsigned int id, const SerialLayer &serial)
                                                                >  };
                                                                >
                                                                >  class OPEFOREIGNFactory : public LayerFactory {
                                                                >  public:
                                                                >      static std::unique_ptr<EncLayer>
                                                                >          create(const Create_field &cf, const std::string &key);
                                                                >      static std::unique_ptr<EncLayer>
                                                                >          deserialize(unsigned int id, const SerialLayer &serial)
    static EncLayer * create(Create_field * const cf,           |      static std::unique_ptr<EncLayer>
                             const std::string &key);           |          create(const Create_field &cf, const std::string &key);
    static EncLayer * deserialize(unsigned int id,              |      static std::unique_ptr<EncLayer>
                                  const SerialLayer &serial);   |          deserialize(unsigned int id, const SerialLayer &serial)
static uint                                                     <
getDecimals(const std::string &serial)                          <
{                                                               <
    return atoi(serial.substr(0, serial.find(' ')).c_str());    <
}                                                               <
                                                                <
static std::string                                              <
underSerial(const std::string &serial)                          <
{                                                               <
    const uint pos = serial.find(" ");                          <
    return serial.substr(pos + 1, std::string::npos);           <
}                                                               <
                                                                <
EncLayer *                                                      |  std::unique_ptr<EncLayer>
EncLayerFactory::encLayer(onion o, SECLEVEL sl, Create_field *  |  EncLayerFactory::encLayer(onion o, SECLEVEL sl, const Create_fi
                                                                >          case SECLEVEL::OPEFOREIGN:{return OPEFOREIGNFactory::cr
        case SECLEVEL::SEARCH: {return new Search(cf, key);}    |          case SECLEVEL::SEARCH: {
        case SECLEVEL::PLAINVAL: {return new PlainText();}      |              return std::unique_ptr<EncLayer>(new Search(cf, key
                                                                >          }
                                                                >          case SECLEVEL::PLAINVAL: {
                                                                >              return std::unique_ptr<EncLayer>(new PlainText());
                                                                >          }
EncLayer *                                                      |  //recover from the database using lambda.
                                                                >  std::unique_ptr<EncLayer>
                                  const std::string &serial)    |                                    const std::string &serial){
{                                                               <
                                                                >          case SECLEVEL::OPEFOREIGN:
                                                                >              return OPEFOREIGNFactory::deserialize(id,li);
                                                                >
            return new HOM(id, serial);                         |              return std::unique_ptr<EncLayer>(new HOM(id, serial
            return new Search(id, serial);                      |              return std::unique_ptr<EncLayer>(new Search(id, ser
            return new PlainText(id);                           |              return std::unique_ptr<EncLayer>(new PlainText(id))
/*                                                              <
static bool                                                     <
stringItem(Item * const i)                                      <
{                                                               <
    return i->type() == Item::Type::STRING_ITEM;                <
}                                                               <
*/                                                              <
                                                                <
// returns the length of output by AES encryption of a string o <
// and len                                                      <
static                                                          <
std::pair<enum enum_field_types, unsigned long>                 <
type_len_for_AES_str(enum enum_field_types type, unsigned long  <
                     bool pad)                                  <
{                                                               <
    unsigned long res_len = len;                                <
    enum enum_field_types res_type = type;                      <
                                                                <
    switch (type) {                                             <
        case MYSQL_TYPE_TINY_BLOB:                              <
        case MYSQL_TYPE_MEDIUM_BLOB:                            <
        case MYSQL_TYPE_LONG_BLOB:                              <
        case MYSQL_TYPE_BLOB:                                   <
            break;                                              <
        case MYSQL_TYPE_VARCHAR:                                <
        case MYSQL_TYPE_STRING:                                 <
        case MYSQL_TYPE_TIMESTAMP:                              <
        case MYSQL_TYPE_DATE:                                   <
        case MYSQL_TYPE_NEWDATE:                                <
        case MYSQL_TYPE_TIME:                                   <
        case MYSQL_TYPE_DATETIME:                               <
            res_type = MYSQL_TYPE_VARCHAR;                      <
            TEST_TextMessageError(rounded_len(len, AES_BLOCK_BY <
                                              &res_len),        <
                                  "The field you are trying to  <
                                  " too large!");               <
            break;                                              <
        default: {                                              <
            const std::string t =                               <
                TypeText<enum enum_field_types>::toText(type);  <
            assert_s(false, "unexpected sql_type" + t);         <
         }                                                      <
    }                                                           <
                                                                <
    return std::make_pair(res_type, res_len);                   <
                                                                <
}                                                               <
                                                                <
createFieldHelper(const Create_field * const f,                 |  lowLevelcreateFieldHelper(const Create_field &f,
                                                                >      //从内存分配新的Create_field
    Create_field * const f0 = f->clone(thd->mem_root);          |      Create_field * const f0 = f.clone(thd->mem_root);
    } else {                                                    <
        //encryption is always unsigned                         <
        f0->flags = f0->flags | UNSIGNED_FLAG;                  <
                                                                >  }
                                                                >
                                                                >  static Create_field*
                                                                >  integerCreateFieldHelper(const Create_field &f,
                                                                >                           enum enum_field_types type,
                                                                >                           const std::string &anonname = "",
                                                                >                           CHARSET_INFO * const charset = NULL){
                                                                >      return lowLevelcreateFieldHelper(f, 0, type, anonname, char
                                                                >  }
                                                                >  static Create_field*
                                                                >  arrayCreateFieldHelper(const Create_field &f,
                                                                >                         unsigned long field_length,
                                                                >                         enum enum_field_types type,
                                                                >                         const std::string &anonname = "",
                                                                >                         CHARSET_INFO * const charset = NULL){
                                                                >      return lowLevelcreateFieldHelper(f, field_length, type, ano
                                                                >  // Can only check unsigned values
                                                                >  static bool
                                                                >  rangeCheck(uint64_t value, std::pair<int64_t, uint64_t> inclusi
                                                                >  {
                                                                >      const int64_t minimum  = inclusiveRange.first;
                                                                >      const uint64_t maximum = inclusiveRange.second;
                                                                >
                                                                >      // test lower bound
                                                                >      const bool b = minimum < 0 || static_cast<uint64_t>(minimum
                                                                >
                                                                >      // test upper bound
                                                                >      return b && value <= maximum;
                                                                >  }
                                                                >
                                                                >  class CryptedInteger {
                                                                >  public:
                                                                >      CryptedInteger(const Create_field &cf, const std::string &k
                                                                >          : key(key), field_type(cf.sql_type),
                                                                >            inclusiveRange(supportsRange(cf)) {}
                                                                >      static CryptedInteger
                                                                >          deserialize(const std::string &serial);
                                                                >      CryptedInteger(const std::string &key, enum enum_field_type
                                                                >                     std::pair<int64_t, uint64_t> range)
                                                                >          : key(key), field_type(type), inclusiveRange(range) {}
                                                                >      std::string serialize() const;
                                                                >
                                                                >      void checkValue(uint64_t value) const;
                                                                >      std::string getKey() const {return key;}
                                                                >      enum enum_field_types getFieldType() const {return field_ty
                                                                >      std::pair<int64_t, uint64_t> getInclusiveRange() const
                                                                >          { return inclusiveRange; }
                                                                >
                                                                >  private:
                                                                >      const std::string key;
                                                                >      const enum enum_field_types field_type;
                                                                >      const std::pair<int64_t, uint64_t> inclusiveRange;
                                                                >  };
                                                                >
                                                                >
                                                                >
                                                                >  static CryptedInteger
                                                                >  overrideCreateFieldCryptedIntegerFactory(const Create_field &cf
                                                                >                                           const std::string &key
                                                                >                                           signage s,
                                                                >                                           enum enum_field_types 
                                                                >      // the override (@s and @field_type) should support the def
                                                                >      // in @cf
                                                                >
                                                                >      // create a Create_field object so we can build metadata
                                                                >      Create_field *const override_cf = cf.clone(current_thd->mem
                                                                >      override_cf->sql_type = field_type;
                                                                >      override_cf->flags    =
                                                                >          override_cf->flags
                                                                >          & (signage::UNSIGNED == s ? UNSIGNED_FLAG : ~UNSIGNED_F
                                                                >
                                                                >      // get the range for the field constructed by the user
                                                                >      const std::pair<int64_t, uint64_t> userInclusiveRange =
                                                                >          supportsRange(cf);
                                                                >
                                                                >      // get the range for the overriding type
                                                                >      const std::pair<int64_t, uint64_t> overrideInclusiveRange =
                                                                >          supportsRange(*override_cf);
                                                                >
                                                                >      // do we have a fit?
                                                                >      TEST_Text(userInclusiveRange.first >= overrideInclusiveRang
                                                                >             && userInclusiveRange.second <= overrideInclusiveRan
                                                                >                "The field you are trying to create with type "
                                                                >                + TypeText<enum enum_field_types>::toText(cf.sql_
                                                                >                + " could not be overridden properly");
                                                                >
                                                                >      return CryptedInteger(key, override_cf->sql_type,
                                                                >                            overrideInclusiveRange);
                                                                >  }
                                                                >
                                                                >  CryptedInteger
                                                                >  CryptedInteger::deserialize(const std::string &serial) {
                                                                >      const std::vector<std::string> &vec = unserialize_string(se
                                                                >      const std::string &key = vec[0];
                                                                >      const enum enum_field_types field_type =
                                                                >          TypeText<enum enum_field_types>::toType(vec[1]);
                                                                >      const int64_t inclusiveMinimum = strtoll(vec[2].c_str(), NU
                                                                >      const int64_t inclusiveMaximum = strtoull(vec[3].c_str(), N
                                                                >
                                                                >      return CryptedInteger(key, field_type,
                                                                >                            std::make_pair(inclusiveMinimum,
                                                                >                                           inclusiveMaximum));
                                                                >  }
                                                                >
                                                                >  void
                                                                >  CryptedInteger::checkValue(uint64_t value) const
                                                                >  {
                                                                >      TEST_Text(rangeCheck(value, inclusiveRange),
                                                                >                "can't handle out of range value!");
                                                                >  }
                                                                >
                                                                >  static std::string
                                                                >  serializeStrings(std::initializer_list<std::string> inputs)
                                                                >  {
                                                                >      std::string out;
                                                                >      for (auto it : inputs) {
                                                                >          out += serialize_string(it);
                                                                >      }
                                                                >
                                                                >      return out;
                                                                >  }
                                                                >
                                                                >  std::string
                                                                >  CryptedInteger::serialize() const
                                                                >  {
                                                                >      return serializeStrings({key,
                                                                >              TypeText<enum enum_field_types>::toText(field_type)
                                                                >              std::to_string(inclusiveRange.first),
                                                                >              std::to_string(inclusiveRange.second)});
                                                                >  }
    RND_int(Create_field * const cf, const std::string &seed_ke |      RND_int(const Create_field &cf, const std::string &seed_key
                                                                >      RND_int(unsigned int id, const CryptedInteger &cinteger);
    // serialize and deserialize                                |      std::string doSerialize() const;
    std::string doSerialize() const {return key;}               |      static std::unique_ptr<RND_int>
    RND_int(unsigned int id, const std::string &serial);        |          deserialize(unsigned int id, const std::string &serial)
    Create_field * newCreateField(const Create_field * const cf |      Create_field * newCreateField(const Create_field &cf,
    Item * decrypt(Item * const ctext, uint64_t IV) const;      |      Item *decrypt(const Item &ctext, uint64_t IV) const;
    std::string const key;                                      |      const CryptedInteger cinteger;
    static int const ciph_size = 8;                             <
                                                                <
    RND_str(Create_field * const cf, const std::string &seed_ke |      RND_str(const Create_field &cf, const std::string &seed_key
    Create_field * newCreateField(const Create_field * const cf |      Create_field * newCreateField(const Create_field &cf,
    Item * decrypt(Item * const ctext, uint64_t IV) const;      |      Item * decrypt(const Item &ctext, uint64_t IV) const;
    std::string const rawkey;                                   |      const std::string rawkey;
    static int const key_bytes = 16;                            |      static const int key_bytes = 16;
    AES_KEY const * const enckey;                               |      static const bool do_pad   = true;
    AES_KEY const * const deckey;                               |      const std::unique_ptr<const AES_KEY> enckey;
                                                                >      const std::unique_ptr<const AES_KEY> deckey;
EncLayer *                                                      |  static unsigned long long
RNDFactory::create(Create_field * const cf, const std::string & |  strtoul_(const std::string &s)
                                                                >  {
                                                                >      return strtoul(s.c_str(), NULL, 0);
                                                                >  }
                                                                >
                                                                >  std::unique_ptr<EncLayer>
                                                                >  RNDFactory::create(const Create_field &cf, const std::string &k
    if (IsMySQLTypeNumeric(cf->sql_type)) { // the ope case as  |      if (isMySQLTypeNumeric(cf)) {
        return new RND_int(cf, key);                            |          return std::unique_ptr<EncLayer>(new RND_int(cf, key));
        return new RND_str(cf, key);                            |          return std::unique_ptr<EncLayer>(new RND_str(cf, key));
EncLayer *                                                      |  std::unique_ptr<EncLayer>
        return new RND_int(id, sl.layer_info);                  |          return RND_int::deserialize(id, sl.layer_info);
        return new RND_str(id, sl.layer_info);                  |          return std::unique_ptr<EncLayer>(new RND_str(id, sl.lay
RND_int::RND_int(Create_field * const f, const std::string &see |  RND_int::RND_int(const Create_field &f, const std::string &seed
    : key(prng_expand(seed_key, key_bytes)),                    |      : EncLayer(),
      bf(key)                                                   |        cinteger(overrideCreateFieldCryptedIntegerFactory(f,
                                                                >                                           prng_expand(seed_key, 
                                                                >                                           signage::UNSIGNED,
                                                                >                                           MYSQL_TYPE_LONGLONG)),
                                                                >        bf(cinteger.getKey())
RND_int::RND_int(unsigned int id, const std::string &serial)    |  RND_int::RND_int(unsigned int id, const CryptedInteger &cintege
    : EncLayer(id), key(serial), bf(key)                        |      : EncLayer(id), cinteger(cinteger), bf(cinteger.getKey())
                                                                >  std::string
                                                                >  RND_int::doSerialize() const
                                                                >  {
                                                                >      return cinteger.serialize();
                                                                >  }
                                                                >
                                                                >  std::unique_ptr<RND_int>
                                                                >  RND_int::deserialize(unsigned int id, const std::string &serial
                                                                >  {
                                                                >      const CryptedInteger cint = CryptedInteger::deserialize(ser
                                                                >      return std::unique_ptr<RND_int>(new RND_int(id, cint));
                                                                >  }
                                                                >
RND_int::newCreateField(const Create_field * const cf,          |  RND_int::newCreateField(const Create_field &cf,
    // MYSQL_TYPE_LONGLONG because blowfish works on 64 bit blo |      return integerCreateFieldHelper(cf, cinteger.getFieldType()
    return createFieldHelper(cf, ciph_size, MYSQL_TYPE_LONGLONG <
                             anonname);                         <
    // assert(!stringItem(ptext));                              <
                                                                >      cinteger.checkValue(p);
                                                                >
RND_int::decrypt(Item * const ctext, uint64_t IV) const         |  RND_int::decrypt(const Item &ctext, uint64_t IV) const
    const uint64_t c = static_cast<Item_int*>(ctext)->value;    |      const uint64_t c = static_cast<const Item_int &>(ctext).val
    l.push_back(get_key_item(key));                             |      l.push_back(get_key_item(cinteger.getKey()));
RND_str::RND_str(Create_field * const f, const std::string &see |  RND_str::RND_str(const Create_field &f, const std::string &seed
    : rawkey(prng_expand(seed_key, key_bytes)),                 |      : EncLayer(), rawkey(prng_expand(seed_key, key_bytes)),
RND_str::newCreateField(const Create_field * const cf,          |  RND_str::newCreateField(const Create_field &cf,
    auto typelen = type_len_for_AES_str(cf->sql_type, cf->lengt |      const auto typelen = AESTypeAndLength(cf, do_pad);
                                                                |      return arrayCreateFieldHelper(cf, typelen.second, typelen.f
    return createFieldHelper(cf, typelen.second, typelen.first, <
    const std::string enc =                                     |      const std::string &enc =
        encrypt_AES_CBC(ItemToString(ptext), enckey,            |          encrypt_AES_CBC(ItemToString(ptext), enckey.get(),
                        BytesFromInt(IV, SALT_LEN_BYTES), false |                          BytesFromInt(IV, SALT_LEN_BYTES), do_pa
RND_str::decrypt(Item * const ctext, uint64_t IV) const         |  RND_str::decrypt(const Item &ctext, uint64_t IV) const
    const std::string dec =                                     |      const std::string &dec =
        decrypt_AES_CBC(ItemToString(*ctext), deckey,           |          decrypt_AES_CBC(ItemToString(ctext), deckey.get(),
                        BytesFromInt(IV, SALT_LEN_BYTES), false |                          BytesFromInt(IV, SALT_LEN_BYTES), do_pa
    LOG(encl) << "RND_str decrypt " << ItemToString(*ctext) <<  |      LOG(encl) << "RND_str decrypt " << ItemToString(ctext) << "
class DET_abstract_number : public EncLayer {                   |  class DET_abstract_integer : public EncLayer {
    DET_abstract_number(const std::string &key, int64_t shift); |      DET_abstract_integer() : EncLayer() {}
    DET_abstract_number(unsigned int id, const std::string &ser |      DET_abstract_integer(unsigned int id)
                                                                >          : EncLayer(id) {}
    Create_field *newCreateField(const Create_field *const cf,  |      template <typename Type>
                                                                >          static std::unique_ptr<Type>
                                                                >          deserialize(unsigned int id, const std::string &serial)
                                                                >
                                                                >      Create_field *newCreateField(const Create_field &cf,
    Item *decrypt(Item *const ctext, uint64_t IV) const;        |      Item *decrypt(const Item &ctext, uint64_t IV) const;
    const std::string key;                                      <
    const blowfish bf;                                          <
    const int64_t shift;                                        <
    static int64_t getShift(const std::string &serial);         |      virtual const CryptedInteger &getCInteger_() const = 0;
};                                                              |      virtual const blowfish &getBlowfish_() const = 0;
                                                                <
class DET_abstract_integer : public DET_abstract_number {       <
public:                                                         <
    DET_abstract_integer(Create_field *const cf,                <
                         const std::string &seed_key);          <
    DET_abstract_integer(unsigned int id, const std::string &se <
                                                                <
private:                                                        <
    static int64_t getShift(const Create_field *const f);       <
};                                                              <
                                                                <
class DET_abstract_decimal : public DET_abstract_number {       <
public:                                                         <
    DET_abstract_decimal(Create_field *const cf,                <
                         const std::string &seed_key);          <
    DET_abstract_decimal(unsigned int id, const std::string &se <
                                                                <
    // FIXME: final.                                            <
    std::string doSerialize() const;                            <
    Item *encrypt(const Item &ptext, uint64_t IV) const;        <
    Item *decrypt(Item *const ctext, uint64_t IV) const;        <
                                                                <
protected:                                                      <
    const uint decimals;      // number of decimals             <
                                                                <
    DET_int(Create_field *const cf, const std::string &seed_key |      DET_int(const Create_field &cf, const std::string &seed_key
                                                                >          : DET_abstract_integer(),
                                                                >            cinteger(overrideCreateFieldCryptedIntegerFactory(cf,
                                                                >                                         prng_expand(seed_key, bf
                                                                >                                         signage::UNSIGNED,
                                                                >                                         MYSQL_TYPE_LONGLONG)),
                                                                >            bf(cinteger.getKey()) {}
                                                                >
    DET_int(unsigned int id, const std::string &serial);        |      DET_int(unsigned int id, const CryptedInteger &cinteger)
                                                                >          : DET_abstract_integer(id), cinteger(cinteger), bf(cint
                                                                >
                                                                >  private:
                                                                >      const CryptedInteger cinteger;
                                                                >      const blowfish bf;
                                                                >
                                                                >      const CryptedInteger &getCInteger_() const {return cinteger
                                                                >      const blowfish &getBlowfish_() const {return bf;}
class DET_dec : public DET_abstract_decimal {                   <
public:                                                         <
    DET_dec(Create_field *const cf, const std::string &seed_key <
                                                                <
    // create object from serialized contents                   <
    DET_dec(unsigned int id, const std::string &serial);        <
                                                                <
    // FIXME: final                                             <
    SECLEVEL level() const {return SECLEVEL::DET;}              <
    std::string name() const {return "DET_dec";}                <
};                                                              <
                                                                <
    DET_str(Create_field * const cf, const std::string &seed_ke |      DET_str(const Create_field &cf, const std::string &seed_key
                                                                <
    Create_field * newCreateField(const Create_field * const cf |      Create_field * newCreateField(const Create_field &cf,
                                                                <
    Item * decrypt(Item * const ctext, uint64_t IV) const;      |      Item *decrypt(const Item &ctext, uint64_t IV) const;
                                                                <
    std::string const rawkey;                                   |      const std::string rawkey;
    AES_KEY const * const enckey;                               |      static const bool do_pad   = true;
    AES_KEY const * const deckey;                               |      const std::unique_ptr<const AES_KEY> enckey;
                                                                |      const std::unique_ptr<const AES_KEY> deckey;
EncLayer *                                                      |  std::unique_ptr<EncLayer>
DETFactory::create(Create_field * const cf, const std::string & |  DETFactory::create(const Create_field &cf, const std::string &k
    if (IsMySQLTypeNumeric(cf->sql_type)) {                     |      if (isMySQLTypeNumeric(cf)) {
        if (cf->sql_type == MYSQL_TYPE_DECIMAL                  |          if (cf.sql_type == MYSQL_TYPE_DECIMAL
            || cf->sql_type == MYSQL_TYPE_NEWDECIMAL) {         |              || cf.sql_type == MYSQL_TYPE_NEWDECIMAL) {
            return new DET_dec(cf, key);                        |              FAIL_TextMessageError("decimal support is broken");
            return new DET_int(cf, key);                        |              return std::unique_ptr<EncLayer>(new DET_int(cf, ke
        return new DET_str(cf, key);                            |          return std::unique_ptr<EncLayer>(new DET_str(cf, key));
EncLayer *                                                      |  std::unique_ptr<EncLayer>
        return new DET_int(id, sl.layer_info);                  |          return DET_abstract_integer::deserialize<DET_int>(id,
                                                                >                                                         sl.layer
        return new DET_dec(id, sl.layer_info);                  |          FAIL_TextMessageError("decimal support broken");
        return new DET_str(id, sl.layer_info);                  |          return std::unique_ptr<EncLayer>(new DET_str(id, sl.lay
DET_abstract_number::DET_abstract_number(const std::string &key |  std::string
                                         int64_t shift)         |  DET_abstract_integer::doSerialize() const
    : EncLayer(), key(key), bf(key), shift(shift)               |  {
{}                                                              |      return getCInteger_().serialize();
                                                                >  }
DET_abstract_number::DET_abstract_number(unsigned int id,       |  template <typename Type>
                                                                >  std::unique_ptr<Type>
                                                                >  DET_abstract_integer::deserialize(unsigned int id,
    : EncLayer(id), key(getKeyFromSerial(serial)), bf(key),     <
      shift(getShift(serial))                                   <
{}                                                              <
                                                                <
std::string DET_abstract_number::doSerialize() const            <
    return std::to_string(shift) + " " + key;                   |      /* if the concrete DET integer classes need to serialize da
                                                                >       * is not in CryptedInteger; write a deserialize function f
                                                                >       * as well and let them handle the serialized data that is 
                                                                >       * CryptedInteger */
                                                                >      const CryptedInteger &cint = CryptedInteger::deserialize(se
                                                                >      return std::unique_ptr<Type>(new Type(id, cint));
DET_abstract_number::newCreateField(const Create_field * const  |  DET_abstract_integer::newCreateField(const Create_field &cf,
    const int64_t ciph_size = 8;                                |      return integerCreateFieldHelper(cf, getCInteger_().getField
    // MYSQL_TYPE_LONGLONG because blowfish works on 64 bit blo <
    return createFieldHelper(cf, ciph_size, MYSQL_TYPE_LONGLONG <
DET_abstract_number::encrypt(const Item &ptext, uint64_t IV) co |  DET_abstract_integer::encrypt(const Item &ptext, uint64_t IV) c
    // assert(!stringItem(ptext));                              <
                                                                >      getCInteger_().checkValue(value);
    const ulonglong res = static_cast<ulonglong>(bf.encrypt(val |      const ulonglong res = static_cast<ulonglong>(getBlowfish_()
DET_abstract_number::decrypt(Item *const ctext, uint64_t IV) co |  DET_abstract_integer::decrypt(const Item &ctext, uint64_t IV) c
    const ulonglong value = static_cast<Item_int *>(ctext)->val |      const ulonglong value = static_cast<const Item_int &>(ctext
                                                                |      const ulonglong retdec = getBlowfish_().decrypt(value);
    if (shift) {                                                <
        //std::cout << "value: " << value <<  " shift: " << shi <
                                                                <
        longlong retdec = static_cast<longlong>(bf.decrypt(valu <
        retdec -= shift;                                        <
        LOG(encl) << "DET_int dec " << value << "--->" << retde <
        return new (current_thd->mem_root) Item_int(retdec);    <
    }                                                           <
                                                                <
    const ulonglong retdec = bf.decrypt(value) - shift;         <
DET_abstract_number::decryptUDF(Item *const col, Item *const iv |  DET_abstract_integer::decryptUDF(Item *const col, Item *const i
    l.push_back(get_key_item(key));                             |      l.push_back(get_key_item(getCInteger_().getKey()));
    // Only used for signed columns, otherwise zero.            <
    l.push_back(new (current_thd->mem_root)                     <
                    Item_int(static_cast<ulonglong>(shift)));   <
    Item *const udfdec = new (current_thd->mem_root)            |      Item *const udfdec = new Item_func_udf_int(&u_decDETInt, l)
                             Item_func_udf_int(&u_decDETInt, l) <
    Item *const udf = 0 == shift ? new (current_thd->mem_root)  |      Item *const udf = new Item_func_unsigned(udfdec);
                                       Item_func_unsigned(udfde <
                                 : new (current_thd->mem_root)  <
                                       Item_func_signed(udfdec) <
DET_abstract_number::getKeyFromSerial(const std::string &serial |  DET_abstract_integer::getKeyFromSerial(const std::string &seria
int64_t                                                         |  DET_str::DET_str(const Create_field &f, const std::string &seed
DET_abstract_number::getShift(const std::string &serial)        <
{                                                               <
    return atol(serial.substr(0, serial.find(' ')).c_str());    <
}                                                               <
                                                                <
DET_abstract_integer::DET_abstract_integer(Create_field *const  <
                                           const std::string &s <
    : DET_abstract_number(prng_expand(seed_key, bf_key_size),   <
                          getShift(cf))                         <
{}                                                              <
                                                                <
DET_abstract_integer::DET_abstract_integer(unsigned int id,     <
                                           const std::string &s <
    : DET_abstract_number(id, serial)                           <
{}                                                              <
                                                                <
int64_t                                                         <
DET_abstract_integer::getShift(const Create_field * const cf)   <
{                                                               <
    if (cf->flags & UNSIGNED_FLAG) {                            <
        return 0x00;                                            <
    } else {                                                    <
        switch (cf->sql_type) {                                 <
            case MYSQL_TYPE_TINY:                               <
                return 0x80;                                    <
            case MYSQL_TYPE_SHORT:                              <
                return 0x8000;                                  <
            case MYSQL_TYPE_INT24:                              <
                return 0x800000;                                <
            case MYSQL_TYPE_LONG:                               <
                return 0x80000000;                              <
            case MYSQL_TYPE_LONGLONG:                           <
                return 0x8000000000000000;                      <
            default:                                            <
                FAIL_TextMessageError("unknown int type!");     <
        }                                                       <
    }                                                           <
}                                                               <
                                                                <
DET_abstract_decimal::DET_abstract_decimal(Create_field *const  <
                                           const std::string &s <
    : DET_abstract_number(seed_key, pow(10, cf->decimals)),     <
      decimals(cf->decimals)                                    <
{                                                               <
    // > make sure we have at most 8 precision                  <
    // > a number with form DECIMAL(a, b) has decimals = b      <
    //   and length = a + b                                     <
    assert_s(cf->length - cf->decimals <= 8,                    <
             " this type of decimal not supported ");           <
                                                                <
    // decimals = cf->decimals;                                 <
    // shift = pow(10, decimals);                               <
}                                                               <
                                                                <
DET_abstract_decimal::DET_abstract_decimal(unsigned int id,     <
                                           const std::string &s <
    : DET_abstract_number(id, underSerial(serial)),             <
      decimals(getDecimals(serial))                             <
{}                                                              <
                                                                <
std::string                                                     <
DET_abstract_decimal::doSerialize() const                       <
{                                                               <
    return std::to_string(decimals) + " " +                     <
            DET_abstract_number::doSerialize();                 <
}                                                               <
                                                                <
static Item_int *                                               <
decimal_to_int(const Item_decimal &v, uint decimals,            <
               const ulonglong &shift)                          <
{                                                               <
    const ulonglong res = RiboldMYSQL::val_real(v) * shift;     <
                                                                <
    return new (current_thd->mem_root) Item_int(res);           <
}                                                               <
                                                                <
Item *DET_abstract_decimal::encrypt(const Item &ptext, uint64_t <
{                                                               <
    const Item_decimal &ptext_dec =                             <
        static_cast<const Item_decimal &>(ptext);               <
    const std::unique_ptr<Item_int>                             <
        ptext_int(decimal_to_int(ptext_dec, decimals, shift));  <
    return DET_abstract_number::encrypt(*ptext_int, IV);        <
}                                                               <
                                                                <
Item *DET_abstract_decimal::decrypt(Item *const ctext, uint64_t <
{                                                               <
    const std::unique_ptr<Item_int>                             <
        res_int(static_cast<Item_int*>(DET_abstract_number::dec <
                                                                <
    Item_decimal * const res =                                  <
        new (current_thd->mem_root) Item_decimal(res_int->value <
                                                 decimals,      <
                                                 decimals);     <
    LOG(encl) << "DET_dec dec " << res_int->value << "--->"     <
              << RiboldMYSQL::val_real(*res) << std::endl;      <
                                                                <
    return res;                                                 <
}                                                               <
                                                                <
DET_int::DET_int(Create_field *const f, const std::string &seed <
    : DET_abstract_integer(f, seed_key)                         <
{}                                                              <
                                                                <
DET_int::DET_int(unsigned int id, const std::string &serial)    <
    : DET_abstract_integer(id, serial)                          <
{}                                                              <
                                                                <
DET_dec::DET_dec(Create_field * const cf, const std::string &se <
    : DET_abstract_decimal(cf, seed_key)                        <
{}                                                              <
                                                                <
DET_dec::DET_dec(unsigned int id, const std::string &serial)    <
    : DET_abstract_decimal(id, serial)                          <
{}                                                              <
                                                                <
DET_str::DET_str(Create_field * const f, const std::string &see <
DET_str::newCreateField(const Create_field * const cf,          |  DET_str::newCreateField(const Create_field &cf,
    auto typelen = type_len_for_AES_str(cf->sql_type, cf->lengt |      const auto typelen = AESTypeAndLength(cf, do_pad);
                                                                |      return arrayCreateFieldHelper(cf, typelen.second, typelen.f
    return createFieldHelper(cf, typelen.second, typelen.first, |                                    anonname, &my_charset_bin);
                             &my_charset_bin);                  <
    const std::string enc = encrypt_AES_CMC(plain, enckey, true |      const std::string enc = encrypt_AES_CMC(plain, enckey.get()
DET_str::decrypt(Item * const ctext, uint64_t IV) const         |  DET_str::decrypt(const Item &ctext, uint64_t IV) const
    const std::string enc = ItemToString(*ctext);               |      const std::string enc = ItemToString(ctext);
    const std::string dec = decrypt_AES_CMC(enc, deckey, true); |      const std::string dec = decrypt_AES_CMC(enc, deckey.get(), 
    //TODO                                                      <
    DETJOIN_int(Create_field *const cf, const std::string &seed |      // blowfish always produces 64 bit output so we should alwa
        : DET_abstract_integer(cf, seed_key) {}                 |      // unsigned MYSQL_TYPE_LONGLONG
                                                                >      DETJOIN_int(const Create_field &cf, const std::string &seed
                                                                >      : DET_abstract_integer(),
                                                                >        cinteger(overrideCreateFieldCryptedIntegerFactory(cf,
                                                                >                                         prng_expand(seed_key, bf
                                                                >                                         signage::UNSIGNED,
                                                                >                                         MYSQL_TYPE_LONGLONG)),
                                                                >        bf(cinteger.getKey()) {}
                                                                >
    DETJOIN_int(unsigned int id, const std::string &serial)     |      DETJOIN_int(unsigned int id, const CryptedInteger &cinteger
        : DET_abstract_integer(id, serial) {}                   |          : DET_abstract_integer(id), cinteger(cinteger), bf(cint
                                                                >
                                                                >  private:
                                                                >      const CryptedInteger cinteger;
                                                                >      const blowfish bf;
                                                                >
                                                                >      const CryptedInteger &getCInteger_() const {return cinteger
                                                                >      const blowfish &getBlowfish_() const {return bf;}
    DETJOIN_str(Create_field * const cf, const std::string &see |      DETJOIN_str(const Create_field &cf, const std::string &seed
private:                                                        <
                                                                <
};                                                              <
                                                                <
class DETJOIN_dec : public DET_abstract_decimal {               <
    //TODO                                                      <
public:                                                         <
    DETJOIN_dec(Create_field *const cf, const std::string &seed <
        : DET_abstract_decimal(cf, seed_key) {}                 <
                                                                <
    // serialize from parent;  unserialize:                     <
    DETJOIN_dec(unsigned int id, const std::string &serial)     <
        : DET_abstract_decimal(id, serial) {}                   <
                                                                <
    // FIXME: final                                             <
    SECLEVEL level() const {return SECLEVEL::DETJOIN;}          <
    std::string name() const {return "DETJOIN_dec";}            <
EncLayer *                                                      |  std::unique_ptr<EncLayer>
DETJOINFactory::create(Create_field * const cf,                 |  DETJOINFactory::create(const Create_field &cf,
    if (IsMySQLTypeNumeric(cf->sql_type)) {                     |      if (isMySQLTypeNumeric(cf)) {
        if (cf->sql_type == MYSQL_TYPE_DECIMAL                  |          if (cf.sql_type == MYSQL_TYPE_DECIMAL
            || cf->sql_type == MYSQL_TYPE_NEWDECIMAL) {         |              || cf.sql_type == MYSQL_TYPE_NEWDECIMAL) {
            return new DETJOIN_dec(cf, key);                    |              FAIL_TextMessageError("decimal support is broken");
            return new DETJOIN_int(cf, key);                    |              return std::unique_ptr<EncLayer>(new DETJOIN_int(cf
        return new DETJOIN_str(cf, key);                        |          return std::unique_ptr<EncLayer>(new DETJOIN_str(cf, ke
EncLayer *                                                      |  std::unique_ptr<EncLayer>
        return new DETJOIN_int(id, sl.layer_info);              |          return DET_abstract_integer::deserialize<DETJOIN_int>(i
                                                                >                                                      sl.layer_in
        return new DETJOIN_dec(id, sl.layer_info);              |          FAIL_TextMessageError("decimal support broken");
        return new DETJOIN_str(id, sl.layer_info);              |          return std::unique_ptr<EncLayer>(new DETJOIN_str(id,
                                                                >                                                           sl.lay
    OPE_int(Create_field * const cf, const std::string &seed_ke |      OPE_int(const Create_field &cf, const std::string &seed_key
                                                                |      OPE_int(unsigned int id, const CryptedInteger &cinteger,
    // serialize and deserialize                                |              size_t plain_size, size_t ciph_size);
    std::string doSerialize() const {return key;}               |      CryptedInteger opeHelper(const Create_field &f,
    OPE_int(unsigned int id, const std::string &serial);        |                               const std::string &key);
    Create_field * newCreateField(const Create_field * const cf |
                                                                >      std::string doSerialize() const;
                                                                >      static std::unique_ptr<OPE_int>
                                                                >          deserialize(unsigned int id, const std::string &serial)
                                                                >
                                                                >      Create_field * newCreateField(const Create_field &cf,
    Item * decrypt(Item * const c, uint64_t IV) const;          |      Item *decrypt(const Item &c, uint64_t IV) const;
                                                                <
    std::string const key;                                      |      const CryptedInteger cinteger;
    // HACK.                                                    <
    mutable OPE ope;                                            <
    static const size_t plain_size = 4;                         |      const size_t plain_size;
    static const size_t ciph_size = 8;                          |      const size_t ciph_size;
                                                                >      mutable OPE ope;                      // HACK
class OPE_tinyint : public OPE_int {                            |  class OPEFOREIGN_int:public OPE_int{
public:                                                         |  public:
    OPE_tinyint(Create_field * const cf, const std::string &see |      OPEFOREIGN_int(const Create_field &cf, const std::string &s
                                                                |      OPEFOREIGN_int(unsigned int id, const CryptedInteger &cinte
    // create object from serialized contents                   |              size_t plain_size, size_t ciph_size):OPE_int(id,cin
    OPE_tinyint(unsigned int id, const std::string &serial);    |      SECLEVEL level() const {return SECLEVEL::OPEFOREIGN;}
                                                                |      std::string name() const {return "OPEFOREIGN_int";}
    std::string name() const {return "OPE_tinyint";}            |      static std::unique_ptr<OPEFOREIGN_int>
                                                                |          deserialize(unsigned int id, const std::string &serial)
    Item *encrypt(const Item &p, uint64_t IV) const;            <
    Item * decrypt(Item * const c, uint64_t IV) const;          <
OPE_tinyint::OPE_tinyint(Create_field * const cf,               <
                         const std::string &seed_key)           <
    : OPE_int(cf, seed_key)                                     <
{}                                                              <
                                                                <
OPE_tinyint::OPE_tinyint(unsigned int id, const std::string &se <
    : OPE_int(id, serial)                                       <
{}                                                              <
                                                                <
Item *                                                          <
OPE_tinyint::encrypt(const Item &ptext, uint64_t IV) const      <
{                                                               <
    const ulonglong val = RiboldMYSQL::val_uint(ptext);         <
                                                                <
    static const ulonglong tiny_max = 0xff;                     <
    TEST_TextMessageError(tiny_max > val,                       <
                          "Backend storage unit it not TINYINT, <
                          " won't floor. ");                    <
                                                                <
    LOG(encl) << "OPE_tinyint encrypt " << val << " IV " << IV  <
    return OPE_int::encrypt(ptext, static_cast<const ulong>(val <
}                                                               <
                                                                <
Item *                                                          <
OPE_tinyint::decrypt(Item * const ctext, uint64_t IV) const     <
{                                                               <
    return OPE_int::decrypt(ctext, IV);                         <
}                                                               <
                                                                <
class OPE_mediumint : public OPE_int {                          <
public:                                                         <
    OPE_mediumint(Create_field * const cf, const std::string &s <
                                                                <
    // create object from serialized contents                   <
    OPE_mediumint(unsigned int id, const std::string &serial);  <
                                                                <
    std::string name() const {return "OPE_mediumint";}          <
                                                                <
    Item *encrypt(const Item &p, uint64_t IV) const;            <
    Item * decrypt(Item * const c, uint64_t IV) const;          <
};                                                              <
                                                                <
OPE_mediumint::OPE_mediumint(Create_field * const cf,           <
                             const std::string &seed_key)       <
    : OPE_int(cf, seed_key)                                     <
{}                                                              <
                                                                <
OPE_mediumint::OPE_mediumint(unsigned int id, const std::string <
    : OPE_int(id, serial)                                       <
{}                                                              <
                                                                <
Item *                                                          <
OPE_mediumint::encrypt(const Item &ptext, uint64_t IV) const    <
{                                                               <
    const ulonglong val = RiboldMYSQL::val_uint(ptext);         <
                                                                <
    static const ulonglong medium_max = 0xffffff;               <
    TEST_TextMessageError(medium_max > val,                     <
                          "Backend storage unit it not MEDIUMIN <
                          " won't floor. ");                    <
                                                                <
    LOG(encl) << "OPE_mediumint encrypt " << val << " IV " << I <
    return OPE_int::encrypt(ptext, static_cast<const ulong>(val <
}                                                               <
                                                                <
Item *                                                          <
OPE_mediumint::decrypt(Item * const ctext, uint64_t IV) const   <
{                                                               <
    return OPE_int::decrypt(ctext, IV);                         <
}                                                               <
    OPE_str(Create_field * const cf, const std::string &seed_ke |      OPE_str(const Create_field &cf, const std::string &seed_key
    Create_field * newCreateField(const Create_field * const cf |      Create_field * newCreateField(const Create_field &cf,
    Item * decrypt(Item * const c, uint64_t IV) const           |      Item *decrypt(const Item &c, uint64_t IV) const
    std::string const key;                                      |      const std::string key;
                                                                |  class OPEFOREIGN_str: public OPE_str{
class OPE_dec : public OPE_int {                                <
    OPE_dec(Create_field * const cf, const std::string &seed_ke |      OPEFOREIGN_str(const Create_field &cf, const std::string &s
                                                                >      OPEFOREIGN_str(unsigned int id, const std::string &serial):
    // serialize and deserialize                                |      SECLEVEL level() const {return SECLEVEL::OPEFOREIGN;}
    std::string doSerialize() const;                            |      std::string name() const {return "OPEFOREIGN_str";}
    OPE_dec(unsigned int id, const std::string &serial);        <
                                                                <
    std::string name() const {return "OPE_dec";}                <
    Item *encrypt(const Item &p, uint64_t IV) const;            <
    Item * decrypt(Item * const c, uint64_t IV) const;          <
                                                                <
private:                                                        <
    uint const decimals;                                        <
    ulonglong const shift;                                      <
                                                                |  std::unique_ptr<EncLayer>
EncLayer *                                                      |  OPEFactory::create(const Create_field &cf, const std::string &k
OPEFactory::create(Create_field * const cf, const std::string & <
    if (IsMySQLTypeNumeric(cf->sql_type)) {                     |      if (isMySQLTypeNumeric(cf)) {
        if (cf->sql_type == MYSQL_TYPE_DECIMAL                  |          if (cf.sql_type == MYSQL_TYPE_DECIMAL
            || cf->sql_type ==  MYSQL_TYPE_NEWDECIMAL) {        |              || cf.sql_type ==  MYSQL_TYPE_NEWDECIMAL) {
            return new OPE_dec(cf, key);                        |              FAIL_TextMessageError("decimal support is broken");
        } else if (cf->sql_type == MYSQL_TYPE_TINY) {           <
            return new OPE_tinyint(cf, key);                    <
        } else if (cf->sql_type == MYSQL_TYPE_INT24) {          <
            return new OPE_mediumint(cf, key);                  <
        return new OPE_int(cf, key);                            |          return std::unique_ptr<EncLayer>(new OPE_int(cf, key));
    return new OPE_str(cf, key);                                |      return std::unique_ptr<EncLayer>(new OPE_str(cf, key));
EncLayer *                                                      |  std::unique_ptr<EncLayer>
        return new OPE_int(id, sl.layer_info);                  |          return OPE_int::deserialize(id, sl.layer_info);
    } else if (sl.name == "OPE_tinyint") {                      <
        return new OPE_tinyint(id, sl.layer_info);              <
    } else if (sl.name == "OPE_mediumint") {                    <
        return new OPE_mediumint(id, sl.layer_info);            <
        return new OPE_str(id, sl.layer_info);                  |          return std::unique_ptr<EncLayer>(new OPE_str(id, sl.lay
        return new OPE_dec(id, sl.layer_info);                  |          FAIL_TextMessageError("decimal support broken");
OPE_dec::OPE_dec(Create_field * const cf, const std::string &se |
    : OPE_int(cf, seed_key), decimals(cf->decimals),            |  std::unique_ptr<EncLayer>
      shift(pow(10, decimals))                                  |  OPEFOREIGNFactory::create(const Create_field &cf, const std::st
{                                                               |      if (isMySQLTypeNumeric(cf)) {
    assert_s(cf->length - cf->decimals <= 8,                    |          if (cf.sql_type == MYSQL_TYPE_DECIMAL
             "this type of decimal not supported ");            |              || cf.sql_type ==  MYSQL_TYPE_NEWDECIMAL) {
                                                                >              FAIL_TextMessageError("decimal support is broken");
                                                                >          }
                                                                >          return std::unique_ptr<EncLayer>(new OPEFOREIGN_int(cf,
                                                                >      }
                                                                >      return std::unique_ptr<EncLayer>(new OPEFOREIGN_str(cf, key
std::string                                                     |  std::unique_ptr<EncLayer>
OPE_dec::doSerialize() const                                    |  OPEFOREIGNFactory::deserialize(unsigned int id, const SerialLay
    return std::to_string(decimals) + " " + OPE_int::doSerializ |      if (sl.name == "OPEFOREIGN_int") {
                                                                >          return OPEFOREIGN_int::deserialize(id, sl.layer_info);
                                                                >      } else if (sl.name == "OPEFOREIGN_str") {
                                                                >          return std::unique_ptr<EncLayer>(new OPEFOREIGN_str(id,
                                                                >      } else {
                                                                >          FAIL_TextMessageError("decimal support broken");
                                                                >      }
OPE_dec::OPE_dec(unsigned int id, const std::string &serial)    <
    : OPE_int(id, underSerial(serial)), decimals(getDecimals(se <
      shift(pow(10, decimals))                                  <
{}                                                              <
Item *                                                          |
OPE_dec::encrypt(const Item &ptext, uint64_t IV) const          |
                                                                >
                                                                >  static size_t
                                                                >  toMultiple(size_t n, size_t multiple)
    const Item_decimal &ptext_dec =                             |      assert(multiple > 0);
        static_cast<const Item_decimal &>(ptext);               |
    const std::unique_ptr<Item_int>                             |      const size_t remainder = n % multiple;
        ptext_int(decimal_to_int(ptext_dec, decimals, shift));  |      if (0 == remainder) {
    return OPE_int::encrypt(*ptext_int.get(), IV);              |          return n;
                                                                >      return n + (multiple - remainder);
                                                                >  }
Item *                                                          |  /*
OPE_dec::decrypt(Item * const ctext, uint64_t IV) const         |   * OPE_int::opeHelper(...), opePlainSize(...) and opeCiphSize(.
                                                                >   * play nice as OPE_int::opeHelper(...) assumes the doubling of
                                                                >   * when it decides if a VARCHAR field is necessary, but this ac
                                                                >   * doesn't occur until opeCiphSize(...).
                                                                >   */
                                                                >  CryptedInteger
                                                                >  OPE_int::opeHelper(const Create_field &f, const std::string &ke
    const std::unique_ptr<Item_int>                             |      const auto plain_inclusive_range = supportsRange(f);
        res_int(static_cast<Item_int *>(OPE_int::decrypt(ctext, |      assert(0 == plain_inclusive_range.first);
    Item_decimal * const res =                                  |      // these fields can not be represented with 64 bits; HACK
        new (current_thd->mem_root) Item_decimal(res_int->value |      if (plain_inclusive_range.second > 0xFFFFFFFF) {
                                                 decimals,      |          return CryptedInteger(key, MYSQL_TYPE_VARCHAR,
                                                 decimals);     |                                plain_inclusive_range);
                                                                >      }
    return res;                                                 |      const auto crypto_inclusive_range =
                                                                >          std::make_pair(0, plain_inclusive_range.second
                                                                >                            * (2 + plain_inclusive_range.second))
                                                                >      // FIXME: pass Create_field object so we can account for si
                                                                >      const std::pair<bool, enum enum_field_types> field_type =
                                                                >          getTypeForRange(crypto_inclusive_range);
                                                                >      TEST_Text(true == field_type.first,
                                                                >                "could not build an OPE onion for field type: "
                                                                >                + TypeText<enum enum_field_types>::toText(f.sql_t
                                                                >
                                                                >      return CryptedInteger(key, field_type.second, plain_inclusi
                                                                >  }
                                                                >
                                                                >  static size_t
                                                                >  opePlainSize(const CryptedInteger &cinteger)
                                                                >  {
                                                                >      return toMultiple(log2(cinteger.getInclusiveRange().second)
                                                                >                             BITS_PER_BYTE)
                                                                >             / BITS_PER_BYTE;
                                                                >  // we need twice as many bytes for the cipher; this means that 
                                                                >  // don't actually use the field type that the user specified
                                                                >  static size_t
                                                                >  opeCiphSize(const CryptedInteger &cinteger)
                                                                >  {
                                                                >      return 2 * opePlainSize(cinteger);
                                                                >  }
OPE_int::OPE_int(Create_field * const f, const std::string &see |  OPE_int::OPE_int(const Create_field &f, const std::string &seed
    : key(prng_expand(seed_key, key_bytes)),                    |      : cinteger(opeHelper(f, prng_expand(seed_key, key_bytes))),
      ope(OPE(key, plain_size * 8, ciph_size * 8))              |        plain_size(opePlainSize(cinteger)), ciph_size(opeCiphSize
                                                                >        ope(OPE(cinteger.getKey(), plain_size * BITS_PER_BYTE,
                                                                >                ciph_size * BITS_PER_BYTE))
OPE_int::OPE_int(unsigned int id, const std::string &serial)    |  OPE_int::OPE_int(unsigned int id, const CryptedInteger &cintege
    : EncLayer(id), key(serial),                                |                   size_t plain_size, size_t ciph_size)
      ope(OPE(key, plain_size * 8, ciph_size * 8))              |      : EncLayer(id), cinteger(cinteger), plain_size(plain_size),
                                                                >        ciph_size(ciph_size),
                                                                >        ope(OPE(cinteger.getKey(), plain_size * BITS_PER_BYTE,
                                                                >                ciph_size * BITS_PER_BYTE))
                                                                >  std::unique_ptr<OPE_int>
                                                                >  OPE_int::deserialize(unsigned int id, const std::string &serial
                                                                >  {
                                                                >      const std::vector<std::string> vec = unserialize_string(ser
                                                                >      const size_t plain_bytes = strtoul_(vec[0]);
                                                                >      const size_t ciph_bytes  = strtoul_(vec[1]);
                                                                >      const CryptedInteger cint = CryptedInteger::deserialize(vec
                                                                >      return std::unique_ptr<OPE_int>(new OPE_int(id, cint, plain
                                                                >                                                  ciph_bytes) );
                                                                >  }
                                                                >
                                                                >
                                                                >  std::unique_ptr<OPEFOREIGN_int>
                                                                >  OPEFOREIGN_int::deserialize(unsigned int id, const std::string 
                                                                >  {
                                                                >      const std::vector<std::string> vec = unserialize_string(ser
                                                                >      const size_t plain_bytes = strtoul_(vec[0]);
                                                                >      const size_t ciph_bytes  = strtoul_(vec[1]);
                                                                >      const CryptedInteger cint = CryptedInteger::deserialize(vec
                                                                >      return std::unique_ptr<OPEFOREIGN_int>(new OPEFOREIGN_int(i
                                                                >                                                  ciph_bytes));
                                                                >  }
                                                                >
                                                                >
                                                                >  std::string
                                                                >  OPE_int::doSerialize() const
                                                                >  {
                                                                >      return serializeStrings({std::to_string(plain_size),
                                                                >                               std::to_string(ciph_size),
                                                                >                               cinteger.serialize()});
                                                                >  }
                                                                >
OPE_int::newCreateField(const Create_field * const cf,          |  OPE_int::newCreateField(const Create_field &cf,
    return createFieldHelper(cf, cf->length, MYSQL_TYPE_LONGLON |      if (isMySQLTypeNumeric(cinteger.getFieldType())) {
                                                                >          return integerCreateFieldHelper(cf, cinteger.getFieldTy
                                                                >      // create a varbinary column because we could not map the u
                                                                >      // desired field type into an integer column
                                                                >      assert(MYSQL_TYPE_VARCHAR == cinteger.getFieldType());
                                                                >      return arrayCreateFieldHelper(cf, ciph_size, cinteger.getFi
                                                                >                                    anonname, &my_charset_bin);
                                                                >  }
                                                                >
                                                                >  static std::string
                                                                >  reverse(const std::string &s)
                                                                >  {
                                                                >      return std::string(s.rbegin(), s.rend());
                                                                >  }
                                                                >
    // assert(!stringItem(ptext));                              |      const uint64_t pval = RiboldMYSQL::val_uint(ptext);
    // AWARE: Truncation.                                       |      cinteger.checkValue(pval);
    const uint32_t pval = RiboldMYSQL::val_uint(ptext);         <
    const ulonglong enc = uint64FromZZ(ope.encrypt(to_ZZ(pval)) <
    LOG(encl) << "OPE_int encrypt " << pval << " IV " << IV     <
              << "--->" << enc;                                 <
    return new (current_thd->mem_root) Item_int(enc);           |      LOG(encl) << "OPE_int encrypt " << pval << " IV " << IV << 
                                                                >
                                                                >      if (MYSQL_TYPE_VARCHAR != this->cinteger.getFieldType()) {
                                                                >          const ulonglong enc = uint64FromZZ(ope.encrypt(ZZFromUi
                                                                >          return new Item_int(enc);
                                                                >      }
                                                                >
                                                                >      // > the result of the encryption could be larger than 64 b
                                                                >      //   don't try to handle with an integer
                                                                >      // > the ``stringd'' ZZ must be reversed because we want th
                                                                >      //   from high to low order bytes
                                                                >      // > leading zeros must be added because not all numbers wi
                                                                >      //   allotted bytes and we don't want mysql to do a misalig
                                                                >      const std::string &enc_string =
                                                                >          leadingZeros(reverse(StringFromZZ(ope.encrypt(ZZFromUin
                                                                >                       this->ciph_size);
                                                                >
                                                                >
                                                                >      return new Item_string(make_thd_string(enc_string),
                                                                >                             enc_string.length(),
                                                                >                             &my_charset_bin);
OPE_int::decrypt(Item * const ctext, uint64_t IV) const         |  OPE_int::decrypt(const Item &ctext, uint64_t IV) const
    const ulonglong cval =                                      |      LOG(encl) << "OPE_int decrypt " << ItemToString(ctext) << "
        static_cast<ulonglong>(static_cast<Item_int *>(ctext)-> |                << std::endl;
    const ulonglong dec = uint64FromZZ(ope.decrypt(ZZFromUint64 <
    LOG(encl) << "OPE_int decrypt " << cval << " IV " << IV     <
              << "--->" << dec << std::endl;                    <
    return new (current_thd->mem_root) Item_int(dec);           |      if (MYSQL_TYPE_VARCHAR != this->cinteger.getFieldType()) {
                                                                >          const ulonglong cval = RiboldMYSQL::val_uint(ctext);
                                                                >          return new Item_int(static_cast<ulonglong>(uint64FromZZ
                                                                >      }
                                                                >
                                                                >      // undo the reversal from encryption
                                                                >      return new Item_int(static_cast<ulonglong>(uint64FromZZ(ope
OPE_str::OPE_str(Create_field * const f, const std::string &see |  OPE_str::OPE_str(const Create_field &f, const std::string &seed
      ope(OPE(key, plain_size * 8, ciph_size * 8))              |        ope(OPE(key, plain_size * BITS_PER_BYTE, ciph_size * BITS
    ope(OPE(key, plain_size * 8, ciph_size * 8))                |      ope(OPE(key, plain_size * BITS_PER_BYTE, ciph_size * BITS_P
OPE_str::newCreateField(const Create_field * const cf,          |  OPE_str::newCreateField(const Create_field &cf,
    return createFieldHelper(cf, cf->length, MYSQL_TYPE_LONGLON |      return arrayCreateFieldHelper(cf, cf.length, MYSQL_TYPE_LON
OPE_str::decrypt(Item * const ctext, uint64_t IV) const         |  OPE_str::decrypt(const Item &ctext, uint64_t IV) const
class HOM_dec : public HOM {                                    |  std::unique_ptr<EncLayer>
public:                                                         |  HOMFactory::create(const Create_field &cf, const std::string &k
    HOM_dec(Create_field * const cf, const std::string &seed_ke <
                                                                <
    //deserialize                                               <
    HOM_dec(unsigned int id, const std::string &serial);        <
                                                                <
    std::string name() const {return "HOM_dec";}                <
                                                                <
                                                                <
    //TODO needs multi encrypt and decrypt                      <
    Item *encrypt(const Item &p, uint64_t IV) const;            <
    Item * decrypt(Item * const c, uint64_t IV) const;          <
                                                                <
    //expr is the expression (e.g. a field) over which to sum   <
    Item *sumUDA(Item *const expr) const;                       <
    Item *sumUDF(Item *const i1, Item *const i2) const;         <
                                                                <
private:                                                        <
    uint const decimals;                                        <
    ZZ const shift;                                             <
                                                                <
    std::string doSerialize() const;                            <
    ~HOM_dec() {;}                                              <
};                                                              <
                                                                <
                                                                <
EncLayer *                                                      <
HOMFactory::create(Create_field * const cf, const std::string & <
    if (cf->sql_type == MYSQL_TYPE_DECIMAL                      |      if (cf.sql_type == MYSQL_TYPE_DECIMAL
        || cf->sql_type == MYSQL_TYPE_NEWDECIMAL) {             |          || cf.sql_type == MYSQL_TYPE_NEWDECIMAL) {
        return new HOM_dec(cf, key);                            |          FAIL_TextMessageError("decimal support is broken");
    return new HOM(cf, key);                                    |      return std::unique_ptr<EncLayer>(new HOM(cf, key));
EncLayer *                                                      |  std::unique_ptr<EncLayer>
HOMFactory::deserialize(unsigned int id, const SerialLayer &ser |  HOMFactory::deserialize(unsigned int id, const SerialLayer &ser
{                                                               <
        return new HOM_dec(id, serial.layer_info);              |          FAIL_TextMessageError("decimal support broken");
    return new HOM(id, serial.layer_info);                      |      return std::unique_ptr<EncLayer>(new HOM(id, serial.layer_i
    const std::string str = StringFromZZ(val);                  |      const std::string &str = StringFromZZ(val);
ItemStrToZZ(Item *const i)                                      |  ItemStrToZZ(const Item &i)
    const std::string res = ItemToString(*i);                   |      return ZZFromString(ItemToString(i));
    return ZZFromString(res);                                   <
HOM_dec::HOM_dec(Create_field * const cf, const std::string &se <
    : HOM(cf, seed_key), decimals(cf->decimals),                <
      shift(power(to_ZZ(10), decimals))                         <
{                                                               <
    assert_s(cf->length <= 120, "too large decimal for HOM laye <
}                                                               <
                                                                <
std::string                                                     <
HOM_dec::doSerialize() const                                    <
{                                                               <
    return std::to_string(decimals) + " " + HOM::doSerialize(); <
}                                                               <
                                                                <
HOM_dec::HOM_dec(unsigned int id, const std::string &serial)    <
    : HOM(id, underSerial(serial)), decimals(getDecimals(serial <
      shift(power(to_ZZ(10), decimals))                         <
{}                                                              <
                                                                <
static ZZ                                                       <
ItemDecToZZ(const Item &ptext, const ZZ &shift, uint decimals)  <
{                                                               <
    bool is_null;                                               <
    // ss is a number                                           <
    // : - xxxx.yyyy                                            <
    const std::string &ss(RiboldMYSQL::val_str(ptext, &is_null) <
    assert(false == is_null);                                   <
                                                                <
    std::string ss_int = ss.substr(0, ss.find('.')); // integer <
    if (ss_int == "") ss_int = "0";                             <
    std::string ss_dec = "";                                    <
    if (ss.find('.') != std::string::npos) {                    <
        ss_dec = ss.substr(ss.find('.') + 1); // decimal part   <
    }                                                           <
    const uint actual_decs = ss_dec.length();                   |  HOM::HOM(const Create_field &f, const std::string &seed_key)
    assert_s(actual_decs <= decimals, "value has more decimals  <
                                                                <
    ZZ val_int = ZZFromDecString(ss_int);                       <
    ZZ val_dec = ZZFromDecString(ss_dec);                       <
                                                                <
    // make an integer out of it                                <
    val_dec = val_dec * power(to_ZZ(10), decimals - actual_decs <
                                                                <
    return val_int * shift + val_dec;                           <
}                                                               <
                                                                <
static Item_decimal *                                           <
ZZToItemDec(const ZZ &val, const ZZ &shift)                     <
{                                                               <
    const ZZ val_int = val / shift;                             <
    const ZZ val_dec = val % shift;                             <
                                                                <
    const std::string num =                                     <
        DecStringFromZZ(val_int) + "." + DecStringFromZZ(val_de <
                                                                <
    return new (current_thd->mem_root) Item_decimal(num.data(), <
                                                    num.length( <
                                                    &my_charset <
}                                                               <
                                                                <
                                                                <
Item *                                                          <
HOM_dec::encrypt(const Item &ptext, uint64_t IV) const          <
{                                                               <
    const ZZ enc = sk->encrypt(ItemDecToZZ(ptext, shift, decima <
                                                                <
    return ZZToItemStr(enc);                                    <
}                                                               <
                                                                <
Item *                                                          <
HOM_dec::decrypt(Item * const ctext, uint64_t IV) const         <
{                                                               <
    const ZZ enc = ItemStrToZZ(ctext);                          <
    const ZZ dec = sk->decrypt(enc);                            <
                                                                <
    return ZZToItemDec(dec, shift);                             <
}                                                               <
                                                                <
                                                                <
                                                                <
HOM::HOM(Create_field * const f, const std::string &seed_key)   <
HOM::newCreateField(const Create_field * const cf,              |  HOM::newCreateField(const Create_field &cf,
                    const std::string &anonname) const          |                      const std::string &anonname) const{
{                                                               |      return arrayCreateFieldHelper(cf, 2*nbits/BITS_PER_BYTE,
    return createFieldHelper(cf, 2*nbits/8, MYSQL_TYPE_VARCHAR, |                                    MYSQL_TYPE_VARCHAR, anonname,
                             anonname, &my_charset_bin);        |                                    &my_charset_bin);
                                                                >  //if first, use seed key to generate 
                                                                >
HOM::unwait() const                                             |  HOM::unwait() const {
{                                                               <
HOM::encrypt(const Item &ptext, uint64_t IV) const              |  HOM::encrypt(const Item &ptext, uint64_t IV) const{
{                                                               <
HOM::decrypt(Item * const ctext, uint64_t IV) const             |  HOM::decrypt(const Item &ctext, uint64_t IV) const
                                                                >      TEST_Text(NumBytes(dec) <= 8,
                                                                >                "Summation produced an integer larger than 64 bit
Search::Search(Create_field * const f, const std::string &seed_ |  Search::Search(const Create_field &f, const std::string &seed_k
Search::newCreateField(const Create_field * const cf,           |  Search::newCreateField(const Create_field &cf,
    return createFieldHelper(cf, cf->length, MYSQL_TYPE_BLOB, a |      return arrayCreateFieldHelper(cf, cf.length, MYSQL_TYPE_BLO
                             &my_charset_bin);                  |                                    anonname, &my_charset_bin);
Search::decrypt(Item * const ctext, uint64_t IV) const          |  Search::decrypt(const Item &ctext, uint64_t IV) const
PlainText::newCreateField(const Create_field * const cf,        |  PlainText::newCreateField(const Create_field &cf,
    Create_field * const f0 = cf->clone(thd->mem_root);         |      Create_field * const f0 = cf.clone(thd->mem_root);
PlainText::decrypt(Item *const ctext, uint64_t IV) const        |  PlainText::decrypt(const Item &ctext, uint64_t IV) const
    return dup_item(*ctext);                                    |      return dup_item(ctext);
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/CryptoHandlers.hh Practical-Cryptdb/main/CryptoHandlers.hh
                                                                >  #include <main/macro_util.hh>
    std::string typeName() const {return type_name;}            |      TYPENAME("encLayer")
    static std::string instanceTypeName() {return type_name;}   <
        newCreateField(const Create_field * const cf,           |          newCreateField(const Create_field &cf,
    virtual Item *decrypt(Item * const ctext, uint64_t IV) cons |      virtual Item *decrypt(const Item &ctext, uint64_t IV) const
                                                                <
private:                                                        <
     constexpr static const char * type_name = "encLayer";      <
    HOM(Create_field * const cf, const std::string &seed_key);  |      HOM(const Create_field &cf, const std::string &seed_key);
                                                                >      ~HOM();
    Create_field * newCreateField(const Create_field * const cf |      Create_field * newCreateField(const Create_field &cf,
    Item * decrypt(Item * const c, uint64_t IV) const;          |      Item * decrypt(const Item &c, uint64_t IV) const;
    ~HOM();                                                     <
                                                                <
    Search(Create_field * const cf, const std::string &seed_key |      Search(const Create_field &cf, const std::string &seed_key)
    Create_field * newCreateField(const Create_field * const cf |      Create_field * newCreateField(const Create_field &cf,
    Item * decrypt(Item * const ctext, uint64_t IV) const       |      Item * decrypt(const Item &ctext, uint64_t IV) const
    static EncLayer * encLayer(onion o, SECLEVEL sl,            |      static std::unique_ptr<EncLayer>
                               Create_field * const cf,         |          encLayer(onion o, SECLEVEL sl, const Create_field &cf,
    static EncLayer * deserializeLayer(unsigned int id,         |      static std::unique_ptr<EncLayer>
                                       const std::string &seria |          deserializeLayer(unsigned int id, const std::string &se
    virtual Create_field *newCreateField(const Create_field * c |      virtual Create_field *newCreateField(const Create_field &cf
    Item *decrypt(Item * const ctext, uint64_t IV) const;       |      Item *decrypt(const Item &ctext, uint64_t IV) const;
                                                                >
                                                                >
                                                                >
                                                                >
                                                                >
                                                                >
                                                                >
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/dbobject.hh Practical-Cryptdb/main/dbobject.hh
                                                                >  #include <algorithm>
// FIXME: Maybe should inherit from DBObject.                   |
class AbstractMetaKey {                                         |  // FIXME: Maybe should inherit from DBObject.(but it do not nee
                                                                >
                                                                >  /*provide static factory for get a key type*/
                                                                >  class AbstractMetaKey : public NormalAlloc {
                                                                >      /* used in mappedDBmeta: factory<KeyType> */
        static ConcreteKey *factory(std::string serial)         |          static ConcreteKey *factory(std::string serial) {
    {                                                           |          /*dummy is not used!!*/
                                                                >  /*
                                                                >  *we have onionMetaKey,UIntMetaKey and IdentityMetaKey for metad
                                                                >  *meta key provides KeyType and Serial
                                                                >  */
                                                                >      /*key can be inserted into a map, so it must support those 
                                                                >
                                                                >  /*
                                                                >  *this is metakey<string>
                                                                >  */
                                                                >  /*
                                                                >  *this is metakey<onion>
                                                                >  */
                                                                >
                                                                >  /*
                                                                >  *this is metakey<int>,and it should be noted that onion is diff
                                                                >  */
    virtual std::string serialize(unsigned int i)               |      virtual std::string serialize(unsigned int i){
    {                                                           <
    virtual unsigned int unserialize(std::string s)             |      virtual unsigned int unserialize(std::string s){
    {                                                           <
                                                                >
                                                                >  /*
                                                                >  * DBObject intends to give each object of this type an 
                                                                >  * id, which can be written into the embeeded database.
                                                                >  */
                                                                <
    // FIXME: This should possibly be a part of DBMeta.         <
    // > Parent will definitely be DBMeta.                      <
    // > Parent-Child semantics aren't really added until DBMet <
    virtual std::string serialize(const DBObject &parent) const <
                                                                >
class DBMeta : public DBObject {                                |
                                                                >  class DBMeta : public DBObject, public NormalAlloc {
                                                                >
                                                                >      /* */
    // Stops processing on error.                               |      /* */
        applyToChildren(std::function<bool(const DBMeta &)>)    |          applyToChildren(std::function<bool(const DBMeta &)>) co
        const = 0;                                              |      /*traverse the map to get the key for the conresponding chi
    virtual AbstractMetaKey const &getKey(const DBMeta &child)  |      virtual AbstractMetaKey const &getKey(const DBMeta &child) 
        const = 0;                                              |      /*each item in the meta hierachy should be able to serializ
                                                                |      virtual std::string serialize(const DBObject &parent) const
                                                                >
                                                                >      /*from DBmeta*/
        fetchChildren(const std::unique_ptr<Connect> &e_conn)   |          fetchChildren(const std::unique_ptr<Connect> &e_conn) {
    {                                                           <
                                                                >      /*from DBmeta*/
        fn) const                                               |          fn) const {
    {                                                           <
    AbstractMetaKey const &getKey(const DBMeta &child) const    |      /*if this is an abstract function, then enclayers can be ac
    {                                                           |      AbstractMetaKey const &getKey(const DBMeta &child) const {
        // FIXME:                                               <
                                                                >
                                                                >  /*
                                                                >  * ChildType is an instance of EncLayer, and KeyType could be Me
                                                                >  */
    virtual bool addChild(KeyType key,                          |
                          std::unique_ptr<ChildType> meta);     |      virtual bool addChild(KeyType key, std::unique_ptr<ChildTyp
    virtual ChildType *                                         |      virtual ChildType * getChild(const KeyType &key) const;
        getChild(const KeyType &key) const;                     |
                                                                >      /*the return type is different from that of DBMeta, what ar
                                                                >
    bool applyToChildren(std::function<bool(const DBMeta &)>    <
        fn) const;                                              <
    // FIXME: Make protected.                                   |      /*inherited from DBMeta*/
                                                                >      bool applyToChildren(std::function<bool(const DBMeta &)> fn
                                                                >
                                                                >      const std::map<KeyType, std::unique_ptr<ChildType> > &
                                                                >          getChildren() const {
                                                                >              return children;
                                                                >          }
                                                                >      /*when is this used???*/
                                                                >      virtual const ChildType *
                                                                >          getChildWithGChild(const DBMeta &gchild) const;
                                                                >  private:
                                                                >
                                                                >  /*store the hirechy of metadata as a map. For example, each dat
                                                                >  *then in the databasemeta stores a map of tables. The keys are 
                                                                >  *and the values are of type DBMeta.
                                                                >  */
#include <main/dbobject.tt>                                     |
                                                                >
                                                                >
                                                                >  /*template implemented in dbobject.hh*/
                                                                >  template <typename KeyType>
                                                                >  bool MetaKey<KeyType>::operator <(const MetaKey<KeyType> &rhs) 
                                                                >  {
                                                                >      return key_data < rhs.key_data;
                                                                >  }
                                                                >
                                                                >  template <typename KeyType>
                                                                >  bool MetaKey<KeyType>::operator ==(const MetaKey<KeyType> &rhs)
                                                                >      return key_data == rhs.key_data;
                                                                >  }
                                                                >
                                                                >  template <typename ChildType, typename KeyType>
                                                                >  bool
                                                                >  MappedDBMeta<ChildType, KeyType>::addChild(KeyType key,
                                                                >                                             std::unique_ptr<Chil
                                                                >      if (childExists(key)) {
                                                                >          return false;
                                                                >      }
                                                                >      children[key] = std::move(meta);
                                                                >      return true;
                                                                >  }
                                                                >
                                                                >  template <typename ChildType, typename KeyType>
                                                                >  bool
                                                                >  MappedDBMeta<ChildType, KeyType>::childExists(const KeyType &ke
                                                                >  {
                                                                >      return children.end() != children.find(key);
                                                                >  }
                                                                >
                                                                >  // Slow.
                                                                >  // FIXME: Use findChild.
                                                                >  template <typename ChildType, typename KeyType>
                                                                >  ChildType *
                                                                >  MappedDBMeta<ChildType, KeyType>::getChild(const KeyType &key) 
                                                                >  {
                                                                >      for (const auto &it : children) {
                                                                >          if (it.first == key) {
                                                                >              return it.second.get();
                                                                >          }
                                                                >      }
                                                                >
                                                                >      return NULL;
                                                                >  }
                                                                >
                                                                >  // NOTE: Slow.
                                                                >  template <typename ChildType, typename KeyType>
                                                                >  KeyType const &
                                                                >  MappedDBMeta<ChildType, KeyType>::getKey(const DBMeta &child) c
                                                                >      for (const auto &it : children) {
                                                                >          if (it.second.get() == &child) {
                                                                >              return it.first;
                                                                >          }
                                                                >      }
                                                                >      assert(false);
                                                                >  }
                                                                >
                                                                >  template <typename ChildType, typename KeyType>
                                                                >  std::vector<DBMeta *>
                                                                >  MappedDBMeta<ChildType, KeyType>::fetchChildren(const std::uniq
                                                                >      // Perhaps it's conceptually cleaner to have this lambda re
                                                                >      // pairs of keys and children and then add the children fro
                                                                >      // scope.
                                                                >      std::function<DBMeta *(const std::string &,
                                                                >                             const std::string &,
                                                                >                             const std::string &)>
                                                                >          deserialize =
                                                                >          [this] (const std::string &key, const std::string &seri
                                                                >                  const std::string &id)
                                                                >          {
                                                                >              const std::unique_ptr<KeyType>
                                                                >                  meta_key(AbstractMetaKey::factory<KeyType>(key)
                                                                >              //DatabaseMeta::deserialize
                                                                >              auto dChild = ChildType::deserialize;
                                                                >              std::unique_ptr<ChildType>
                                                                >                  new_old_meta(dChild(atoi(id.c_str()), serial));
                                                                >              // Gobble the child.
                                                                >              this->addChild(*meta_key, std::move(new_old_meta));
                                                                >              return this->getChild(*meta_key);
                                                                >          };
                                                                >
                                                                >      return DBMeta::doFetchChildren(e_conn, deserialize);
                                                                >  }
                                                                >
                                                                >
                                                                >  template <typename ChildType, typename KeyType>
                                                                >  bool
                                                                >  MappedDBMeta<ChildType, KeyType>::applyToChildren(
                                                                >                              std::function<bool(const DBMeta &)>
                                                                >      for (const auto &it : children) {
                                                                >          if (false == fn(*it.second.get())) {
                                                                >              return false;
                                                                >          }
                                                                >      }
                                                                >      return true;
                                                                >  }
                                                                >
                                                                >
                                                                >  template <typename ChildType, typename KeyType>
                                                                >  const ChildType *MappedDBMeta<ChildType, KeyType>::
                                                                >  getChildWithGChild(const DBMeta &gchild) const{
                                                                >      bool match = false;
                                                                >      for (const auto &it : this->getChildren()){
                                                                >          std::function<bool(const DBMeta &)> misGet =           
                                                                >                      [&it, &gchild, &match] (const DBMeta &possi
                                                                >                          if (&possible_match == &gchild) {
                                                                >                              match = true;
                                                                >                              return false;       // shortcircuit
                                                                >                          }
                                                                >
                                                                >                          return true;
                                                                >                      };
                                                                >
                                                                >          it.second->applyToChildren(misGet);
                                                                >          if (true == match) {
                                                                >              return it.second.get();
                                                                >          }
                                                                >      }
                                                                >      return nullptr;
                                                                >  }
                                                                >
Only in cryptdb-popa/main: dbobject.tt
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/ddl_handler.cc Practical-Cryptdb/main/ddl_handler.cc
                                                                >  #include <csignal>
                                                                >
                                                                >  #include <main/metadata_tables.hh>
class CreateTableHandler : public DDLHandler {                  |  #include <util/yield.hpp>
    virtual LEX *rewriteAndUpdate(Analysis &a, LEX *lex,        |
                                  const ProxyState &ps) const   |
    {                                                           |  //a list of ddl handlers, buildddlhandler, and ddlexecutor
        const std::string db_name =                             |
            lex->select_lex.table_list.first->db;               |  //#############################################################
        TEST_DatabaseDiscrepancy(db_name, a.getDatabaseName()); |  AbstractQueryExecutor *
        const std::string table =                               |          CreateTableHandler::rewriteAndUpdate(Analysis &a, LEX *
            lex->select_lex.table_list.first->table_name;       |      {
                                                                >          assert(a.deltas.size() == 0);
                                                                >
                                                                >          TEST_DatabaseDiscrepancy(pre.dbname, a.getDatabaseName(
                                                                >          TEST_Text(DB_TYPE_INNODB == lex->create_info.db_type->d
                                                                >                    "InnoDB is the only supported ENGINE")
                                                                >
                                                                >          // partitioning information is not currently printed by
                                                                >          // stringifications algorithms which leads to a truncat
                                                                >          TEST_Text(NULL == lex->part_info,
                                                                >                    "CryptDB does not support partitioning");
                                                                >
        if (lex->create_info.options & HA_LEX_CREATE_TABLE_LIKE |          TEST_Text(
            cryptdb_err() << "No support for create table like  |                  !(lex->create_info.options & HA_LEX_CREATE_TABL
                          << "If you see this, please implement |                  "No support for create table like yet. "
        }                                                       |                  "If you see this, please implement me");
        if (false == a.tableMetaExists(db_name, table)) {       |          if (false == a.tableMetaExists(pre.dbname, pre.table)) 
            // > We also know that rewrite_table_list is going  |              // > We do not currently support CREATE + SELECT sy
            // find this table in 'a'.                          |              //   ! CREATE TABLE t2 SELECT * FROM t1;
                                                                >              // > We also know that Analysis does not have a ref
                                                                >              //   the table as it depends on SchemaInfo.
            assert(1 == new_lex->select_lex.table_list.elements |              TEST_Text(1 == new_lex->select_lex.table_list.eleme
                                                                >                        "we do not support multiple tables in a C
                                                                >                        " TABLE queries");
                                                                >              //new table_list only contain one element
                                                                >              // collect the keys (and their types) as they may a
                                                                >              // layout we use
                                                                >              const auto &key_data = collectKeyData(*lex);
                                                                >
                                                                >              //这里给出了create的获取. alter_info代码被摘出来了.
                                                                >
                                                                >              //对现有的每个field, 如id,name, 都在内部通过createA
                                                                >              //其中洋葱有多个层, 其通过newCreateField函数, 决定
                                                                >              //扩展以后, 就是新的Create_field类型了, 这了返回的l
                                                                >              //key data在这里的作用是, 决定是不是unique, 从而选
                    [&a, &ps, &tm] (List<Create_field> out_list |                      [&a, &tm, &key_data] (List<Create_field> ou
                        return createAndRewriteField(a, ps, cf, |                          return createAndRewriteField(a, cf, tm.
                                                     true, out_ |                                                       true, key_
                                                                <
            auto key_it =                                       |              highLevelRewriteKey(*tm.get(), *lex, new_lex, a);
                List_iterator<Key>(lex->alter_info.key_list);   |              highLevelRewriteForeignKey(*tm.get(), *lex, new_lex
            new_lex->alter_info.key_list =                      <
                accumList<Key>(key_it,                          <
                    [&tm, &a] (List<Key> out_list, Key *const k <
                    {                                           <
                        auto keys = rewrite_key(*tm.get(), key, <
                        out_list.concat(vectorToListWithTHD(key <
                                                                <
                        return out_list;                        <
                    });                                         <
                                                                <
                                                                >              //建立了db=>table的关系, 作为delta实现. 然后delta会
                                            a.getDatabaseMeta(d |                                              a.getDatabaseMeta(p
                                            IdentityMetaKey(tab |                                              IdentityMetaKey(pre
                                                                <
            // Make sure we aren't trying to create a table tha <
                                  "Table " + table + " already  |                                  "Table " + pre.table + " alread
                                                                |              //why still rewrite here???
            // -----------------------------                    <
            //         Rewrite TABLE                            <
            // -----------------------------                    <
            new_lex->select_lex.table_list =                    <
                rewrite_table_list(lex->select_lex.table_list,  <
            // > We do not rewrite the fields because presumabl <
            // can do a CREATE TABLE IF NOT EXISTS for a table  <
            // exists, but with fields that do not actually exi <
            // > This would cause problems when trying to look  <
            // for these non-existant fields.                   <
            // > We may want to do some additional non-determin <
            // anonymization of the fieldnames to prevent infor <
            // (ie, server gets compromised, server logged all  <
            // attacker can see that the admin creates the acco <
            // with the credit card field every time the server <
                                                                |          //在handler的第一阶段, 通过analysis搜集delta以及执行计
        return new_lex;                                         |          //执行计划, 新的lex里面包含了改写以后的语句, 直接转化成
                                                                >          return new DDLQueryExecutor(*new_lex, std::move(a.delta
};                                                              <
// > TODO: mysql permits a single ALTER TABLE command to invoke |
//   and _different_ subcommands.                               |
//   ie, ALTER TABLE t ADD COLUMN x integer, ADD INDEX i (z);   |
//   Currently we do not support mixed operations.              |
//   > Must guarentee that rewrite_table_list is only called on |  //#############################################################
//   > If we drop Keys and Columns in the same query the order  |  // mysql does not support indiscriminate add-drops
//     going to get changed.                                    |  // ie,
                                                                >  //      mysql> create table pk (x integer);
                                                                >  //      Query OK, 0 rows affected (0.09 sec)
                                                                >  //
                                                                >  //      mysql> alter table pk drop column x, add column x integ
                                                                >  //                            drop column x;
                                                                >  //      ERROR 1091 (42000): Can't DROP 'x'; check that column/k
                                                                >  //
                                                                >  //      mysql> alter table pk drop column x, add column x integ
                                                                >  //      Query OK, 0 rows affected (0.03 sec)
                                                                >  //      Records: 0  Duplicates: 0  Warnings: 0
    virtual LEX *rewriteAndUpdate(Analysis &a, LEX *lex,        |      virtual AbstractQueryExecutor *
                                  const ProxyState &ps) const   |          rewriteAndUpdate(Analysis &a, LEX *lex, const Preamble 
        assert(sub_dispatcher->canDo(lex));                     |          assert(a.deltas.size() == 0);
                                                                >
                                                                >          TEST_Text(sub_dispatcher->canDo(lex),
                                                                >                    "your ALTER TABLE query may require at least 
                                                                >                    " unsupported feature");
                                                                >          assert(handlers.size() > 0);
            new_lex = it->transformLex(a, new_lex, ps);         |              new_lex = it->transformLex(a, new_lex);
        return new_lex;                                         |          return new DDLQueryExecutor(*new_lex, std::move(a.delta
                                                                >
                                                                >
                                                                >  //#############################################################
                                                                >
                                                                >
    virtual LEX *rewriteAndUpdate(Analysis &a, LEX *lex,        |      virtual AbstractQueryExecutor *
                                  const ProxyState &ps) const   |          rewriteAndUpdate(Analysis &a, LEX *lex, const Preamble 
        LEX *final_lex = rewrite(a, lex, ps);                   |          assert(a.deltas.size() == 0);
        update(a, lex, ps);                                     |
                                                                >          LEX *const final_lex = rewrite(a, lex);
                                                                >          update(a, lex);
        return final_lex;                                       |          return new DDLQueryExecutor(*final_lex, std::move(a.del
    LEX *rewrite(Analysis &a, LEX *lex, const ProxyState &ps) c |      LEX *rewrite(Analysis &a, LEX *lex) const
    void update(Analysis &a, LEX *lex, const ProxyState &ps) co |      void update(Analysis &a, LEX *lex) const
                                                                >
                                                                >  //#############################################################
                                                                >
    virtual LEX *rewriteAndUpdate(Analysis &a, LEX *const lex,  |      virtual AbstractQueryExecutor *
                                  const ProxyState &ps) const   |          rewriteAndUpdate(Analysis &a, LEX *const lex, const Pre
                                                                >              const
        const std::string dbname =                              |          assert(a.deltas.size() == 0);
                                                                >
                                                                >          const std::string &dbname =
                                                                >              //可以看到, 建立数据库的时候,和建立表的时候类型, 使
                                                                >             
                                                                |          return new DDLQueryExecutor(*copyWithTHD(lex), std::mov
        return copyWithTHD(lex);                                <
                                                                >
                                                                >  //#############################################################
                                                                >
    virtual LEX *rewriteAndUpdate(Analysis &a, LEX *const lex,  |      virtual AbstractQueryExecutor *
                                  const ProxyState &ps) const   |          rewriteAndUpdate(Analysis &a, LEX *const lex, const Pre
                                                                >              const
        return copyWithTHD(lex);                                |          assert(a.deltas.size() == 0);
                                                                >          return new SimpleExecutor();
                                                                >
                                                                >  //#############################################################
    virtual LEX *rewriteAndUpdate(Analysis &a, LEX *const lex,  |      virtual AbstractQueryExecutor *
                                  const ProxyState &ps) const   |          rewriteAndUpdate(Analysis &a, LEX *const lex, const Pre
                                                                >              const
        const std::string dbname =                              |          assert(a.deltas.size() == 0);
            convert_lex_str(lex->name);                         |
        DatabaseMeta &dm = a.getDatabaseMeta(dbname);           |          const std::string &dbname = convert_lex_str(lex->name);
                                                                >          const DatabaseMeta &dm = a.getDatabaseMeta(dbname);
        return copyWithTHD(lex);                                |          return new DDLQueryExecutor(*copyWithTHD(lex), std::mov
                                                                >
                                                                >  //#############################################################
    virtual LEX *rewriteAndUpdate(Analysis &a, LEX *const lex,  |      virtual AbstractQueryExecutor *
                                  const ProxyState &ps) const   |          rewriteAndUpdate(Analysis &a, LEX *const lex, const Pre
                                                                >              const
                                                                >          assert(a.deltas.size() == 0);
                                                                >
        return new_lex;                                         |          return new DDLQueryExecutor(*new_lex, std::move(a.delta
                                                                >      }
                                                                >  };
                                                                >
                                                                >
                                                                >  //#############################################################
                                                                >  class CreateIndexHandler : public DDLHandler {
                                                                >      virtual AbstractQueryExecutor *
                                                                >          rewriteAndUpdate(Analysis &a, LEX *const lex, const Pre
                                                                >              const
                                                                >      {
                                                                >          assert(a.deltas.size() == 0);
                                                                >
                                                                >          LEX *const new_lex = copyWithTHD(lex);
                                                                >
                                                                >          // rewrite table
                                                                >          new_lex->select_lex.table_list =
                                                                >              rewrite_table_list(lex->select_lex.table_list, a);
                                                                >
                                                                >          TEST_DatabaseDiscrepancy(pre.dbname, a.getDatabaseName(
                                                                >          TableMeta const &tm = a.getTableMeta(pre.dbname, pre.ta
                                                                >
                                                                >          highLevelRewriteKey(tm, *lex, new_lex, a);
                                                                >
                                                                >          return new DDLQueryExecutor(*new_lex, std::move(a.delta
LEX *DDLHandler::transformLex(Analysis &a, LEX *lex,            |
                              const ProxyState &ps) const       |  static std::string
                                                                >  empty_if_null(const char *const p)
                                                                >  {
                                                                >      if (p) return std::string(p);
                                                                >
                                                                >      return std::string("");
                                                                >  }
                                                                >
                                                                >  AbstractQueryExecutor *DDLHandler::
                                                                >  transformLex(Analysis &a, LEX *lex) const
    return this->rewriteAndUpdate(a, lex, ps);                  |
                                                                >      assert(a.deltas.size() == 0);
                                                                >
                                                                >      AssignOnce<std::string> db;
                                                                >      AssignOnce<std::string> table;
                                                                >
                                                                >      if (lex->select_lex.table_list.first) {
                                                                >          db = empty_if_null(lex->select_lex.table_list.first->db
                                                                >          table =
                                                                >              empty_if_null(lex->select_lex.table_list.first->tab
                                                                >      } else {
                                                                >          db =  "", table = "";
                                                                >      }
                                                                >      auto executor =
                                                                >          this->rewriteAndUpdate(a, lex, Preamble(db.get(), table
                                                                >      assert(a.deltas.size() == 0);
                                                                >
                                                                >      return executor;
                                                                >      h = new CreateIndexHandler();
                                                                >      dispatcher->addHandler(SQLCOM_CREATE_INDEX, h);
                                                                >
                                                                >
                                                                >  std::pair<AbstractQueryExecutor::ResultType, AbstractAnything *
                                                                >  DDLQueryExecutor::
                                                                >  nextImpl(const ResType &res, const NextParams &nparams)
                                                                >  {
                                                                >      reenter(this->corot) {
                                                                >          yield {
                                                                >              {
                                                                >                  uint64_t embedded_completion_id;
                                                                >                  TEST_ErrPkt(
                                                                >                      deltaOutputBeforeQuery(nparams.ps.getEConn(
                                                                >                                             nparams.original_que
                                                                >                                             this->new_query, thi
                                                                >                                             CompletionType::DDL,
                                                                >                                             &embedded_completion
                                                                >                      "deltaOutputBeforeQuery failed for DDL");
                                                                >                  this->embedded_completion_id = embedded_complet
                                                                >              }
                                                                >              return CR_QUERY_AGAIN(this->new_query);
                                                                >          }
                                                                >          TEST_ErrPkt(res.success(), "DDL query failed");
                                                                >          // save the results so we can return them to the client
                                                                >          this->ddl_res = res;
                                                                >
                                                                >          yield {
                                                                >              return CR_QUERY_AGAIN(
                                                                >                  " INSERT INTO " + MetaData::Table::remoteQueryC
                                                                >                  "   (embedded_completion_id, completion_type) V
                                                                >                  "   (" + std::to_string(this->embedded_completi
                                                                >                  "    '"+TypeText<CompletionType>::toText(Comple
                                                                >                  "   );");
                                                                >          }
                                                                >
                                                                >          TEST_ErrPkt(res.success(), "failed issuing ddl completi
                                                                >
                                                                >          // execute the original query against the embedded data
                                                                >          // > this is a ddl query so do not put it into a transa
                                                                >          TEST_ErrPkt(nparams.ps.getEConn()->execute(nparams.orig
                                                                >                     "Failed to execute DDL query against embedde
                                                                >
                                                                >          TEST_ErrPkt(deltaOutputAfterQuery(nparams.ps.getEConn()
                                                                >                                            this->embedded_comple
                                                                >                     "deltaOuputAfterQuery failed for DDL");
                                                                >          yield return CR_RESULTS(this->ddl_res.get());
                                                                >      }
                                                                >
                                                                >      assert(false);
                                                                >  }
                                                                >
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/ddl_handler.hh Practical-Cryptdb/main/ddl_handler.hh
                                                                >  class DDLQueryExecutor : public AbstractQueryExecutor {
                                                                >
                                                                >
                                                                >
                                                                >      AssignOnce<ResType> ddl_res;
                                                                >      AssignOnce<uint64_t> embedded_completion_id;
                                                                >
                                                                >  public:
                                                                >      const std::string new_query;
                                                                >      DDLQueryExecutor(const LEX &new_lex,
                                                                >                       std::vector<std::unique_ptr<Delta> > &&del
                                                                >          : new_query(lexToQuery(new_lex)), deltas(std::move(delt
                                                                >      ~DDLQueryExecutor() {}
                                                                >      std::pair<ResultType, AbstractAnything *>
                                                                >          nextImpl(const ResType &res, const NextParams &nparams)
                                                                >
                                                                >  private:
                                                                >      const std::vector<std::unique_ptr<Delta> > deltas;
                                                                >      bool stales() const {return true;}
                                                                >      bool usesEmbedded() const {return true;}
                                                                >  };
                                                                >
    virtual LEX *transformLex(Analysis &analysis, LEX *lex,     |      virtual AbstractQueryExecutor *transformLex(Analysis &analy
                              const ProxyState &ps) const;      |          const;
    virtual LEX *rewriteAndUpdate(Analysis &a, LEX *lex,        |      virtual AbstractQueryExecutor *
                                  const ProxyState &ps) const = |          rewriteAndUpdate(Analysis &a, LEX *lex, const Preamble 
                                                                <
                                                                >
                                                                >
                                                                >  class CreateTableHandler : public DDLHandler {
                                                                >      //must rewrite the header here or we get pure virtual funct
                                                                >      virtual AbstractQueryExecutor *
                                                                >          rewriteAndUpdate(Analysis &a, LEX *lex, const Preamble 
                                                                >  };
                                                                >
                                                                >
                                                                >
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/dispatcher.cc Practical-Cryptdb/main/dispatcher.cc
                                                                >  /*
                                                                >  This file contains functions for SQLDispatcher and 
                                                                >  AlterDispatcher
                                                                >  */
                                                                >  //########################SQLDispatcher########################
// FIXME: Implement.                                            |
                                                                >
                                                                >  //#####################AlterDispatcher#########################
    return true;                                                |      // there must be a command for us to do
                                                                >      if (0 == lex->alter_info.flags) {
                                                                >          return false;
                                                                >      }
                                                                >
                                                                >      long long flags = lex->alter_info.flags;
                                                                >      for (const auto &it : handlers) {
                                                                >          flags -= lex->alter_info.flags & it.first;
                                                                >      }
                                                                >
                                                                >      return 0 == flags;
    for (auto it = handlers.begin(); it != handlers.end(); it++ |      for (const auto &it : handlers) {
        long long extract = lex->alter_info.flags & (*it).first |          const long long extract = lex->alter_info.flags & it.fi
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/dml_handler.cc Practical-Cryptdb/main/dml_handler.cc
                                                                >  #include <functional>
                                                                >
                                                                >  #include <main/metadata_tables.hh>
                                                                >  #include <util/onions.hh>
                                                                >  #include <util/yield.hpp>
                                                                >      //这里先做lookup, 找到类以后调用内部的结果, 试试
                                                                >      //对于普通的student操作, 最后调用的是ANON的typical_rewrite_
class InsertHandler : public DMLHandler {                       |
    virtual void gather(Analysis &a, LEX *const lex,            |  void InsertHandler::gather(Analysis &a, LEX *const lex) const {
                        const ProxyState &ps) const             |          //only select xxx etc?不是的!!!
    {                                                           <
                                                                >          //find plain for field and value rewrite?
    virtual LEX *rewrite(Analysis &a, LEX *const lex, const Pro |      AbstractQueryExecutor * InsertHandler::rewrite(Analysis &a,
        const                                                   |          const{
    {                                                           <
                                                                <
                                                                >          //from databasemeta to tablemeta.
                                                                >
                                                                >          //For insert, we can choose to specify field list or om
                                                                >                  //这下也就知道了field item是什么了
                                    implicit_it->fname);        |                                      implicit_it->getFieldName()
                                                                >              //开始处理many values
                                                                >                      //li指向了lex->many_values的迭代内容 
                                                                >                     
                                                                >                          assert(!!i == (fmVec.end() != fmVecIt))
                            assert(fmVec.end() == fmVecIt);     <
                        assert(fmVec.end() != fmVecIt);         |                          //获得values中的内容,并且通过fieldMeta
                                                                >                          //每个field都要进行洋葱的加密.
                                                                >
                                                                >          //对于普通的insert, 这部分的内容不会用到的.
            assert(rewrite_field_value_pairs(fd_it, val_it, a,  |              TEST_TextMessageError(
                                             &res_values));     |                  rewrite_field_value_pairs(fd_it, val_it, a, &re
                                                                >                                            &res_values),
                                                                >                  "rewrite_field_value_pairs failed in ON DUPLICA
                                                                >                  " UPDATE");
                                                                |          return new DMLQueryExecutor(*new_lex, a.rmeta);
        return new_lex;                                         <
};                                                              |
                                                                >
                                                                >
    virtual void gather(Analysis &a, LEX *lex, const ProxyState |      virtual void gather(Analysis &a, LEX *lex) const {
        const                                                   <
    {                                                           <
    virtual LEX *rewrite(Analysis &a, LEX *lex, const ProxyStat |      virtual AbstractQueryExecutor *rewrite(Analysis &a, LEX *le
        const                                                   <
        a.special_update =                                      |          // Special Update?
            false == rewrite_field_value_pairs(fd_it, val_it, a |          if (false == rewrite_field_value_pairs(fd_it, val_it, a
                                               &res_fields, &re |                                                 &res_fields, &re
                                                                >              const auto plain_table =
                                                                >                  lex->select_lex.top_join_list.head()->table_nam
                                                                >              const auto crypted_table =
                                                                >                  new_lex->select_lex.top_join_list.head()->table
                                                                >              AssignOnce<std::string> where_clause;
                                                                >              if (lex->select_lex.where) {
                                                                >                  std::ostringstream where_stream;
                                                                >                  where_stream << " " << *lex->select_lex.where <
                                                                >                  where_clause = where_stream.str();
                                                                >              } else {
                                                                >                  where_clause = " TRUE ";
                                                                >              }
                                                                >
                                                                >              return new SpecialUpdateExecutor(plain_table, crypt
                                                                >                                               where_clause.get()
                                                                >          }
                                                                >
        return new_lex;                                         |          return new DMLQueryExecutor(*new_lex, a.rmeta);
    virtual void gather(Analysis &a, LEX *const lex, const Prox |      virtual void gather(Analysis &a, LEX *const lex)
        const                                                   |          const {
    {                                                           <
    virtual LEX *rewrite(Analysis &a, LEX *lex, const ProxyStat |      virtual AbstractQueryExecutor *
                                                                >          rewrite(Analysis &a, LEX *lex)
                                                                >          //这个因该是delete from的来源!
        return new_lex;                                         |          return new DMLQueryExecutor(*new_lex, a.rmeta);
class SelectHandler : public DMLHandler {                       |  class MultiDeleteHandler : public DMLHandler {
    virtual void gather(Analysis &a, LEX *const lex, const Prox |      virtual void gather(Analysis &a, LEX *const lex)
        const                                                   |          const {
    {                                                           <
    virtual LEX *rewrite(Analysis &a, LEX *lex, const ProxyStat |      virtual AbstractQueryExecutor *
        const                                                   |          rewrite(Analysis &a, LEX *lex)
                                                                >          const {
                                                                >          LEX *const new_lex = copyWithTHD(lex);
                                                                >          // the multidelete looks like this
                                                                >          //  $ DELETE <LEX::auxiliary_...> FROM <LEX::query_tabl
                                                                >          // if query_tablez doesn't have an alias for a value it
                                                                >          // to rewrite the table name (and also put this rewritt
                                                                >          // in the alias); the auxlist must then also rewrite it
                                                                >          //
                                                                >          // if query_tablez does have an alias it will leave the
                                                                >          // and rewrite the real table name; the auxlist then ne
                                                                >          // leave it's value as _is_ because it's already the al
                                                                >          // well formed query)
                                                                >          //
                                                                >          // the auxlist doesn't ``correctly'' set the TABLE_LIST
                                                                >          // parameter; we ``fix'' that here
                                                                >          //
                                                                >          // the corner case is when a table is aliased as it's r
                                                                >          //  $ DELETE a FROM a AS A
                                                                >          // we resolve this by looking up the alias in Analysis
                                                                >          //
                                                                >          // our goal is to use aliases in the initial DELETE for
                                                                >          // clauses and WHERE clauses; while not using it in the
                                                                >          // clauses; the JOIN clause should print the full field
                                                                >          // (db.field.table) as well as the alias
                                                                >          //
                                                                >          // the problem is further complicated by a peculiarity 
                                                                >          // initial DELETE form; in most other clauses we can sa
                                                                >          // do db.alias.field but in the DELETE form we _must_ d
                                                                >          // alias.field.  therefore we have to tell the rewrite 
                                                                >          // for Item_field that it should ``inject'' the alias n
                                                                >          for (TABLE_LIST *tbl = lex->auxiliary_table_list.first;
                                                                >               tbl;
                                                                >               tbl = tbl->next_local) {
                                                                >
                                                                >              assert(false == tbl->is_alias);
                                                                >              // it's useful to do this style of alias check as w
                                                                >              // because it doesn't require the database name
                                                                >              if (strcmp(tbl->alias, tbl->table_name)) {
                                                                >                  tbl->is_alias = true;
                                                                >              } else {
                                                                >                  const std::string &db =
                                                                >                      std::string(tbl->db, tbl->db_length);
                                                                >                  TEST_DatabaseDiscrepancy(db, a.getDatabaseName(
                                                                >
                                                                >                  tbl->is_alias = a.isAlias(db, tbl->alias);
                                                                >              }
                                                                >          }
                                                                >          // rewrite the DELETE form
                                                                >          new_lex->auxiliary_table_list =
                                                                >              rewrite_table_list(lex->auxiliary_table_list, a);
                                                                >
                                                                >          // rewrite the ON/JOIN forms
                                                                >          TABLE_LIST *new_query_tables = NULL;
                                                                >          for (TABLE_LIST *tbl = lex->query_tables;
                                                                >               tbl;
                                                                >               tbl = tbl->next_local) {
                                                                >              // JOIN form
                                                                >              TABLE_LIST *const new_t = rewrite_table_list(tbl, a
                                                                >
                                                                >              // FIXME: look at rewrite_table_list and determine 
                                                                >              // can support
                                                                >              TEST_TextMessageError(NULL == tbl->nested_join,
                                                                >                                    "No nested joins in DELETE FR
                                                                >
                                                                >              // ON form
                                                                >              if (tbl->on_expr) {
                                                                >                  ScopedAssignment<bool>(&a.inject_alias, true,
                                                                >                      [&new_t, &tbl, &a] ()
                                                                >                          new_t->on_expr =
                                                                >                              ::rewrite(*tbl->on_expr, PLAIN_EncS
                                                                >                      });
                                                                >              }
                                                                >
                                                                >              // first iteration?
                                                                >              if (NULL == new_query_tables) {
                                                                >                  new_query_tables = new_t;
                                                                >              } else {
                                                                >                  new_query_tables->next_local = new_t;
                                                                >              }
                                                                >          }
                                                                >          new_lex->query_tables = new_query_tables;
                                                                >
                                                                >          set_select_lex(new_lex,
                                                                >                         rewrite_select_lex(new_lex->select_lex, 
                                                                >
                                                                >          return new DMLQueryExecutor(*new_lex, a.rmeta);
                                                                >      }
                                                                >  };
                                                                >
                                                                >  class SelectHandler : public DMLHandler {
                                                                >      virtual void gather(Analysis &a, LEX *const lex)
                                                                >          const{
                                                                >          //处理了选择域, 以及为having等field 设置了rewriteplain,
                                                                >          process_select_lex(lex->select_lex, a);
                                                                >      }
                                                                >
                                                                >      virtual AbstractQueryExecutor *
                                                                >          rewrite(Analysis &a, LEX *lex)
                                                                >          const{
                                                                >
                                                                >
        return new_lex;                                         |          return new DMLQueryExecutor(*new_lex, a.rmeta);
 LEX *DMLHandler::transformLex(Analysis &analysis, LEX *lex,    |  AbstractQueryExecutor *DMLHandler::
                               const ProxyState &ps) const      |  transformLex(Analysis &analysis, LEX *lex) const {
{                                                               |      this->gather(analysis, lex);
    this->gather(analysis, lex, ps);                            |      return this->rewrite(analysis, lex);
                                                                <
    return this->rewrite(analysis, lex, ps);                    <
    /*if (select_lex->join &&                                   <
        select_lex->join->conds &&                              <
        select_lex->where != select_lex->join->conds)           <
        analyze(select_lex->join->conds, reason(FULL_EncSet, "j <
                                                                <
                                                                >      //可以看到, 首先处理top_join_list, 是List<TABLE_LIST>类型. 
                                                                >      //内部分别用process_table_aliases(tll, a); process_table_jo
                                                                >      //如果不是jion式的语句, 就不用管了.其内部通过递归处理nested
    //select clause                                             |       //这里处理的是itemlist, 也就是List of columns and expressi
                                                                >       //expressions in the SELECT list.是List<Item>类型.
                                                                >      //select 也就是选择域
                                                                >      int numOfItem = 0;
                                                                >      //因该是对itemlist做内部转化以后在添加rewriteplain. 这里在
                                                                >      //这里处理了id 和 name.
                                                                |          numOfItem++;
                                                                |      //这里处理的是select_lex.where和select_lex.having, 通过Item
                                                                >      //rewriteplain. 然后再通过process_order, 对select_lex.group
                                                                >      //rewritePlain
                                                                >          assert(!!field_item == !!value_item);
            assert(!value_item);                                <
        assert(value_item != NULL);                             <
                                                                <
        const std::unique_ptr<RewritePlan> &rp =                |          Item *const new_item = rewrite(i, constr, a);
            constGetAssert(a.rewritePlans, &i);                 <
        const EncSet es = constr.intersect(rp->es_out);         <
        // FIXME: Add version that will take a second EncSet of <
        // we had available (ie, rp->es_out).                   <
        TEST_NoAvailableEncSet(es, i.type(), constr, rp->r.why, <
                            std::vector<std::shared_ptr<Rewrite <
        const OLK olk = es.chooseOne();                         <
                                                                <
        Item *const new_item = itemTypes.do_rewrite(i, olk, *rp <
                                                                |  //order by, group by, where, having.
    //  if (select_lex->join &&                                 <
    //     select_lex->join->conds &&                           <
    //    select_lex->where != select_lex->join->conds) {       <
    //cerr << "select_lex join conds " << select_lex->join->con <
    //rewrite(&select_lex->join->conds, a);                     <
    //}                                                         <
                                                                <
                          List<Item> *const res_values)         |                            List<Item> *const res_values) {
{                                                               <
                                                                >          assert(!!field_item == !!value_item);
            assert(NULL == value_item);                         <
        assert(NULL != value_item);                             <
            bool has_salt, const std::string &name)             |              bool has_salt, const std::string &name){
{                                                               <
                                                                >  //Item是当前需要加密的item, rp是gather阶段存入的RewritePlain,加
             List<Item> *newList)                               |               List<Item> *const newList) {
{                                                               <
                                                                >
        const auto cached_rewritten_i = a.item_cache.find(&fiel |          const auto &cached_rewritten_i = a.item_cache.find(&fie
                                                                >              //对于select中的选择域来说,这里对应的是rewrite_fiel
                                                                >      //和insert不同, select的时候, 只要一个洋葱, 选取一个进行改
        const std::string anon_table_name =                     |          TEST_TextMessageError(Item::Type::FIELD_ITEM == ir.get(
                                                                >              "a projection requires a salt and is not a field; c
                                                                >              " does not currently support such behavior");
                                                                >          const std::string &anon_table_name =
        const std::string anon_field_name = olk.get().key->getS |          const std::string &anon_field_name = olk.get().key->get
    st_select_lex *const new_select_lex =                       |      st_select_lex *const new_select_lex = rewrite_filters_lex(s
        rewrite_filters_lex(select_lex, a);                     <
                                                                >      int numOfItem=0;
                                                                >      //item的改写, 是写到newlist里面, 所以item本身不会有变化.
                                                                >
        LOG(cdb_v) << "rewrite_select_lex " << *item << " with  |          numOfItem++;
                   << item->name << std::endl;                  <
    // TODO(stephentu): investigate whether or not this is a me |  //    auto item_it_new =
                                                                >  //        RiboldMYSQL::constList_iterator<Item>(newList);
                                                                >  //    std::cout<<"rewrite#############" <<std::endl;
                                                                >  //    for(;;){
                                                                >  //        const Item *const item = item_it_new++;
                                                                >  //        if(!item) break;
                                                                >  //        std::cout<<"itemname: "<<item->name<<std::endl;
                                                                >  //     }
                                                                >
                                                                >  //    std::cout<<"num of item: "<<numOfItem<<std::endl;
            assert(a.addAlias(t->alias, t->db, t->table_name)); |              TEST_TextMessageError(
                                                                >                  a.addAlias(t->alias, t->db, t->table_name),
                                                                >                  "failed to add alias " + std::string(t->alias))
invalidates(const FieldMeta &fm, const EncSet & es)             |  invalidates(const FieldMeta &fm, const EncSet & es){
{                                                               |      for (const auto &om_it : fm.getChildren()) {
    for (auto om_it = fm.children.begin(); om_it != fm.children |          onion const o = om_it.first.getValue();
         om_it++) {                                             <
        onion const o = (*om_it).first.getValue();              <
            assert(equalsIgnoreCase(fm.fname, item_field_name)) |              assert(equalsIgnoreCase(fm.getFieldName(), item_fie
        const OLK olk = {pair.first, pair.second.first, &fm};   |          const OLK &olk = {pair.first, pair.second.first, &fm};
                                                                <
                    const std::string anon_table_name =         |                      const std::string &anon_table_name =
            TEST_TextMessageError(false,                        |              FAIL_TextMessageError("UNSUPPORTED or unrecognized"
                                  "UNSUPPORTED or UNRECOGNIZED" <
                                                                >  class SetHandler : public DMLHandler {
                                                                >      virtual void gather(Analysis &a, LEX *const lex) const
                                                                >      {
                                                                >      }
                                                                >
                                                                >      virtual AbstractQueryExecutor *rewrite(Analysis &a, LEX *le
                                                                >      {
                                                                >          #define DIRECTIVE_HANDLER(function)                    
                                                                >              std::bind((function), this, std::placeholders::_1, 
                                                                >                        std::placeholders::_2)
                                                                >          typedef std::function<AbstractQueryExecutor *(std::map<
                                                                >                                                                 
                                                                >                                     Analysis &a)>
                                                                >              DirectiveHandler;
                                                                >
                                                                >          static const std::map<std::string, DirectiveHandler> di
                                                                >              {{"show", DIRECTIVE_HANDLER(&SetHandler::handleShow
                                                                >               {"adjust", DIRECTIVE_HANDLER(&SetHandler::handleAd
                                                                >               {"sensitive",
                                                                >                DIRECTIVE_HANDLER(&SetHandler::handleSensitiveDir
                                                                >               {"killzone",
                                                                >                DIRECTIVE_HANDLER(&SetHandler::handleKillZoneDire
                                                                >
                                                                >          DirectiveHandler dhandler = nullptr;
                                                                >          std::map<std::string, std::string> var_pairs;
                                                                >          auto var_it =
                                                                >              List_iterator<set_var_base>(lex->var_list);
                                                                >          for (;;) {
                                                                >              const set_var_base *const v = var_it++;
                                                                >              if (!v) {
                                                                >                  break;
                                                                >              }
                                                                >
                                                                >              switch (v->varType()) {
                                                                >              case set_var_base::V_USER: {
                                                                >                  const set_var_user *const user_v =
                                                                >                      static_cast<const set_var_user *>(v);
                                                                >                  Item_func_set_user_var *const i =
                                                                >                      user_v->*rob<set_var_user, Item_func_set_us
                                                                >                                   &set_var_user::user_var_item>:
                                                                >                  const std::string &var_name = convert_lex_str(i
                                                                >                  const Item *const *const args =
                                                                >                      i->*rob<Item_func, Item **,
                                                                >                              &Item_func_set_user_var::args>::ptr
                                                                >                  assert(args && args[0]);
                                                                >                  // skip non string sets, ie
                                                                >                  //   SET @this = @@that
                                                                >                  if (Item::Type::STRING_ITEM != args[0]->type())
                                                                >                      continue;
                                                                >                  }
                                                                >
                                                                >                  std::string var_value = printItem(*args[0]);
                                                                >                  TEST_TextMessageError(var_value.length() > 2,
                                                                >                                        "this " + var_value + " i
                                                                >                                        " not what you meant");
                                                                >                  var_value = var_value.substr(1, var_value.lengt
                                                                >                  if (equalsIgnoreCase("cryptdb", var_name)) {
                                                                >                      //
                                                                >                      TEST_TextMessageError(nullptr == dhandler,
                                                                >                                            "only one directive p
                                                                >                      auto enc = directive_handlers.find(toLowerC
                                                                >                      TEST_Text(directive_handlers.end() != enc,
                                                                >                                "unsupported directive: " + var_v
                                                                >
                                                                >                      dhandler = enc->second;
                                                                >                      continue;
                                                                >                  }
                                                                >
                                                                >                  // using the same key twice is not permitted
                                                                >                  TEST_TextMessageError(var_pairs.end()
                                                                >                                          == var_pairs.find(var_n
                                                                >                                        "you double specified: `"
                                                                >                                        + var_name + "`");
                                                                >
                                                                >                  var_pairs[var_name] = var_value;
                                                                >              }
                                                                >              case set_var_base::V_SYSTEM: {
                                                                >                  // do not allow the client to put us into SQL_S
                                                                >                  // mode; else bad things will happen
                                                                >                  const set_var *const set_v =
                                                                >                      static_cast<const set_var *>(v);
                                                                >                  const sys_var *const sys_v = set_v->var;
                                                                >                  if (NULL == sys_v) {
                                                                >                      break;
                                                                >                  }
                                                                >
                                                                >                  const std::string &name = convert_lex_str(sys_v
                                                                >                  TEST_Text(false == equalsIgnoreCase("SQL_SAFE_U
                                                                >                            "cryptDB does not support SQL_SAFE_UP
                                                                >                  break;
                                                                >              }
                                                                >              case set_var_base::V_PASSWORD:
                                                                >              case set_var_base::V_COLLATION:
                                                                >                  break;
                                                                >              default:
                                                                >                  assert(false);
                                                                >              }
                                                                >          }
                                                                >
                                                                >          if (nullptr == dhandler) {
                                                                >              return new SimpleExecutor();
                                                                >          }
                                                                >
                                                                >          return dhandler(var_pairs, a);
                                                                >
                                                                >          #undef DIRECTIVE_HANDLER
                                                                >      }
                                                                >
                                                                >  private:
                                                                >      AbstractQueryExecutor *
                                                                >      handleAdjustDirective(std::map<std::string, std::string> &v
                                                                >                            Analysis &a) const
                                                                >      {
                                                                >          const ParameterCollection &params = collectParameters(v
                                                                >
                                                                >          for (const auto &it : params.onions) {
                                                                >              const OnionMeta &om = a.getOnionMeta(params.fm, it.
                                                                >              const SECLEVEL current_level = a.getOnionLevel(om);
                                                                >              if (it.second < current_level) {
                                                                >                  throw OnionAdjustExcept(params.tm, params.fm, i
                                                                >                                          it.second);
                                                                >              } else if (it.second > current_level) {
                                                                >                  FAIL_TextMessageError("it is not possible to ad
                                                                >                                        " only remove them");
                                                                >              }
                                                                >          }
                                                                >
                                                                >          return new NoOpExecutor();
                                                                >      }
                                                                >
                                                                >
                                                                >      AbstractQueryExecutor *
                                                                >      handleShowDirective(std::map<std::string, std::string> &var
                                                                >                          Analysis &a) const
                                                                >      {
                                                                >          return new ShowDirectiveExecutor(a.getSchema());
                                                                >      }
                                                                >
                                                                >      AbstractQueryExecutor *
                                                                >      handleSensitiveDirective(std::map<std::string, std::string>
                                                                >                               Analysis &a) const
                                                                >      {
                                                                >          assert(a.deltas.size() == 0);
                                                                >
                                                                >          const ParameterCollection &params = collectParameters(v
                                                                >
                                                                >          for (const auto &it : params.onions) {
                                                                >              OnionMeta &om = a.getOnionMeta(params.fm, it.first)
                                                                >              const SECLEVEL current_level = a.getOnionLevel(om);
                                                                >              if (it.second <= current_level) {
                                                                >                  om.setMinimumSecLevel(it.second);
                                                                >              } else {
                                                                >                  FAIL_TextMessageError("it is not possible to se
                                                                >                                        " above the current level
                                                                >              }
                                                                >              a.deltas.push_back(std::unique_ptr<Delta>(new Repla
                                                                >                                                                 
                                                                >          }
                                                                >
                                                                >          return new SensitiveDirectiveExecutor(std::move(a.delta
                                                                >      }
                                                                >
                                                                >      AbstractQueryExecutor *
                                                                >      handleKillZoneDirective(std::map<std::string, std::string> 
                                                                >                          Analysis &a) const
                                                                >      {
                                                                >          auto count = var_pairs.find(std::string("count"));
                                                                >          auto where = var_pairs.find(std::string("where"));
                                                                >          TEST_Text(var_pairs.end() != count
                                                                >                 && var_pairs.end() != where
                                                                >                 && var_pairs.size() == 2,
                                                                >                    "the killzone directive takes two parameters,
                                                                >                    " and 'where'");
                                                                >
                                                                >          KillZone::Where typed_where = typeWhere(where->second);
                                                                >          try {
                                                                >              const long long c = std::stoll(count->second.c_str(
                                                                >              if (c < 0) throw;
                                                                >
                                                                >              static_assert(sizeof(long long) <= sizeof(uint64_t)
                                                                >                            "longlong larger than uint64_t");
                                                                >              a.kill_zone.activate(static_cast<uint64_t>(c), type
                                                                >          } catch (...) {
                                                                >              FAIL_TextMessageError("'count' parameter must be no
                                                                >                                    " integer");
                                                                >          }
                                                                >
                                                                >          return new NoOpExecutor();
                                                                >      }
                                                                >
                                                                >      KillZone::Where
                                                                >      typeWhere(const std::string &untyped_where) const
                                                                >      {
                                                                >          if (equalsIgnoreCase("before", untyped_where)) {
                                                                >              return KillZone::Where::Before;
                                                                >          } else if (equalsIgnoreCase("after", untyped_where)) {
                                                                >              return KillZone::Where::After;
                                                                >          }
                                                                >
                                                                >          FAIL_TextMessageError("Unknown 'where' parameter,"
                                                                >                                " must be 'before' or 'after'");
                                                                >      }
                                                                >
                                                                >      struct ParameterCollection {
                                                                >          ParameterCollection(const Analysis &a,
                                                                >                              const std::string &database,
                                                                >                              const std::string &table,
                                                                >                              const std::string &field,
                                                                >                              const std::vector<std::pair<onion, 
                                                                >              : database(database), table(table), field(field), o
                                                                >                tm(a.getTableMeta(database, table)),
                                                                >                fm(a.getFieldMeta(tm, field)) {}
                                                                >          const std::string database;
                                                                >          const std::string table;
                                                                >          const std::string field;
                                                                >          const std::vector<std::pair<onion, SECLEVEL> > onions;
                                                                >
                                                                >          TableMeta &tm;
                                                                >          FieldMeta &fm;
                                                                >      };
                                                                >
                                                                >      // destructively modifies var_pairs by removing database, t
                                                                >      ParameterCollection
                                                                >      collectParameters(std::map<std::string, std::string> &var_p
                                                                >                        Analysis &a) const
                                                                >      {
                                                                >          std::function<std::string(std::string)> getAndDestroy(
                                                                >              [&var_pairs] (const std::string &key)
                                                                >          {
                                                                >              auto it = var_pairs.find(key);
                                                                >              TEST_TextMessageError(it != var_pairs.end(),
                                                                >                                    "must supply a " + key);
                                                                >              const std::string value = it->second;
                                                                >              var_pairs.erase(it);
                                                                >
                                                                >              return value;
                                                                >          });
                                                                >
                                                                >          const std::string &database = getAndDestroy("database")
                                                                >          const std::string &table    = getAndDestroy("table");
                                                                >          const std::string &field    = getAndDestroy("field");
                                                                >
                                                                >          // the remaining values are <onion>=<level> pairs
                                                                >          std::vector<std::pair<onion, SECLEVEL> > onions;
                                                                >          for (auto it = var_pairs.begin(); it != var_pairs.end()
                                                                >              const std::string &str_onion = it->first;
                                                                >              const std::string &str_level = it->second;
                                                                >
                                                                >              AssignOnce<onion> o;
                                                                >              AssignOnce<SECLEVEL> l;
                                                                >              try {
                                                                >                  o = TypeText<onion>::noCaseToType(str_onion);
                                                                >                  l = TypeText<SECLEVEL>::noCaseToType(str_level)
                                                                >              } catch (CryptDBError &e) {
                                                                >                  FAIL_TextMessageError("bad param; " + str_onion
                                                                >                                        str_level);
                                                                >              }
                                                                >
                                                                >              onions.push_back(std::make_pair(o.get(), l.get()));
                                                                >              var_pairs.erase(it++);
                                                                >          }
                                                                >
                                                                >          TEST_Text(0 == var_pairs.size(),
                                                                >                    "extraneous directive parameter, indicate a s
                                                                >                    " table and field; and then onion-seclevel pa
                                                                >          TEST_Text(onions.size() > 0,
                                                                >                    "you must specify at least one onion");
                                                                >
                                                                >          return ParameterCollection(a, database, table, field, o
                                                                >      }
                                                                >  };
                                                                >
                                                                >  class ShowTablesHandlers : public DMLHandler {
                                                                >      virtual void gather(Analysis &a, LEX *const lex) const
                                                                >      {
                                                                >
                                                                >      }
                                                                >
                                                                >      virtual AbstractQueryExecutor *rewrite(Analysis &a, LEX *le
                                                                >      {
                                                                >          return new ShowTablesExecutor();
                                                                >      }
                                                                >  };
                                                                >
                                                                >
                                                                >  //add show create table handler
                                                                >  class ShowCreateTableHandler: public DMLHandler{
                                                                >      virtual void gather(Analysis &a, LEX *const lex) const
                                                                >      {
                                                                >
                                                                >      }
                                                                >      virtual AbstractQueryExecutor *rewrite(Analysis &a, LEX *le
                                                                >      {
                                                                >
                                                                >          int elements = lex->select_lex.table_list.elements;
                                                                >          assert(elements==1);
                                                                >
                                                                >          TABLE_LIST *tbl = lex->select_lex.table_list.first;
                                                                >          std::string db(tbl->db);
                                                                >          std::string tbn(tbl->table_name);
                                                                >
                                                                >          TableMeta &tbm = a.getTableMeta(db,tbn);
                                                                >
                                                                >          //rewrite the table list here        
                                                                >          LEX *const new_lex = copyWithTHD(lex);
                                                                >          tbl =  rewrite_table_list(new_lex->select_lex.table_lis
                                                                >          new_lex->select_lex.table_list = *oneElemListWithTHD<TA
                                                                >
                                                                >          return new ShowCreateTableExecutor(*new_lex);
                                                                >      }
                                                                >  };
                                                                >
                                                                >
                                                                >
    SQLDispatcher *dispatcher = new SQLDispatcher();            |      SQLDispatcher *const dispatcher = new SQLDispatcher();
                                                                >      h = new MultiDeleteHandler;
                                                                >      dispatcher->addHandler(SQLCOM_DELETE_MULTI, h);
                                                                >
                                                                >      h = new SetHandler;
                                                                >      dispatcher->addHandler(SQLCOM_SET_OPTION, h);
                                                                >
                                                                >      h = new ShowTablesHandlers;
                                                                >      dispatcher->addHandler(SQLCOM_SHOW_TABLES, h);
                                                                >
                                                                >      //added
                                                                >      h = new ShowCreateTableHandler;
                                                                >      dispatcher->addHandler(SQLCOM_SHOW_CREATE,h);
                                                                >
                                                                >
                                                                >  }
                                                                >
                                                                >  std::pair<AbstractQueryExecutor::ResultType, AbstractAnything *
                                                                >  DMLQueryExecutor::
                                                                >  nextImpl(const ResType &res, const NextParams &nparams)
                                                                >  {
                                                                >      reenter(this->corot) {
                                                                >          yield return CR_QUERY_AGAIN(this->query);
                                                                >          //crosses init here www.cplusplus.com/forum/beginner/48
                                                                >          //errormessage += "DML query failed against remote data
                                                                >          TEST_ErrPkt(res.success(), this->query+"DML query faile
                                                                >          yield {
                                                                >              try {
                                                                >                  return CR_RESULTS(Rewriter::decryptResults(res,
                                                                >              } catch (...) {//catch中也有默认参数.
                                                                >                  FAIL_GenericPacketException("error decrypting d
                                                                >              }
                                                                >          }
                                                                >      }
                                                                >
                                                                >      assert(false);
                                                                >  }
                                                                >
                                                                >  // currently only supports queries that return QUERY_COME_AGAIN
                                                                >  // > this is an attempt to keep this function simple
                                                                >  static std::pair<std::string, ReturnMeta>
                                                                >  rewriteAndGetFirstQuery(const std::string &query, NextParams np
                                                                >  {
                                                                >      try {
                                                                >          const std::shared_ptr<const SchemaInfo> schema =
                                                                >              nparams.ps.getSchemaInfo();
                                                                >          QueryRewrite delete_rewrite =
                                                                >              Rewriter::rewrite(query, *schema.get(), nparams.def
                                                                >                                nparams.ps);
                                                                >
                                                                >          auto results =
                                                                >              delete_rewrite.executor->next(ResType(true, 0, 0), 
                                                                >          assert(AbstractQueryExecutor::ResultType::QUERY_COME_AG
                                                                >                 == results.first);
                                                                >
                                                                >          return std::make_pair(std::get<1>(results)->
                                                                >                                  extract<std::pair<bool, std::st
                                                                >                                delete_rewrite.rmeta);
                                                                >      } catch (const SchemaFailure &e) {
                                                                >          FAIL_GenericPacketException("failed to get schema info"
                                                                >      } catch (...) {
                                                                >          FAIL_GenericPacketException("error rewriting a single q
                                                                >      }
                                                                >  }
                                                                >
                                                                >  #define SPECIALIZED_SYNC(test)                               \
                                                                >      SYNC_IF_FALSE((test), nparams.ps.getEConn())
                                                                >
                                                                >  std::pair<AbstractQueryExecutor::ResultType, AbstractAnything *
                                                                >  SpecialUpdateExecutor::
                                                                >  nextImpl(const ResType &res, const NextParams &nparams)
                                                                >  {
                                                                >      // FIXME: implement and remove the CALL later on
                                                                >      /*
                                                                >      crStartBlock
                                                                >          const std::string &cond_trx =
                                                                >              "CALL " + MetaData::Table::conditionalTrx();
                                                                >          crYield(std::make_pair(true, cond_trx));
                                                                >      crEndBlock
                                                                >      */
                                                                >      reenter(this->corot) {
                                                                >          assert(res.success());
                                                                >
                                                                >          yield {
                                                                >              // Retrieve rows from database.
                                                                >              const std::string &select_q =
                                                                >                  " SELECT * FROM " + this->plain_table +
                                                                >                  " WHERE " + this->where_clause + ";";
                                                                >              // Should never cause an onion adjustment
                                                                >              const auto &rewritten_select_q =
                                                                >                  rewriteAndGetFirstQuery(select_q, nparams);
                                                                >              this->select_rmeta = rewritten_select_q.second;
                                                                >              return CR_QUERY_AGAIN(rewritten_select_q.first);
                                                                >          }
                                                                >          TEST_ErrPkt(res.success(),
                                                                >                      "initial select query in SpecialUpdate fail
                                                                >
                                                                >          try {
                                                                >              this->dec_res =
                                                                >                  Rewriter::decryptResults(res, this->select_rmet
                                                                >          } catch (...) {
                                                                >              TEST_ErrPkt(res.success(),
                                                                >                          "decrypting initial SELECT failed for S
                                                                >          }
                                                                >          assert(this->dec_res.get().success());
                                                                >          if (this->dec_res.get().rows.size() == 0) {
                                                                >              yield return CR_RESULTS(ResType(true, 0, 0));
                                                                >          }
                                                                >
                                                                >          yield {
                                                                >              const auto itemToNiceString =
                                                                >                  [&nparams] (const Item *const p_item)
                                                                >                  {
                                                                >                      const std::string &s = ItemToString(*p_item
                                                                >
                                                                >                      if (Item::Type::STRING_ITEM != p_item->type
                                                                >                          return s;
                                                                >                      }
                                                                >
                                                                >                      // escaping and quoting the string creates 
                                                                >                      // actually be used in an INSERT statement
                                                                >                      return "'" + escapeString(nparams.ps.getECo
                                                                >                  };
                                                                >
                                                                >              // We must take these items and convert them into q
                                                                >              // strings
                                                                >              //  > Item -> std::string -> escaped -> quoted
                                                                >              // then we join the results into a single comma sep
                                                                >              const auto pItemVectorToNiceValueList =
                                                                >                  [&itemToNiceString]
                                                                >                      (const std::vector<std::vector<Item *> > &v
                                                                >                  {
                                                                >                      std::vector<std::string> esses;
                                                                >                      for (auto row_it : vec) {
                                                                >                          std::vector<std::string> nice_values(ro
                                                                >                          std::transform(row_it.begin(), row_it.e
                                                                >                                         nice_values.begin(), ite
                                                                >                          esses.push_back("("+ vector_join(nice_v
                                                                >                      }
                                                                >
                                                                >                      return vector_join(esses, ",");
                                                                >                  };
                                                                >
                                                                >              const std::string &values_string =
                                                                >                  pItemVectorToNiceValueList(dec_res.get().rows);
                                                                >
                                                                >              // do the query on the embedded database inside of 
                                                                >              // so that we can prevent failure artifacts from po
                                                                >              // embedded database
                                                                >              TEST_ErrPkt(nparams.ps.getEConn()->execute("START T
                                                                >                          "failed to start transaction");
                                                                >
                                                                >              // turn on strict mode so we can determine if we ha
                                                                >              // > ie trying to insert 256 into a TINYINT UNSIGNE
                                                                >              SPECIALIZED_SYNC(strictMode(nparams.ps.getEConn().g
                                                                >
                                                                >              // Push the plaintext rows to the embedded database
                                                                >              const std::string &push_q =
                                                                >                  " INSERT INTO " + this->plain_table +
                                                                >                  " VALUES " + values_string + ";";
                                                                >              SPECIALIZED_SYNC(nparams.ps.getEConn()->execute(pus
                                                                >
                                                                >              // Run the original (unmodified) query on the data 
                                                                >              // database.
                                                                >              std::unique_ptr<DBResult> original_query_dbres;
                                                                >              SPECIALIZED_SYNC(nparams.ps.getEConn()->execute(
                                                                >                                  nparams.original_query, &origin
                                                                >              assert(original_query_dbres);
                                                                >              // HACK
                                                                >              this->original_query_dbres = original_query_dbres.r
                                                                >
                                                                >              // strict mode off
                                                                >              SPECIALIZED_SYNC(nparams.ps.getEConn()->execute(
                                                                >                                  "SET SESSION sql_mode = ''"));
                                                                >
                                                                >              // > Collect the results from the embedded database
                                                                >              // > This code relies on single threaded access to 
                                                                >              //   and on the fact that the database is cleaned u
                                                                >              //   every such operation.
                                                                >              std::unique_ptr<DBResult> dbres;
                                                                >              const std::string &select_results_q =
                                                                >                  " SELECT * FROM " + this->plain_table + ";";
                                                                >              SPECIALIZED_SYNC(nparams.ps.getEConn()->execute(sel
                                                                >                                                              &db
                                                                >              const ResType interim_res = ResType(dbres->unpack()
                                                                >              assert(interim_res.success());
                                                                >              this->escaped_output_values =
                                                                >                  pItemVectorToNiceValueList(interim_res.rows);
                                                                >
                                                                >              // Cleanup the embedded database.
                                                                >              const std::string &cleanup_q =
                                                                >                  "DELETE FROM " + this->plain_table + ";";
                                                                >              SPECIALIZED_SYNC(nparams.ps.getEConn()->execute(cle
                                                                >
                                                                >              SPECIALIZED_SYNC(nparams.ps.getEConn()->execute("CO
                                                                >
                                                                >              // This query is necessary to propagate a transacti
                                                                >              // INFORMATION_SCHEMA.
                                                                >              return CR_QUERY_AGAIN(
                                                                >                  "SELECT NULL FROM " + this->crypted_table + ";"
                                                                >          }
                                                                >
                                                                >          TEST_ErrPkt(res.success(),
                                                                >              "transaction propagation query failed in SpecialUpd
                                                                >
                                                                >          yield return CR_QUERY_AGAIN(
                                                                >              "CALL " + MetaData::Proc::activeTransactionP());
                                                                >          TEST_ErrPkt(res.success(),
                                                                >                      "failed to determine if we are in a transac
                                                                >          this->in_trx = handleActiveTransactionPResults(res);
                                                                >
                                                                >          if (false == this->in_trx.get()) {
                                                                >              yield return CR_QUERY_AGAIN("START TRANSACTION");
                                                                >              TEST_ErrPkt(res.success(),
                                                                >                          "failed to start transaction in Special
                                                                >          }
                                                                >
                                                                >          yield {
                                                                >              // DELETE the rows matching the WHERE clause from t
                                                                >              const std::string &delete_q =
                                                                >                  " DELETE FROM " + this->plain_table +
                                                                >                  " WHERE " + this->where_clause + ";";
                                                                >              const auto &rewritten_delete_q =
                                                                >                  rewriteAndGetFirstQuery(delete_q, nparams);
                                                                >              return CR_QUERY_AGAIN(rewritten_delete_q.first);
                                                                >          }
                                                                >          CR_ROLLBACK_AND_FAIL(res, "delete query failed in Speci
                                                                >
                                                                >          yield {
                                                                >              // > Add each row from the embedded database to the
                                                                >              const std::string &insert_q =
                                                                >                  " INSERT INTO " + this->plain_table +
                                                                >                  " VALUES " + this->escaped_output_values.get() 
                                                                >              const auto &rewritten_insert_q =
                                                                >                  rewriteAndGetFirstQuery(insert_q, nparams);
                                                                >              return CR_QUERY_AGAIN(rewritten_insert_q.first);
                                                                >          }
                                                                >          CR_ROLLBACK_AND_FAIL(res, "insert query failed in Speci
                                                                >
                                                                >          if (false == this->in_trx.get()) {
                                                                >              yield return CR_QUERY_AGAIN("COMMIT");
                                                                >              CR_ROLLBACK_AND_FAIL(res, "commit failed in Special
                                                                >          }
                                                                >
                                                                >          /*
                                                                >          crStartBlock
                                                                >              const std::string &cond_trx =
                                                                >                  "CALL " + MetaData::Table::conditionalCommit();
                                                                >              crYield(std::make_pair(true, cond_trx));
                                                                >          crEndBlock
                                                                >          */
                                                                >
                                                                >          return CR_RESULTS(this->original_query_dbres.get()->unp
                                                                >      }
                                                                >
                                                                >      assert(false);
                                                                >  }
                                                                >
                                                                >  std::pair<AbstractQueryExecutor::ResultType, AbstractAnything *
                                                                >  ShowDirectiveExecutor::
                                                                >  nextImpl(const ResType &res, const NextParams &nparams)
                                                                >  {
                                                                >      reenter(this->corot) {
                                                                >          yield {
                                                                >              TEST_ErrPkt(deleteAllShowDirectiveEntries(nparams.p
                                                                >                          "failed to initialize show directives t
                                                                >
                                                                >              // HACK hack HACK hackity hackhack
                                                                >              const auto &databases = this->schema.getChildren();
                                                                >              for (const auto &db_it : databases) {
                                                                >                  const std::string &db_name = db_it.first.getVal
                                                                >                  const auto &dm = db_it.second;
                                                                >                  const auto &tables = dm->getChildren();
                                                                >                  for (const auto &table_it : tables) {
                                                                >                      const std::string &table_name = table_it.fi
                                                                >                      const auto &tm = table_it.second;
                                                                >                      const auto &fields = tm->getChildren();
                                                                >                      for (const auto &field_it : fields) {
                                                                >                          const std::string &field_name =
                                                                >                              field_it.first.getValue();
                                                                >                          const auto &fm = field_it.second;
                                                                >                          const auto &onions = fm->getChildren();
                                                                >                          for (const auto &onion_it : onions) {
                                                                >                              const std::string &onion_name =
                                                                >                                TypeText<onion>::toText(onion_it.
                                                                >                              const auto &om = onion_it.second;
                                                                >
                                                                >                              // HACK: this behavior is not usual
                                                                >                              // Analysis to get state informatio
                                                                >                              const std::string &level =
                                                                >                                  TypeText<SECLEVEL>::toText(om->
                                                                >                              const bool b =
                                                                >                                  addShowDirectiveEntry(nparams.p
                                                                >                                                        db_name, 
                                                                >                                                        field_nam
                                                                >                                                        level);
                                                                >                              TEST_ErrPkt(true == b,
                                                                >                                          "failed producing direc
                                                                >                          }
                                                                >                      }
                                                                >                  }
                                                                >              }
                                                                >
                                                                >              std::unique_ptr<DBResult> db_res;
                                                                >              TEST_ErrPkt(getAllShowDirectiveEntries(nparams.ps.g
                                                                >                                                     &db_res),
                                                                >                          "failed retrieving directive results");
                                                                >              return CR_RESULTS(db_res->unpack());
                                                                >          }
                                                                >      }
                                                                >
                                                                >      assert(false);
                                                                >  }
                                                                >
                                                                >  bool ShowDirectiveExecutor::
                                                                >  deleteAllShowDirectiveEntries(const std::unique_ptr<Connect> &e
                                                                >  {
                                                                >      const std::string &query =
                                                                >          "DELETE FROM " + MetaData::Table::showDirective() + ";"
                                                                >      return e_conn->execute(query);
                                                                >  }
                                                                >
                                                                >  bool ShowDirectiveExecutor::
                                                                >  addShowDirectiveEntry(const std::unique_ptr<Connect> &e_conn,
                                                                >                        const std::string &database,
                                                                >                        const std::string &table,
                                                                >                        const std::string &field,
                                                                >                        const std::string &onion,
                                                                >                        const std::string &level)
                                                                >  {
                                                                >      const std::string &query =
                                                                >          "INSERT INTO " + MetaData::Table::showDirective() +
                                                                >          " (_database, _table, _field, _onion, _level) VALUES "
                                                                >          " ('" + database + "', '" + table + "',"
                                                                >          "  '" + field + "', '" + onion + "', '" + level + "')";
                                                                >
                                                                >      return e_conn->execute(query);
                                                                >  }
                                                                >
                                                                >  bool ShowDirectiveExecutor::
                                                                >  getAllShowDirectiveEntries(const std::unique_ptr<Connect> &e_co
                                                                >                             std::unique_ptr<DBResult> *db_res)
                                                                >  {
                                                                >      assert(db_res);
                                                                >      const std::string &query =
                                                                >          "SELECT * FROM " + MetaData::Table::showDirective() + "
                                                                >      return e_conn->execute(query, db_res);
                                                                >  }
                                                                >
                                                                >  std::pair<AbstractQueryExecutor::ResultType, AbstractAnything *
                                                                >  SensitiveDirectiveExecutor::
                                                                >  nextImpl(const ResType &res, const NextParams &nparams)
                                                                >  {
                                                                >      reenter(this->corot) {
                                                                >          yield {
                                                                >              TEST_ErrPkt(nparams.ps.getEConn()->execute("START T
                                                                >                        "failed to start transaction for sensitiv
                                                                >
                                                                >              SPECIALIZED_SYNC(writeDeltas(nparams.ps.getEConn(),
                                                                >                                           Delta::BLEEDING_TABLE)
                                                                >
                                                                >              SPECIALIZED_SYNC(writeDeltas(nparams.ps.getEConn(),
                                                                >                                           Delta::REGULAR_TABLE))
                                                                >
                                                                >              SPECIALIZED_SYNC(nparams.ps.getEConn()->execute("CO
                                                                >
                                                                >              return CR_QUERY_RESULTS("DO 0;");
                                                                >          }
                                                                >      }
                                                                >
                                                                >      assert(false);
                                                                >  }
                                                                >
                                                                >  #undef SPECIALIZED_SYNC
                                                                >
                                                                >  std::pair<AbstractQueryExecutor::ResultType, AbstractAnything *
                                                                >  ShowTablesExecutor::
                                                                >  nextImpl(const ResType &res, const NextParams &nparams)
                                                                >  {
                                                                >      reenter(this->corot) {
                                                                >          yield return CR_QUERY_AGAIN(nparams.original_query);
                                                                >          TEST_ErrPkt(res.success(), "show tables failed");
                                                                >
                                                                >          yield {
                                                                >              const std::shared_ptr<const SchemaInfo> &schema =
                                                                >                  nparams.ps.getSchemaInfo();
                                                                >              const DatabaseMeta *const dm =
                                                                >                  schema->getChild(IdentityMetaKey(nparams.defaul
                                                                >              TEST_ErrPkt(dm, "failed to find the database '"
                                                                >                              + nparams.default_db + "'");
                                                                >              std::vector<std::vector<Item *> > new_rows;
                                                                >
                                                                >              for (const auto &it : res.rows) {
                                                                >                  assert(1 == it.size());
                                                                >                  for (const auto &table : dm->getChildren()) {  
                                                                >                      assert(table.second);
                                                                >                      if (table.second->getAnonTableName()
                                                                >                          == ItemToString(*it.front())) {
                                                                >
                                                                >                          const IdentityMetaKey &plain_table_name
                                                                >                              = dm->getKey(*table.second.get());
                                                                >                          new_rows.push_back(std::vector<Item *>
                                                                >                              {make_item_string(plain_table_name.
                                                                >                      }
                                                                >                  }
                                                                >              }
                                                                >              return CR_RESULTS(ResType(res, new_rows));
                                                                >          }
                                                                >      }
                                                                >      assert(false);
                                                                >  }
                                                                >
                                                                >  std::pair<AbstractQueryExecutor::ResultType, AbstractAnything *
                                                                >  ShowCreateTableExecutor::
                                                                >  nextImpl(const ResType &res, const NextParams &nparams){
                                                                >      //return CR_QUERY_AGAIN(nparams.original_query);
                                                                >      reenter(this->corot) {
                                                                >          yield return CR_QUERY_AGAIN(this->query);
                                                                >          TEST_ErrPkt(res.success(), "show create table tables fa
                                                                >          yield {
                                                                >              const std::shared_ptr<const SchemaInfo> &schema =
                                                                >                  nparams.ps.getSchemaInfo();
                                                                >              const DatabaseMeta *const dm =
                                                                >                  schema->getChild(IdentityMetaKey(nparams.defaul
                                                                >              TEST_ErrPkt(dm, "failed to find the database '"
                                                                >                              + nparams.default_db + "'");
                                                                >              std::vector<std::vector<Item *> > new_rows;
                                                                >              return CR_RESULTS(ResType(res, new_rows));
                                                                >          }
                                                                >      }
                                                                >      assert(false);
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/dml_handler.hh Practical-Cryptdb/main/dml_handler.hh
                                                                >  class DMLQueryExecutor : public AbstractQueryExecutor {
                                                                >  public:
                                                                >      DMLQueryExecutor(const LEX &lex, const ReturnMeta &rmeta)
                                                                >          : query(lexToQuery(lex)), rmeta(rmeta) {}
                                                                >      ~DMLQueryExecutor() {}
                                                                >      std::pair<ResultType, AbstractAnything *>
                                                                >          nextImpl(const ResType &res, const NextParams &nparams)
                                                                >      std::string getQuery(){return query;}
                                                                >  private:
                                                                >      const std::string query;
                                                                >      const ReturnMeta rmeta;
                                                                >  };
                                                                >
                                                                >  class SpecialUpdateExecutor : public AbstractQueryExecutor {
                                                                >      const std::string original_query;
                                                                >      const std::string plain_table;
                                                                >      const std::string crypted_table;
                                                                >      const std::string where_clause;
                                                                >
                                                                >      // coroutine state
                                                                >      AssignOnce<ResType> dec_res;
                                                                >      AssignOnce<DBResult *> original_query_dbres;
                                                                >      AssignOnce<std::string> escaped_output_values;
                                                                >      AssignOnce<ReturnMeta> select_rmeta;
                                                                >      AssignOnce<bool> in_trx;
                                                                >
                                                                >  public:
                                                                >      SpecialUpdateExecutor(const std::string &plain_table,
                                                                >                            const std::string &crypted_table,
                                                                >                            const std::string &where_clause)
                                                                >          : plain_table(plain_table), crypted_table(crypted_table
                                                                >            where_clause(where_clause) {}
                                                                >      ~SpecialUpdateExecutor() {}
                                                                >      std::pair<ResultType, AbstractAnything *>
                                                                >          nextImpl(const ResType &res, const NextParams &nparams)
                                                                >
                                                                >  private:
                                                                >      bool usesEmbedded() const {return true;}
                                                                >  };
                                                                >
                                                                >  class ShowDirectiveExecutor : public AbstractQueryExecutor {
                                                                >      const SchemaInfo &schema;
                                                                >
                                                                >  public:
                                                                >      ShowDirectiveExecutor(const SchemaInfo &schema)
                                                                >          : schema(schema) {}
                                                                >      ~ShowDirectiveExecutor() {}
                                                                >
                                                                >      std::pair<ResultType, AbstractAnything *>
                                                                >          nextImpl(const ResType &res, const NextParams &nparams)
                                                                >
                                                                >  private:
                                                                >      bool usesEmbedded() const {return true;}
                                                                >
                                                                >      static bool
                                                                >      deleteAllShowDirectiveEntries(const std::unique_ptr<Connect
                                                                >
                                                                >      static bool
                                                                >      addShowDirectiveEntry(const std::unique_ptr<Connect> &e_con
                                                                >                            const std::string &database,
                                                                >                            const std::string &table,
                                                                >                            const std::string &field,
                                                                >                            const std::string &onion,
                                                                >                            const std::string &level);
                                                                >
                                                                >      static bool
                                                                >      getAllShowDirectiveEntries(const std::unique_ptr<Connect> &
                                                                >                                 std::unique_ptr<DBResult> *db_re
                                                                >  };
                                                                >
                                                                >  class SensitiveDirectiveExecutor : public AbstractQueryExecutor
                                                                >      const std::vector<std::unique_ptr<Delta> > deltas;
                                                                >
                                                                >  public:
                                                                >      SensitiveDirectiveExecutor(std::vector<std::unique_ptr<Delt
                                                                >          : deltas(std::move(deltas)) {}
                                                                >      ~SensitiveDirectiveExecutor() {}
                                                                >
                                                                >      std::pair<ResultType, AbstractAnything *>
                                                                >          nextImpl(const ResType &res, const NextParams &nparams)
                                                                >
                                                                >  private:
                                                                >      bool stales() const {return true;}
                                                                >      bool usesEmbedded() const {return true;}
                                                                >  };
                                                                >
                                                                >  class ShowTablesExecutor : public AbstractQueryExecutor {
                                                                >      const std::vector<std::unique_ptr<Delta> > deltas;
                                                                >      std::string query;
                                                                >  public:
                                                                >      ShowTablesExecutor(){}
                                                                >      ~ShowTablesExecutor() {}
                                                                >
                                                                >      std::pair<ResultType, AbstractAnything *>
                                                                >          nextImpl(const ResType &res, const NextParams &nparams)
                                                                >
                                                                >  };
                                                                >
                                                                >
                                                                >  //added
                                                                >  class ShowCreateTableExecutor: public AbstractQueryExecutor{
                                                                >      std::string query;
                                                                >  public:
                                                                >      ShowCreateTableExecutor(const LEX &lex):query(lexToQuery(le
                                                                >      ~ShowCreateTableExecutor(){}
                                                                >
                                                                >      std::pair<ResultType, AbstractAnything *>
                                                                >          nextImpl(const ResType &res, const NextParams &nparams)
                                                                >  };
                                                                >
                                                                >
                                                                >
    virtual LEX *transformLex(Analysis &a, LEX *lex,            |      virtual AbstractQueryExecutor *
                               const ProxyState &ps) const;     |          transformLex(Analysis &a, LEX *lex) const;
    virtual void gather(Analysis &a, LEX *lex, const ProxyState |      virtual void gather(Analysis &a, LEX *lex) const = 0;
        const = 0;                                              |      virtual AbstractQueryExecutor * rewrite(Analysis &a, LEX *l
    virtual LEX *rewrite(Analysis &a, LEX *lex, const ProxyStat <
        const = 0;                                              <
                                                                >
                                                                >  class InsertHandler : public DMLHandler {
                                                                >      virtual void gather(Analysis &a, LEX *const lex)const;
                                                                >      virtual AbstractQueryExecutor *rewrite(Analysis &a, LEX *co
                                                                >  };
                                                                >
                                                                >
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/error.cc Practical-Cryptdb/main/error.cc
std::string                                                     <
SynchronizationException::to_string() const                     <
{                                                               <
    return "** Synchronization Failure **\n"                    <
           + error.to_string();                                 <
}                                                               <
                                                                <
std::ostream &operator<<(std::ostream &out,                     <
                         const SynchronizationException &error) <
{                                                               <
    out << error.to_string();                                   <
    return out;                                                 <
}                                                               <
                                                                <
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/error.hh Practical-Cryptdb/main/error.hh
                                                                >  #include <cassert>
// Do not derive this from AbstractException; their handling is |  class ErrorPacketException {
// divergent and we don't want to miss cases in catch graphs.   |      const std::string file_name;
class SynchronizationException {                                |      const uint64_t line_number;
public:                                                         |      const std::string msg;
    SynchronizationException(const std::string &file_name,      |      const unsigned int error_code;
                             unsigned long line_number,         |      const std::string sql_state;
                             const std::string &details)        |
        : error(TextMessageError(file_name, line_number, detail |  public:
    ~SynchronizationException() {}                              |      ErrorPacketException(const std::string &file_name, uint64_t
                                                                |                           const std::string &msg, unsigned int e
    std::string to_string() const;                              |                           const std::string &sql_state)
                                                                |          : file_name(file_name), line_number(line_number), msg(m
private:                                                        |            error_code(error_code), sql_state(sql_state)
    const TextMessageError error;                               |      {
};                                                              |          assert(sql_state.length() == 5);
                                                                |      }
std::ostream &operator<<(std::ostream &out,                     |
                         const SynchronizationException &error) |      std::string getMessage() const
                                                                |      {
                                                                >          return "(" + file_name + ", " + std::to_string(line_num
                                                                >                 + ")\n" + msg + "\n";
                                                                >      }
                                                                >
                                                                >      unsigned int getErrorCode() const {return error_code;}
                                                                >      std::string getSQLState() const {return sql_state;}
                                                                >  };
                                                                >
                                                                >  #define TEST_GenericPacketException(test, msg)                 
                                                                >  {                                                              
                                                                >      if (false == (test)) {                                     
                                                                >          throw ErrorPacketException(__FILE__, __LINE__, (msg),  
                                                                >                                     0xfff, "fail1");            
                                                                >      }                                                          
                                                                >  }
                                                                >
                                                                >  #define FAIL_GenericPacketException(msg)                       
                                                                >      TEST_GenericPacketException(false, msg)                    
                                                                >
                                                                >  #define TEST_ErrPkt(test, msg)                                 
                                                                >      TEST_GenericPacketException((test), (msg))
                                                                >
                                                                >  class SchemaFailure : public AbstractException {
                                                                >  public:
                                                                >      SchemaFailure(const std::string &file_name, int line_number
                                                                >          : AbstractException(file_name, line_number) {}
                                                                >      std::string to_string() const {return "schema failure";}
                                                                >  };
                                                                >
                                                                >  #define TEST_SchemaFailure(test)                    \
                                                                >  {                                                   \
                                                                >      if (!(test)) {                                  \
                                                                >          throw SchemaFailure(__FILE__, __LINE__);    \
                                                                >      }                                               \
                                                                >  }
                                                                >
                                                                >  class KillZoneFailure : public AbstractException {
                                                                >  public:
                                                                >      KillZoneFailure(const std::string &file_name, int line_numb
                                                                >          : AbstractException(file_name, line_number) {}
                                                                >      std::string to_string() const {return "kill zone failure";}
                                                                >  };
                                                                >
                                                                >  #define TEST_KillZoneFailure(test)                  \
                                                                >  {                                                   \
                                                                >      if (!(test)) {                                  \
                                                                >          throw KillZoneFailure(__FILE__, __LINE__);  \
                                                                >      }                                               \
                                                                >  }
Only in Practical-Cryptdb/main: load_and_store.cc
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/macro_util.hh Practical-Cryptdb/main/macro_util.hh
#define RETURN_FALSE_IF_FALSE(status)       \                   |  #define TYPENAME(value)                                        
{                                           \                   |      std::string typeName() const {return (value);}             
    if (!(status)) {                        \                   |      static std::string instanceTypeName() {return (value);}
        return false;                       \                   |
    }                                       \                   <
}                                                               <
#define RFIF RETURN_FALSE_IF_FALSE                              |  #define RETURN_NULL_IF_NULL(p)              \
                                                                >      (p);                                    \
                                                                >      if (!(p)) {                             \
                                                                >          return NULL;                        \
                                                                >      }
// FIXME: 'assert' is incorrect handling.                       <
#define SYNC_IF_FALSE(status, conn)                     \       <
{                                                       \       <
    if (!(status)) {                                    \       <
        assert((conn)->execute("ROLLBACK;"));           \       <
        TEST_Sync(status, "query failed");              \       <
    }                                                   \       <
}                                                               <
                                                                <
                                                                >  #define TEST_Text TEST_TextMessageError
                                                                >
inline void                                                     <
testSync(const std::string &file_name, unsigned int line_number <
         bool test, const std::string &identifier_name)         <
{                                                               <
    if (false == test) {                                        <
        throw SynchronizationException(file_name, line_number,  <
                                       identifier_name);        <
    }                                                           <
}                                                               <
                                                                |  #define SYNC_IF_FALSE(status, conn)                     \
#define TEST_Sync(test, identifier_name)                        <
    testSync(__FILE__, __LINE__, (test), (identifier_name));    |      const auto &s = (status);                            \
                                                                >      if (!s) {                                           \
                                                                >          assert((conn)->execute("ROLLBACK;"));           \
                                                                >          TEST_ErrPkt(s, "query failed");                 \
                                                                >      }                                                   \
#define FAIL_Sync(identifier_name)                              |  #define CR_ROLLBACK_AND_FAIL(res, msg)                         
    testSync(__FILE__, __LINE__, false, (identifier_name));     |      if (false == res.success()) {                              
                                                                >          yield return CR_QUERY_AGAIN("ROLLBACK");               
                                                                >                                                                 
                                                                >          assert(res.success());                                 
                                                                >          FAIL_GenericPacketException((msg));                    
                                                                >      }                                                          
                                                                >  #define ROLLBACK_ERROR_PACKET                                  
                                                                >  {                                                              
                                                                >      throw ErrorPacketException(__FILE__, __LINE__, "proxy did r
                                                                >                                 1213, "40001");                 
                                                                >  }
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/Makefrag Practical-Cryptdb/main/Makefrag
                rewrite_field.cc dispatcher.cc dml_handler.cc \ |                  rewrite_field.cc dispatcher.cc sql_handler.cc d
                error.cc stored_procedures.cc rewrite_main.cc   |                  error.cc stored_procedures.cc rewrite_ds.cc rew
                                                                >
                                                                >  CRYPTDB_PROGS:= cdb_test load_and_store test_layer test_schema 
CRYPTDB_PROGS:= cdb_test                                        <
        $(CXX) -shared -o $@ $(CRYPTDB_OBJS) $(LDFLAGS) $(LDRPA |          $(CXX) -shared -g -o $@ $(CRYPTDB_OBJS) $(LDFLAGS) $(LD
install: install_main                                           <
.PHONY: install_main                                            |
install_main: $(OBJDIR)/libcryptdb.so                           |  #install: install_main
        install -m 644 $(OBJDIR)/libcryptdb.so /usr/lib         |
                                                                >  #.PHONY: install_main
                                                                >  #install_main: $(OBJDIR)/libcryptdb.so
                                                                >  #       install -m 644 $(OBJDIR)/libcryptdb.so /usr/lib
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/metadata_tables.cc Practical-Cryptdb/main/metadata_tables.cc
                                                                |  //这个文件主要就是本地的表的名字维护以及初始化工作.
MetaData::Table::remoteQueryCompletion()                        |  MetaData::Table::showDirective()
    return DB::remoteDB() + "." + Internal::getPrefix() +       |      return DB::embeddedDB() + "." + Internal::getPrefix() +
           "remoteQueryCompletion";                             |             "showDirective";
}                                                               <
                                                                <
std::string                                                     <
MetaData::Proc::currentTransactionID()                          <
{                                                               <
    return DB::remoteDB() + "." + Internal::getPrefix() +       <
           "currentTransactionID";                              <
MetaData::Proc::homAdditionTransaction()                        |  MetaData::Table::remoteQueryCompletion()
           "homAdditionTransaction";                            |             "remoteQueryCompletion";
MetaData::Proc::adjustOnion()                                   |  MetaData::Proc::activeTransactionP()
    return DB::remoteDB() + "." + Internal::getPrefix() + "adju |      return DB::remoteDB() + "." + Internal::getPrefix() + "acti
                                                                >          //return true;
                                                                >      {
                                                                >          const std::string len(std::to_string(STORED_QUERY_LENGT
        "   (begin BOOLEAN NOT NULL,"                           |              "   (complete BOOLEAN NOT NULL,"
        "    complete BOOLEAN NOT NULL,"                        |              "    original_query VARCHAR(" + len + ") NOT NULL,"
        "    original_query VARCHAR(500) NOT NULL,"             |              "    rewritten_query VARCHAR(" + len + ") NOT NULL,
                                                                >      }
                                                                >      const std::string create_show_directive =
                                                                >          " CREATE TABLE IF NOT EXISTS " + Table::showDirective()
                                                                >          "   (_database VARCHAR(500) NOT NULL,"
                                                                >          "    _table VARCHAR(500) NOT NULL,"
                                                                >          "    _field VARCHAR(500) NOT NULL,"
                                                                >          "    _onion VARCHAR(500) NOT NULL,"
                                                                >          "    _level VARCHAR(500) NOT NULL,"
                                                                >          "    id SERIAL PRIMARY KEY)"
                                                                >          " ENGINE=InnoDB;";
                                                                >      RETURN_FALSE_IF_FALSE(e_conn->execute(create_show_directive
                                                                >
        "   (begin BOOLEAN NOT NULL,"                           |          "   (embedded_completion_id INTEGER NOT NULL,"
        "    complete BOOLEAN NOT NULL,"                        |          "    completion_type VARCHAR(100) NOT NULL,"
        "    embedded_completion_id INTEGER NOT NULL,"          <
        "    reissue BOOLEAN NOT NULL,"                         <
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/metadata_tables.hh Practical-Cryptdb/main/metadata_tables.hh
                                                                >  //这个在embedded的表中也是定义好的query最大的长度, 在程序中检查
                                                                >  #define STORED_QUERY_LENGTH 10000
                                                                >
                                                                >          std::string showDirective();
        std::string currentTransactionID();                     |          std::string activeTransactionP();
        std::string homAdditionTransaction();                   <
        std::string adjustOnion();                              <
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/rewrite_const.cc Practical-Cryptdb/main/rewrite_const.cc
                                                                >
// class/object names we don't care to know the name of         |  /* class/object names we don't care to know the name of */
// encrypts a constant item based on the information in a       |  // encrypts a constant item based on the information in Analysi
// FIXME: @i should be const ref.                               <
encrypt_item(const Item &i, const OLK &olk, Analysis &a)        |  encrypt_item(const Item &i, const OLK &olk, Analysis &a) {
{                                                               <
    LOG(cdb_v) << fm->fname << " " << fm->children.size();      |      LOG(cdb_v) << fm->getFieldName() << " " << fm->getChildren(
                                                                >  static class ANON : public CItemSubtypeIT<Item_float,
                                                                >                                            Item::Type::REAL_ITEM
                                                                >      virtual RewritePlan *
                                                                >      do_gather_type(const Item_float &i, Analysis &a) const
                                                                >      {
                                                                >          LOG(cdb_v) << " Float item do_gather " << i << std::end
                                                                >          const std::string why = "is a float constant";
                                                                >          reason rsn(PLAIN_EncSet, why, i);
                                                                >          return new RewritePlan(PLAIN_EncSet, rsn);
                                                                >      }
                                                                >
                                                                >      virtual Item *
                                                                >      do_rewrite_type(const Item_float &i, const OLK &constr,
                                                                >                      const RewritePlan &rp, Analysis &a) const
                                                                >      {
                                                                >          LOG(cdb_v) << "do_rewrite_type Float item " << i << std
                                                                >          return encrypt_item(i, constr, a);
                                                                >      }
                                                                >
                                                                >      virtual void
                                                                >      do_rewrite_insert_type(const Item_float &i, const FieldMeta
                                                                >                             Analysis &a, std::vector<Item *> *l)
                                                                >      {
                                                                >          typical_rewrite_insert_type(i, fm, a, l);
                                                                >      }
                                                                >  } ANON;
                                                                >
                                                                >
/*        double n = i->val_real();                             <
        char buf[sizeof(double) * 2];                           <
        sprintf(buf, "%x", (unsigned int)n);                    <
        // TODO(stephentu): Do some actual encryption of the do <
        return new Item_hex_string(buf, sizeof(buf));*/         <
Only in Practical-Cryptdb/main: rewrite_ds.cc
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/rewrite_ds.hh Practical-Cryptdb/main/rewrite_ds.hh
                                                                >  #include <parser/sql_utils.hh>
        : encset(es), why(why), item(item) {}                   |          : encset(es), why(why), string_item(printItemToString(i
    const Item &item;                                           |      const std::string string_item;
    reason getReason() const {return r;}                        |      virtual ~RewritePlan() {}
                                                                >      reason getReason() const {
                                                                >          return r;
                                                                >      }
                                                                >  class RewritePlanWithChildren : public RewritePlan {
                                                                >  public:
                                                                >      std::vector<std::shared_ptr<RewritePlan> > childr_rp;
                                                                >
                                                                >      RewritePlanWithChildren(const EncSet &es_out, const reason 
                                                                >                              const std::vector<std::shared_ptr<R
                                                                >                                  &childr_rp)
                                                                >          : RewritePlan(es_out, r), childr_rp(childr_rp) {}
                                                                >  };
                                                                >
                                                                >      ~RewritePlanOneOLK() {}
                                                                >      ~RewritePlanPerChildOLK() {}
                                                                >      ~RewritePlanWithAnalysis();
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/rewrite_field.cc Practical-Cryptdb/main/rewrite_field.cc
// gives names to classes and objects we don't care to know the |  /*gives names to classes and objects we don't care to know the 
                                                                <
                     Analysis &a)                               |                       Analysis &a) {
{                                                               <
                                                                >  //对于select的选择域, 由于是FIELD_ITEM类型, 会使用到这个类的.
        LOG(cdb_v) << "FIELD_ITEM do_gather " << i << std::endl <
                                                                <
                                                                <
                                                                >      //select的选择域rewrite的时候会用到, 从全局的rewrite调用.
        LOG(cdb_v) << "do_rewrite_type FIELD_ITEM " << i << std <
                                                                <
                                                                >
                                                                >          bool is_alias;
            a.getAnonTableName(db_name, plain_table_name);      |              a.getAnonTableName(db_name, plain_table_name, &is_a
                                                                >
                                                                >          // HACK: to get aliases to work in DELETE FROM statemen
                                                                >          if (a.inject_alias && is_alias) {
                                                                >              res->db_name = NULL;
                                                                >          }
                                                                >
        // where there query is using the VALUES(...) function. |          // where the query is using the VALUES(...) function.
/*                                                              <
    static OLK                                                  <
    chooseProj(FieldMeta * fm)                                  <
    {                                                           <
        SECLEVEL l;                                             <
        if (contains_get(fm->encdesc.olm, oDET, l)) {           <
            return OLK(oDET, l, fm);                            <
        }                                                       <
        if (contains_get(fm->encdesc.olm, oOPE, l)) {           <
            return OLK(oOPE, l, fm);                            <
        }                                                       <
        if (contains_get(fm->encdesc.olm, oAGG, l)) {           <
            return OLK(oAGG, l, fm);                            <
        }                                                       <
        assert_s(false, "field " + fm->fname + " does not have  <
        return OLK();                                           <
    }                                                           <
*/                                                              <
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/rewrite_func.cc Practical-Cryptdb/main/rewrite_func.cc
                                                                >  #define PLAIN_FUNCTION(type, name)                             
                                                                >  namespace {                                                    
                                                                >      extern const char __str_name_##name[] = #name;             
                                                                >      static class ANON : public CItemSubtypeFN<type, __str_name_
                                                                >          virtual RewritePlan *                                  
                                                                >          do_gather_type(const type &i, Analysis &a) const       
                                                                >          {                                                      
                                                                >              const std::string &why = #name;                    
                                                                >              return allPlainIterateGather(i, why, a);           
                                                                >          }                                                      
                                                                >                                                                 
                                                                >          virtual Item *                                         
                                                                >          do_rewrite_type(const type &i, const OLK &constr,      
                                                                >                          const RewritePlan &rp, Analysis &a) con
                                                                >          {                                                      
                                                                >              return rewrite_args_FN(i, constr,                  
                                                                >                                     static_cast<const RewritePla
                                                                >                                     a);                         
                                                                >          }                                                      
                                                                >      } ANON;                                                    
                                                                >  };
                                                                >
    /*                                                          <
    Item *i0 = do_optimize_const_item(i, a);                    <
    if (i0 == i) {                                              <
        // no optimizations done at top level                   <
        // try children                                         <
        Item **args = i->arguments();                           <
        for (uint x = 0; x < i->argument_count(); x++) {        <
            optimize(&args[x], a);                              <
        }                                                       <
        return i;                                               <
    } else {                                                    <
        return i0;                                              <
    }*/                                                         <
                                                                >  static RewritePlan *
                                                                >  friendlyGather(Analysis &a, const Item_func &i, const EncSet &f
                                                                >                 const std::string &why)
                                                                >  {
                                                                >      const unsigned int arg_count = i.argument_count();
                                                                >      TEST_BadItemArgumentCount(i.type(), 2, arg_count);
                                                                >
                                                                >      Item *const *const args = i.arguments();
                                                                >      std::vector<std::shared_ptr<RewritePlan> >
                                                                >          childr_rp({std::shared_ptr<RewritePlan>(gather(*args[0]
                                                                >                     std::shared_ptr<RewritePlan>(gather(*args[1]
                                                                >
                                                                >      const EncSet solution =
                                                                >          filter_es.intersect(childr_rp[0]->es_out).
                                                                >                    intersect(childr_rp[1]->es_out);
                                                                >      TEST_NoAvailableEncSet(solution, i.type(), filter_es, why, 
                                                                >
                                                                >      const reason rsn(solution, why, i);
                                                                >
                                                                >      return new RewritePlanWithChildren(solution, rsn, childr_rp
                                                                >  }
                                                                >
                                                                >
                                                                >  //add support for user variable
                                                                >  static class ANON : public CItemSubtypeFT<Item_func_get_user_va
                                                                >
                                                                >      virtual RewritePlan *
                                                                >      do_gather_type(const Item_func_get_user_var &i, Analysis &a
                                                                >      {
                                                                >          const std::string why = "user var";
                                                                >          const reason r = reason(PLAIN_EncSet, why, i);
                                                                >          return new RewritePlan(PLAIN_EncSet, r);
                                                                >      }
                                                                >
                                                                >      virtual Item *
                                                                >      do_rewrite_type(const Item_func_get_user_var &i,
                                                                >                      const OLK &constr, const RewritePlan &_rp,
                                                                >                      Analysis &a) const
                                                                >      {
                                                                >          return &const_cast<Item_func_get_user_var &>(i);
                                                                >      }
                                                                >  } ANON;
                                                                >
                                                                >
                                                                >
                                                                >
                                                                >
        return typical_gather(a, i, ADD_EncSet, why, true);     |          return friendlyGather(a, i, ADD_EncSet, why);
        const RewritePlanOneOLK &rp =                           |          const RewritePlanWithChildren &rp =
            static_cast<const RewritePlanOneOLK &>(_rp);        |              static_cast<const RewritePlanWithChildren &>(_rp);
        if (oAGG == constr.o) {                                 |          const EncSet chose_encset = rp.es_out.intersect(EncSet(
            OnionMeta *const om = rp.olk.key->getOnionMeta(oAGG |          const OLK olk = chose_encset.chooseOne();
                                                                >          TEST_Text(OLK::isNotInvalid(olk),
                                                                >                    "no valid EncSet available for Addition/Subtr
                                                                >
                                                                >          switch (olk.o) {
                                                                >          case oAGG: {
                                                                >              TEST_Text(olk.key, "fail");
                                                                >
                                                                >              OnionMeta *const om = olk.key->getOnionMeta(oAGG);
        } else {                                                |          }
                                                                >          default:
/*                                                              <
extern const char str_sqrt[] = "sqrt";                          <
static CItemMath<Item_func_sqrt, str_sqrt> ANON;                <
                                                                <
extern const char str_round[] = "round";                        <
static CItemMath<Item_func_round, str_round> ANON;              <
                                                                <
extern const char str_sin[] = "sin";                            <
static CItemMath<str_sin> ANON;                                 <
                                                                <
extern const char str_cos[] = "cos";                            <
static CItemMath<str_cos> ANON;                                 <
                                                                <
extern const char str_acos[] = "acos";                          <
static CItemMath<str_acos> ANON;                                <
*/                                                              <
                                                                <
// extern const char str_radians[] = "radians";                 <
// static CItemMath<str_radians> ANON;                          <
                                                                <
                                                                <
                                                                <
        /*                                                      <
        LOG(cdb_v) << "Item_func do_gather_type " << *i;        <
                                                                <
        Item **args = i->arguments();                           <
        assert_s(i->argument_count() == 2, "expecting LIKE to h <
                                                                <
        if ((args[0]->type() == Item::Type::FIELD_ITEM) && (arg <
                                                                <
            string s(args[1]->str_value.ptr(), args[1]->str_val <
                                                                <
            if (s.find('%') == s.npos && s.find('_') == s.npos) <
                // some queries actually use LIKE as an equalit <
                return typical_gather(a, i, EQ_EncSet, "LIKE eq <
                                                                <
            } else {                                            <
                                                                <
                // XXX check if pattern is one we can support?  <
                                                                <
                reason r1;                                      <
                RewritePlan * rp1 = gather(args[0], r1, a);     <
                                                                <
                EncSet solution = rp1->es_out.intersect(Search_ <
                                                                <
                if (solution.empty()) {                         <
                    cerr << "cannot support " << i << " BECAUSE <
                         << " but field only supports  " << rp1 <
                }                                               <
                                                                <
                stringstream ss;                                <
                ss << "like:'" << s << "'";                     <
                tr = reason(PLAIN_EncSet, ss.str(), i);         <
                tr.add_child(r1);                               <
                                                                <
                return new RewritePlan(PLAIN_OLK, solution.choo <
            }                                                   <
        } else {                                                <
            // we cannot support non-constant search patterns   <
            assert_s(false, "we cannot support search patterns  <
            //for (uint x = 0; x < i->argument_count(); x++)    <
            //    analyze(args[x], reason(EMPTY_EncSet, "like-n <
        }                                                       <
                                                                <
                                                                <
        */                                                      <
/*      LOG(cdb_v) << "Item_func_like do_rewrite_type " << *i;  <
                                                                <
        assert_s(i->argument_count() == 2, "expecting LIKE to h <
        Item **args = i->arguments();                           <
                                                                <
        if ((args[0]->type() == Item::Type::FIELD_ITEM) && (arg <
                                                                <
            string s(args[1]->str_value.ptr(), args[1]->str_val <
                                                                <
            if (s.find('%') == s.npos && s.find('_') == s.npos) <
                // some queries actually use LIKE as an equalit <
                                                                <
                Item_func_like * res = new Item_func_like(args[ <
                do_rewrite_type_args(i, res, constr, a);        <
                                                                <
                return res;                                     <
                                                                <
            } else {                                            <
                // XXX check if pattern is one we can support?  <
                                                                <
                RewritePlan * plan = getAssert(a.itemRewritePla <
                auto childr_plan = getAssert(plan->plan, constr <
                OLK child_OLK = getAssert(childr_plan, args[0]) <
                                                                <
                if (child_OLK == PLAIN_OLK) {                   <
                    return new Item_func_like(args[0], args[1], <
                }                                               <
                                                                <
                Item * field = itemTypes.do_rewrite(args[0], ch <
                args[0]->name = NULL; //no alias                <
                                                                <
                Item * expr = args[1];                          <
                FieldMeta * fm = child_OLK.key;                 <
                                                                <
                EncLayer * el = getAssert(fm->onions, oSWP)->la <
                assert_s(el->level() == SECLEVEL::SEARCH, "inco <
                                                                <
                Item * res = ((Search *) el)->searchUDF(field,  <
                cerr << "result is " << *res << "\n";           <
                                                                <
                return res;                                     <
            }                                                   <
        }                                                       <
                                                                <
        // we cannot support non-constant search patterns       <
        assert_s(false, "we cannot support search patterns not  <
*/                                                              <
//TODO: use this func in other places as well                   <
/*static List<Item> *                                           <
getArgs(Item_func * itf) {                                      <
    List<Item> * res = new List<Item>();                        <
    Item ** args = itf->arguments();                            <
    for (uint j = 0; j < itf->argument_count(); j++)  {         <
        res->push_back(args[j]);                                <
    }                                                           <
    return res;                                                 <
}                                                               <
*/                                                              <
                                                                <
    //FIXME: Cleanup.                                           <
        Item *const cond =                                      |          AssignOnce<Item *> cond;
            cmp_sign ? static_cast<Item *>(new                  |          if (-1 == cmp_sign) {
                            Item_func_gt(cond_arg0, cond_arg1)) |              cond = new Item_func_gt(cond_arg0, cond_arg1);
                     : static_cast<Item *>(new                  |          } else if (1 == cmp_sign) {
                            Item_func_lt(cond_arg0, cond_arg1)) |              cond = new Item_func_lt(cond_arg0, cond_arg1);
                                                                >          } else {
                                                                >              FAIL_TextMessageError("unknown comparison type with
                                                                >                                    " Item_func_min_max");
                                                                >          }
                                                                >
                                                                >          // this monstrosity forces us to lower the DET onion fr
                                                                >          // we do not handle cases where a projection is not _ju
                                                                >          // and requires a salt
                                                                >          // > EXCEPT: when we are being called from inside a SUM
                                                                >          //   'summation_hack'
                                                                >          FieldMeta *const fm = rp.olk.key;
                                                                >          if (fm
                                                                >              && false == a.summation_hack
                                                                >              && SECLEVEL::RND <= a.getOnionLevel(*fm, oDET)) {
                                                                >
                                                                >              const DatabaseMeta &dm = a.getDatabaseMeta(a.getDat
                                                                >              const TableMeta *const tm = dm.getChildWithGChild(*
                                                                >              if (tm) {
                                                                >                  throw OnionAdjustExcept(*tm, *fm, oDET, SECLEVE
                                                                >              }
                                                                >          }
        return new Item_func_if(cond,                           |          return new Item_func_if(cond.get(),
//TODO: do we still need the file analyze.cc?                   <
                                                                <
    do_gather_type(const Item_func_strcmp &i, Analysis &a) cons |      do_gather_type(const Item_func_strcmp &i, Analysis &a) cons
    {                                                           <
        //cerr << "do_a_t Item_func_strcmp reason " << tr << "\ <
        /* Item **args = i->arguments();                        <
        for (uint x = 0; x < i->argument_count(); x++)          <
            analyze(args[x], reason(EQ_EncSet, "strcmp", i, &tr <
        return tr.encset;                                       <
        */                                                      <
    virtual Item * do_optimize_type(Item_func_strcmp *i, Analys |      virtual Item * do_optimize_type(Item_func_strcmp *i, Analys
    {                                                           <
    do_gather_type(const Item_func_if &i, Analysis &a) const    |      do_gather_type(const Item_func_if &i, Analysis &a) const {
    {                                                           <
        /*                                                      <
        Item **args = i->arguments();                           <
        assert(i->argument_count() == 3);                       <
        analyze(args[0], a);                                    <
        analyze(args[1], a);                                    <
        analyze(args[2], a);                                    <
        return a.rewritePlans.find(i)->second;                  <
        */                                                      <
        /*                                                      <
         Item **args = i->arguments();                          <
        for (uint x = 0; x < i->argument_count(); x++)          <
            analyze(args[x], a);                                <
            return a.rewritePlans.find(i)->second;              <
        */                                                      <
        /*     Item **args = i->arguments();                    |          const std::string &why = str_case;
        int first_expr_num = i->*rob<Item_func_case, int,       |          return allPlainIterateGather(i, why, a);
                &Item_func_case::first_expr_num>::ptr();        <
        int else_expr_num = i->*rob<Item_func_case, int,        <
                &Item_func_case::else_expr_num>::ptr();         <
        uint ncases = i->*rob<Item_func_case, uint,             <
                &Item_func_case::ncases>::ptr();                <
                                                                <
        if (first_expr_num >= 0)                                <
            analyze(args[first_expr_num],                       <
                    reason(EQ_EncSet, "case_first", i, &tr), a) <
        if (else_expr_num >= 0)                                 <
            analyze(args[else_expr_num], tr, a);                <
                                                                <
        for (uint x = 0; x < ncases; x += 2) {                  <
            if (first_expr_num < 0)                             <
            analyze(args[x],                                    <
                    reason(EMPTY_EncSet, "case_nofirst", i, &tr <
            else                                                <
            analyze(args[x],                                    <
                    reason(EQ_EncSet, "case_w/first", i, &tr),  <
            analyze(args[x+1], tr, a);                          <
        }                                                       <
        return tr.encset;                                       <
        */                                                      <
                                                                >
                                                                >      virtual Item *
                                                                >      do_rewrite_type(const Item_func_case &i, const OLK &constr,
                                                                >                      const RewritePlan &rp, Analysis &a) const
                                                                >      {
                                                                >          return rewrite_args_FN(i, constr,
                                                                >                                 static_cast<const RewritePlanOne
                                                                >      }
                                                                <
        /*                                                      <
        LOG(cdb_v) << "CItemSubtypeFN (L1107) do_gather " << *i <
        const std::string why = str_in_optimizer;               <
        return allPlainIterateGather(i, why, tr, a);            <
        */                                                      <
                                                                <
        /*                                                      <
        //Item **args = i->arguments();                         <
        //analyze(args[0], reason(EMPTY_EncSet, "in_opt", i, &t <
        //analyze(args[1], reason(EMPTY_EncSet, "in_opt", i, &t <
        return NULL;                                            <
        */                                                      <
// Use encryption/rewriting.                                    |  // FIXME: Use encryption/rewriting.
                                                                >
                                                                >  extern const char str_current_user[] = "current_user";
                                                                >  static class ANON : public CItemSubtypeFN<Item_func_current_use
                                                                >                                            str_current_user> {
                                                                >      virtual RewritePlan *
                                                                >      do_gather_type(const Item_func_current_user &i, Analysis &a
                                                                >      {
                                                                >          const EncSet out_es = PLAIN_EncSet;
                                                                >          const EncSet child_es = PLAIN_EncSet;
                                                                >          const std::string why = str_current_user;
                                                                >
                                                                >          return allPlainIterateGather(i, why, a);
                                                                >      }
                                                                >
                                                                >      virtual Item *
                                                                >      do_rewrite_type(const Item_func_current_user &i, const OLK 
                                                                >                      const RewritePlan &rp, Analysis &a) const
                                                                >      {
                                                                >          return rewrite_args_FN(i, constr,
                                                                >                                 static_cast<const RewritePlanOne
                                                                >                                 a);
                                                                >      }
                                                                >  } ANON;
                                                                >
                                                                >  PLAIN_FUNCTION(Item_func_connection_id, connection_id);
                                                                >
                                                                >  #undef PLAIN_FUNCTION
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/rewrite_main.cc Practical-Cryptdb/main/rewrite_main.cc
                                                                >  #include <util/yield.hpp>
                                                                >  #include <errmsg.h>
      throw std::runtime_error("crash test exception");         |        throw CrashTestException();
                                                                |  static bool
//TODO: remove this at some point                               <
static inline void                                              <
mysql_query_wrapper(MYSQL *const m, const std::string &q)       <
{                                                               <
    if (mysql_query(m, q.c_str())) {                            <
        cryptdb_err() << "query failed: " << q                  <
                << " reason: " << mysql_error(m);               <
    }                                                           <
                                                                <
    // HACK(stephentu):                                         <
    // Calling mysql_query seems to have destructive effects    <
    // on the current_thd. Thus, we must call create_embedded_t <
    // again.                                                   <
    void *const ret = create_embedded_thd(0);                   <
    if (!ret) assert(false);                                    <
}                                                               <
                                                                <
bool                                                            <
    for (auto it = fm.children.begin(); it != fm.children.end() |      for (const auto &it : fm.getChildren()) {
         it++) {                                                |          OnionMeta *const om = it.second.get();
        OnionMeta *const om = (*it).second.get();               |          const onion o = it.first.getValue();
        const onion o = (*it).first.getValue();                 <
        for (size_t i = 0; i < om->layers.size(); ++i) {        |          const auto &layers = om->getLayers();
            std::unique_ptr<EncLayer> const &layer = om->layers |          for (size_t i = 0; i < layers.size(); ++i) {
                                                                >              const auto &layer = layers[i];
    for (auto it = tm.children.begin(); it != tm.children.end() |      for (const auto &it : tm.getChildren()) {
        const std::unique_ptr<FieldMeta> &fm = (*it).second;    |          const auto &fm = it.second;
    for (auto it = dm.children.begin(); it != dm.children.end() |      for (const auto &it : dm.getChildren()) {
        const std::unique_ptr<TableMeta> &tm = (*it).second;    |          const auto &tm = it.second;
    for (auto it = schema.children.begin(); it != schema.childr |      for (const auto &it : schema.getChildren()) {
         it++) {                                                |          const auto &dm = it.second;
        const std::unique_ptr<DatabaseMeta> &tm = (*it).second; |          assert(sanityCheck(*dm.get()));
        assert(sanityCheck(*tm.get()));                         |      }
                                                                >      return true;
                                                                >  }
                                                                >
                                                                >  static std::map<std::string, int>
                                                                >  collectTableNames(const std::string &db_name,
                                                                >                    const std::unique_ptr<Connect> &c)
                                                                >  {
                                                                >      std::map<std::string, int> name_map;
                                                                >
                                                                >      assert(c->execute("USE " + quoteText(db_name)));
                                                                >
                                                                >      std::unique_ptr<DBResult> dbres;
                                                                >      assert(c->execute("SHOW TABLES", &dbres));
                                                                >
                                                                >      assert(1 == mysql_num_fields(dbres->n));
                                                                >      MYSQL_ROW row;
                                                                >      while ((row = mysql_fetch_row(dbres->n))) {
                                                                >          const unsigned long *const l = mysql_fetch_lengths(dbre
                                                                >          const std::string table_name(row[0], l[0]);
                                                                >          // all table names should be unique
                                                                >          assert(name_map.end() == name_map.find(table_name));
                                                                >          name_map[table_name] = 1;
                                                                >      }
                                                                >      assert(mysql_num_rows(dbres->n) == name_map.size());
                                                                >
                                                                >      return name_map;
                                                                >  }
                                                                >
                                                                >  // compares SHOW TABLES on embedded and remote with the SchemaI
                                                                >  static bool
                                                                >  tablesSanityCheck(SchemaInfo &schema,
                                                                >                    const std::unique_ptr<Connect> &e_conn,
                                                                >                    const std::unique_ptr<Connect> &conn)
                                                                >  {
                                                                >      for (const auto &dm_it : schema.getChildren()) {
                                                                >          const auto &db_name = dm_it.first.getValue();
                                                                >          const auto &dm = dm_it.second;
                                                                >          // gather anonymous tables
                                                                >          std::map<std::string, int> anon_name_map =
                                                                >              collectTableNames(db_name, conn);
                                                                >
                                                                >          // gather plain tables
                                                                >          std::map<std::string, int> plain_name_map =
                                                                >              collectTableNames(db_name, e_conn);
                                                                >
                                                                >          const auto &meta_tables = dm->getChildren();
                                                                >          assert(meta_tables.size() == anon_name_map.size());
                                                                >          assert(meta_tables.size() == plain_name_map.size());
                                                                >          for (const auto &tm_it : meta_tables) {
                                                                >              const auto &tm = tm_it.second;
                                                                >
                                                                >              assert(anon_name_map.find(tm->getAnonTableName())
                                                                >                     != anon_name_map.end());
                                                                >              anon_name_map.erase(tm->getAnonTableName());
                                                                >
                                                                >              assert(plain_name_map.find(tm_it.first.getValue())
                                                                >                     != plain_name_map.end());
                                                                >              plain_name_map.erase(tm_it.first.getValue());
                                                                >          }
                                                                >          //why earse here?
                                                                >          assert(0 == anon_name_map.size());
                                                                >          assert(0 == plain_name_map.size());
                                                                >
    const bool embedded_begin;                                  <
    const bool existed_remote;                                  <
    const bool remote_begin;                                    <
    const std::string query;                                    |      const std::string original_query;
                                                                >      const std::string rewritten_query;
    RecoveryDetails(bool embedded_begin, bool embedded_complete |      RecoveryDetails(bool embedded_complete, bool remote_complet
                    bool existed_remote, bool remote_begin,     |                      const std::string &original_query,
                    bool remote_complete, const std::string &qu |                      const std::string &rewritten_query,
        : embedded_begin(embedded_begin),                       |          : embedded_complete(embedded_complete),
          embedded_complete(embedded_complete),                 |            remote_complete(remote_complete), original_query(orig
          existed_remote(existed_remote), remote_begin(remote_b |            rewritten_query(rewritten_query), default_db(default_
          remote_complete(remote_complete), query(query),       <
          default_db(default_db) {}                             <
false_if_false(bool test, const std::string &new_value)         <
{                                                               <
    if (false == test) {                                        <
        return test;                                            <
    }                                                           <
                                                                <
    return string_to_bool(new_value);                           <
}                                                               <
static bool                                                     <
    const std::string embedded_completion_table =               <
        MetaData::Table::embeddedQueryCompletion();             <
    const std::string remote_completion_table =                 <
        MetaData::Table::remoteQueryCompletion();               <
                                                                <
    const std::string embedded_completion_q =                   |      const std::string &embedded_completion_q =
        " SELECT begin, complete, original_query, default_db FR |          " SELECT complete, original_query, rewritten_query, def
            embedded_completion_table +                         |              MetaData::Table::embeddedQueryCompletion() +
    const std::string string_embedded_begin(embedded_row[0], l[ |      const std::string string_embedded_complete(  embedded_row[0
    const std::string string_embedded_complete(embedded_row[1], |      const std::string original_query(            embedded_row[1
    const std::string string_embedded_query(embedded_row[2], l[ |      const std::string rewritten_query(           embedded_row[2
    const std::string string_embedded_default_db(embedded_row[3 |      const std::string default_db(                embedded_row[3
    const std::string remote_completion_q =                     |      const std::string &remote_completion_q =
        " SELECT begin, complete FROM " + remote_completion_tab |          " SELECT COUNT(*) FROM " + MetaData::Table::remoteQuery
    const unsigned long remote_row_count = mysql_num_rows(dbres |      assert(1 == mysql_num_rows(dbres->n));
    assert(!!remote_row == !!remote_row_count);                 |      const unsigned long *const l_remote = mysql_fetch_lengths(d
    std::string string_remote_begin, string_remote_complete;    |      const long long remote_count =
    const bool existed_remote = !!remote_row;                   |          std::stoll(std::string(remote_row[0], l_remote[0]));
    if (existed_remote) {                                       |      assert(remote_count <= 1);
        const unsigned long *const l = mysql_fetch_lengths(dbre |      const bool remote_complete = remote_count == 1;
        string_remote_begin    = std::string(remote_row[0], l[0 |
        string_remote_complete = std::string(remote_row[1], l[1 |      const bool embedded_complete = string_to_bool(string_embedd
        assert(string_to_bool(string_remote_begin) == true);    |      if (embedded_complete) {
                                                                >          assert(remote_complete);
    const bool embedded_begin = string_to_bool(string_embedded_ <
    const bool embedded_complete =                              <
        string_to_bool(string_embedded_complete);               <
    const bool remote_begin =                                   <
        false_if_false(existed_remote, string_remote_begin);    <
    const bool remote_complete =                                <
        false_if_false(existed_remote, string_remote_complete); <
                                                                <
    assert(true == embedded_begin);                             <
                                                                <
            new RecoveryDetails(embedded_begin, embedded_comple |              new RecoveryDetails(embedded_complete, remote_compl
                                existed_remote, remote_begin,   |                                  original_query, rewritten_query
                                remote_complete, string_embedde |                                  default_db));
                                string_embedded_default_db));   <
    const std::string embedded_completion_table =               <
        MetaData::Table::embeddedQueryCompletion();             <
                                                                <
        " UPDATE " + embedded_completion_table +                |          " UPDATE " + MetaData::Table::embeddedQueryCompletion()
                                                                <
    const std::string embedded_completion_table =               <
        MetaData::Table::embeddedQueryCompletion();             <
                                                                <
        " UPDATE " + embedded_completion_table +                |          " UPDATE " + MetaData::Table::embeddedQueryCompletion()
                                                                >  // we never issue onion adjustment queries from here
    RETURN_FALSE_IF_FALSE(collectRecoveryDetails(conn, e_conn,  |      RETURN_FALSE_IF_FALSE(
                                                 unfinished_id, |          collectRecoveryDetails(conn, e_conn, unfinished_id, &de
                                                 &details));    |      assert(false == details->embedded_complete);
    assert(details->remote_begin == details->remote_complete);  |      assert(""    == details->rewritten_query);
    if (false == details->remote_begin) {                       |      if (false == details->remote_complete) {
        assert(false == details->embedded_complete              |          assert(false == details->embedded_complete);
               && false == details->existed_remote              |
               && false == details->remote_complete);           <
    // lifted from mysql-src/includes/errmsg.h                  |      std::map<unsigned int, int> errors{
    unsigned long cr_unknown_error        = 2000,               |          {CR_UNKNOWN_ERROR, 1}, {CR_SERVER_GONE_ERROR, 1}, {CR_S
                  cr_server_gone_error    = 2006,               |          {CR_COMMANDS_OUT_OF_SYNC, 1}, {ER_OUTOFMEMORY, 1}};
                  cr_server_lost          = 2013,               <
                  cr_commands_out_of_sync = 2014;               <
    const bool ret =                                            |      return errors.end() == errors.find(err);
        cr_unknown_error == err ||                              <
        cr_server_gone_error == err ||                          <
        cr_server_lost == err ||                                <
        cr_commands_out_of_sync == err;                         <
                                                                <
    return !ret;                                                <
// 'bad_query' is a sanity checking mechanism; if the query is  |  enum class QueryStatus {UNKNOWN_ERROR, MALFORMED_QUERY, SUCCESS
// against the remote database, it should also be bad against t |                          RECOVERABLE_ERROR};
// database.                                                    |  static QueryStatus
static bool                                                     |  retryQuery(const std::unique_ptr<Connect> &c, const std::string
retryQuery(const std::unique_ptr<Connect> &c, const std::string <
           bool *const bad_query)                               <
    assert(bad_query);                                          |      if (true == c->execute(query)) {
                                                                |          return QueryStatus::SUCCESS;
    *bad_query = false;                                         |      }
    if (false == c->execute(query)) {                           |      // the query failed again
        // if the error is not recoverable, we must determine i |      if (true == recoverableDeltaError(err)) {
        // the query failed initially for the same error.       |          // the query possibly succeeded initially and failed im
        if (false == recoverableDeltaError(err)) {              |          // afterwards; or the query just failed originally for 
            *bad_query = queryInitiallyFailedErrors(err);       |          // reason
            RETURN_FALSE_IF_FALSE(*bad_query);                  |          return QueryStatus::RECOVERABLE_ERROR;
                                                                |      }
            // We could abort the query here because we know th |
            // the query is bad and can't be processed by the r |      // the error is not recoverable and we want to determine if
            // or embedded server.                              |      // is failing because it is bad (malformed or otherwise) or
        }                                                       |      // we are having hardware issues (lose of connectivity, etc
                                                                >      // > if the query is just _bad_; tell the caller and he can
                                                                >      // gracefully
                                                                >      // > if there are hardware issues; we will need manual inte
                                                                >      if (true == queryInitiallyFailedErrors(err)) {
                                                                >          return QueryStatus::MALFORMED_QUERY;
    return true;                                                |      return QueryStatus::UNKNOWN_ERROR;
    const std::string remote_completion_table =                 <
        MetaData::Table::remoteQueryCompletion();               <
                                                                <
    RETURN_FALSE_IF_FALSE(collectRecoveryDetails(conn, e_conn,  |      RETURN_FALSE_IF_FALSE(
                                                 unfinished_id, |          collectRecoveryDetails(conn, e_conn, unfinished_id, &de
                                                 &details));    |      assert(false == details->embedded_complete);
    assert(true == details->embedded_begin                      <
           && false == details->embedded_complete);             <
    // failure after initial embedded queries and before remote |      AssignOnce<QueryStatus> remote_query_status;
    if (false == details->remote_begin) {                       <
        assert(false == details->embedded_complete              <
               && false == details->existed_remote              <
               && false == details->remote_complete);           <
        return abortQuery(e_conn, unfinished_id);               <
    }                                                           <
                                                                <
    // --------------------------------------------------       <
    //  After this point we must run to completion as we        <
    //        _may_ have made a DDL modification                <
    //  > unless we determine that it is a bad query.           <
    //  -------------------------------------------------       <
                                                                <
    // ugly sanity checking device                              <
    AssignOnce<bool> remote_bad_query;                          <
        bool rbq;                                               |          // reissue the rewritten DDL query against the remote d
        // reissue the DDL query against the remote database.   |          remote_query_status = 
        RETURN_FALSE_IF_FALSE(retryQuery(conn, details->query,  |              retryQuery(conn, details->rewritten_query);
                                         &rbq));                |          if (QueryStatus::UNKNOWN_ERROR == remote_query_status.g
        remote_bad_query = rbq;                                 |              assert(false);
                                                                >              return false;
                                                                >          }
        const std::string update_remote_complete =              |          // remote is now fully updated
            "UPDATE " + remote_completion_table +               |          const std::string &insert_remote_complete =
            "   SET complete = TRUE"                            |              " INSERT INTO " + MetaData::Table::remoteQueryCompl
            " WHERE embedded_completion_id = " +                |              "  (embedded_completion_id, completion_type) VALUES
                    std::to_string(unfinished_id) + ";";        |              "  (" + std::to_string(unfinished_id) + ","
        RETURN_FALSE_IF_FALSE(conn->execute(update_remote_compl |              "   '" + TypeText<CompletionType>::toText(Completio
                                                                >              "  );";
                                                                >          RETURN_FALSE_IF_FALSE(conn->execute(insert_remote_compl
                                                                >
                                                                >          if (QueryStatus::MALFORMED_QUERY == remote_query_status
                                                                >              // if the query is bad there is no reason to try it
                                                                >              // embedded database
                                                                >              return abortQuery(e_conn, unfinished_id);
                                                                >          }
                                                                >      } else {
                                                                >          // query already succeeded initially
                                                                >          remote_query_status = QueryStatus::SUCCESS;
                                                                >      }
                                                                >
                                                                >      switch (remote_query_status.get()) {
                                                                >      case QueryStatus::SUCCESS:
                                                                >      case QueryStatus::RECOVERABLE_ERROR:
                                                                >          break;
                                                                >      default:
                                                                >          assert(false);
        // reissue the DDL query against the embedded database  |          // reissue the original DDL query against the embedded 
        bool embedded_bad_query;                                |          const QueryStatus embedded_query_status =
        RETURN_FALSE_IF_FALSE(retryQuery(e_conn, details->query |              retryQuery(e_conn, details->original_query);
                                         &embedded_bad_query)); |          switch (embedded_query_status) {
        assert(false == remote_bad_query.assigned()             |          // possibly a hardware issue
               || embedded_bad_query == remote_bad_query.get()) |          case QueryStatus::UNKNOWN_ERROR:
                                                                >          // a broken query should not have made it this far
                                                                >          case QueryStatus::MALFORMED_QUERY:
                                                                >              return false;
        if (true == embedded_bad_query) {                       |          // --------------------------------------
            return abortQuery(e_conn, unfinished_id);           |          // cases above this line are 'definitely'
                                                                >          // an invalid completion
                                                                >          // --------------------------------------
                                                                >
                                                                >          // sometimes you can have a valid success after a fail 
                                                                >          // remote database; consider the case where the proxy f
                                                                >          // after a successfull DDL query (before it can do comp
                                                                >          case QueryStatus::SUCCESS:
                                                                >              break;
                                                                >
                                                                >          case QueryStatus::RECOVERABLE_ERROR:
                                                                >              // if we originally succeeded, we have to succeed n
                                                                >              if (true == details->remote_complete) {
                                                                >                  return false;
                                                                >              }
                                                                >              break;
                                                                >
                                                                >          default:
                                                                >              assert(false);
                                                                >      
        "  WHERE (begin = FALSE OR complete = FALSE)"           |          "  WHERE complete = FALSE AND aborted != TRUE;";
        "    AND aborted != TRUE;";                             |
                                                                >
                                                                >
                                                                >
                                                                >      if (!PRETTY_DEMO) {
                                                                >      }
                                                                >
        case CompletionType::AdjustOnionCompletion:             |          case CompletionType::Onion:
        case CompletionType::DDLCompletion:                     |          case CompletionType::DDL:
                                                                >  // bleeding and regular meta tables must have identical content
                                                                >  // > note that their next auto_increment value will not necessa
                                                                >  //   identical
                                                                >  static bool
                                                                >  metaSanityCheck(const std::unique_ptr<Connect> &e_conn)
                                                                >  {
                                                                >      // same number of elements
                                                                >      {
                                                                >          std::unique_ptr<DBResult> regular_dbres;
                                                                >          assert(e_conn->execute("SELECT * FROM " + MetaData::Tab
                                                                >                                 &regular_dbres));
                                                                >
                                                                >          std::unique_ptr<DBResult> bleeding_dbres;
                                                                >          assert(e_conn->execute("SELECT * FROM "
                                                                >                                 + MetaData::Table::bleedingMetaO
                                                                >                                 &bleeding_dbres));
                                                                >
                                                                >          assert(mysql_num_rows(bleeding_dbres->n)
                                                                >              == mysql_num_rows(regular_dbres->n));
                                                                >      }
                                                                >
                                                                >      // scan through regular
                                                                >      {
                                                                >          std::unique_ptr<DBResult> dbres;
                                                                >          assert(e_conn->execute(
                                                                >              "SELECT * FROM " + MetaData::Table::metaObject() + 
                                                                >              " WHERE NOT EXISTS ("
                                                                >              "       SELECT * FROM " +
                                                                >                          MetaData::Table::bleedingMetaObject() +
                                                                >              "       WHERE"
                                                                >              "           m.serial_object = b.serial_object AND"
                                                                >              "           m.serial_key    = b.serial_key AND"
                                                                >              "           m.id            = b.id AND"
                                                                >              "           m.parent_id     = b.parent_id)",
                                                                >              &dbres));
                                                                >
                                                                >          assert(0 == mysql_num_rows(dbres->n));
                                                                >      }
                                                                >
                                                                >      // scan through bleeding
                                                                >      {
                                                                >          std::unique_ptr<DBResult> dbres;
                                                                >          assert(e_conn->execute(
                                                                >              "SELECT * FROM " + MetaData::Table::bleedingMetaObj
                                                                >              " WHERE NOT EXISTS ("
                                                                >              "       SELECT * FROM " +
                                                                >                          MetaData::Table::metaObject() + " AS m"
                                                                >              "       WHERE"
                                                                >              "           m.serial_object = b.serial_object AND"
                                                                >              "           m.serial_key    = b.serial_key AND"
                                                                >              "           m.id            = b.id AND"
                                                                >              "           m.parent_id     = b.parent_id)",
                                                                >              &dbres));
                                                                >
                                                                >          assert(0 == mysql_num_rows(dbres->n));
                                                                >      }
                                                                >
                                                                >      return true;
                                                                >  }
                                                                >
                                                                >
                                                                >
                                                                >
                                                                >
SchemaInfo *                                                    <
loadSchemaInfo(const std::unique_ptr<Connect> &conn,            <
               const std::unique_ptr<Connect> &e_conn)          <
{                                                               <
    // Must be done before loading the children.                <
    assert(deltaSanityCheck(conn, e_conn));                     <
    SchemaInfo *const schema = new SchemaInfo();                |  /*
    // Recursively rebuild the AbstractMeta<Whatever> and it's  |  *Now I want to separate the original loadSchemaInfo into two pa
    std::function<DBMeta *(DBMeta *const)> loadChildren =       |  */
        [&loadChildren, &e_conn](DBMeta *const parent) {        |
                                                                >
                                                                >  static DBMeta* loadChildren(DBMeta *const parent,const std::uni
                loadChildren(it);                               |          loadChildren(it,e_conn);
                                                                >      }
                                                                >      return parent;
            return parent;  /* lambda */                        |  std::unique_ptr<SchemaInfo>
        };                                                      |  loadSchemaInfo(const std::unique_ptr<Connect> &conn,
                                                                |                 const std::unique_ptr<Connect> &e_conn){
    loadChildren(schema);                                       |      // Must be done before loading the children.
    // FIXME: Ideally we would do this before loading the schem |      assert(deltaSanityCheck(conn, e_conn));
    // But first we must decide on a place to create the databa |      std::unique_ptr<SchemaInfo>schema(new SchemaInfo());
    assert(sanityCheck(*schema));                               |      // Recursively rebuild the AbstractMeta<Whatever> and it's 
                                                                |      loadChildren(schema.get(),e_conn);
    return schema;                                              |      //check from the upmost to the lowest
                                                                >      assert(sanityCheck(*schema.get()));
                                                                >      //check metaobject and bleeding table are identical
                                                                >      assert(metaSanityCheck(e_conn));
                                                                >      // compares SHOW TABLES on embedded and remote with the Sch
                                                                >      assert(tablesSanityCheck(*schema.get(), e_conn, conn));
                                                                >      return std::move(schema);
                 std::vector<Type> enums)                       |                   std::vector<Type> enums){
{                                                               <
buildTypeTextTranslator()                                       |  buildTypeTextTranslator(){
{                                                               <
    const std::vector<std::string> onion_strings                |      const std::vector<std::string> onion_strings {
    {                                                           |          "oINVALID", "oPLAIN", "oEq", "oOrder", "oADD", "oSWP"
        "oINVALID", "oPLAIN", "oDET", "oOPE", "oAGG", "oSWP"    <
    const std::vector<onion> onions                             |      const std::vector<onion> onions {
    {                                                           <
                                                                <
    const std::vector<std::string> seclevel_strings             |      const std::vector<std::string> seclevel_strings{
    {                                                           |          "RND", "DET", "DETJOIN","OPEFOREIGN" ,"OPE", "HOM", "SE
        "RND", "DET", "DETJOIN", "OPE", "HOM", "SEARCH", "PLAIN <
    const std::vector<SECLEVEL> seclevels                       |      const std::vector<SECLEVEL> seclevels{
    {                                                           |          SECLEVEL::RND, SECLEVEL::DET, SECLEVEL::DETJOIN, SECLEV
        SECLEVEL::RND, SECLEVEL::DET, SECLEVEL::DETJOIN, SECLEV <
    const std::vector<std::string> mysql_type_strings           |      const std::vector<std::string> mysql_type_strings{
    {                                                           <
    const std::vector<enum enum_field_types> mysql_types        |      const std::vector<enum enum_field_types> mysql_types{
    {                                                           <
    const std::vector<std::string> mysql_item_strings           |      const std::vector<std::string> mysql_item_strings{
    {                                                           <
    const std::vector<enum Item::Type> mysql_item_types         |      const std::vector<enum Item::Type> mysql_item_types{
    {                                                           <
    const std::vector<std::string> disable_enable_keys_strings  |      const std::vector<std::string> disable_enable_keys_strings{
    {                                                           <
        disable_enable_keys_types                               |          disable_enable_keys_types{
    {                                                           <
    const std::vector<std::string> onion_layout_strings         |      const std::vector<std::string> onion_layout_strings{
    {                                                           <
                                                                <
    const std::vector<onionlayout> onion_layouts                |      const std::vector<onionlayout> onion_layouts{
    {                                                           <
    const std::vector<std::string> geometry_type_strings        |      const std::vector<std::string> geometry_type_strings{
    {                                                           <
    std::vector<Field::geometry_type> geometry_types            |      std::vector<Field::geometry_type> geometry_types{
    {                                                           <
    const std::vector<std::string> security_rating_strings      |      const std::vector<std::string> security_rating_strings{
    {                                                           <
    const std::vector<SECURITY_RATING> security_rating_types    |      const std::vector<SECURITY_RATING> security_rating_types {
    {                                                           <
        CompletionType::DDLCompletion,                          |          CompletionType::DDL, CompletionType::Onion
        CompletionType::AdjustOnionCompletion                   <
buildTypeTextTranslatorHack()                                   |  buildTypeTextTranslatorHack(){
{                                                               <
                                                                <
    query << " UPDATE " << dbname << "." << anon_table_name     |      query << " UPDATE " << quoteText(dbname) << "." << anon_tab
    std::cerr << "\nADJUST: \n" << query.str() << std::endl;    |      std::cerr << GREEN_BEGIN << "\nADJUST: \n" << COLOR_END << 
static std::pair<std::vector<std::unique_ptr<Delta> >,          |  std::pair<std::vector<std::unique_ptr<Delta> >,
    std::cout << "onion: " << TypeText<onion>::toText(o) << std |      TEST_Text(tolevel >= a.getOnionMeta(fm, o).getMinimumSecLev
                                                                >                "your query requires to permissive of a security 
                                                                >
                                                                >      // return make_pair(deltas, adjust_queries);
                                                                <
    return i;                                                   <
                                                                <
    /* TODO for later                                           <
    if (i->const_item()) {                                      <
        // ask embedded DB to eval this const item,             <
        // then replace this item with the eval-ed constant     <
        //                                                      <
        // WARNING: we must make sure that the primitives like  <
        // int literals, string literals, override this method  <
        // and not ask the server.                              <
                                                                <
        // very hacky...                                        <
        stringstream buf;                                       <
        buf << "SELECT " << *i;                                 <
        string q(buf.str());                                    <
        LOG(cdb_v) << q;                                        <
                                                                <
        DBResult * dbres = NULL;                                <
        assert(a.ps->e_conn->execute(q, dbres));                <
                                                                <
        THD *thd = current_thd;                                 <
        assert(thd != NULL);                                    <
                                                                <
        MYSQL_RES *r = dbres->n;                                <
        if (r) {                                                <
            Item *rep = NULL;                                   <
                                                                <
            assert(mysql_num_rows(r) == 1);                     <
            assert(mysql_num_fields(r) == 1);                   <
                                                                <
            MYSQL_FIELD *field = mysql_fetch_field_direct(r, 0) <
            assert(field != NULL);                              <
                                                                <
            MYSQL_ROW row = mysql_fetch_row(r);                 <
            assert(row != NULL);                                <
                                                                <
            char *p = row[0];                                   <
            unsigned long *lengths = mysql_fetch_lengths(r);    <
            assert(lengths != NULL);                            <
            if (p) {                                            <
                                                                <
                LOG(cdb_v) << "p: " << p;                       <
                LOG(cdb_v) << "field->type: " << field->type;   <
                                                                <
                switch (field->type) {                          <
                    case MYSQL_TYPE_SHORT:                      <
                    case MYSQL_TYPE_LONG:                       <
                    case MYSQL_TYPE_LONGLONG:                   <
                    case MYSQL_TYPE_INT24:                      <
                        rep = new Item_int((long long) strtoll( <
                        break;                                  <
                    case MYSQL_TYPE_FLOAT:                      <
                    case MYSQL_TYPE_DOUBLE:                     <
                        rep = new Item_float(p, lengths[0]);    <
                        break;                                  <
                    case MYSQL_TYPE_DECIMAL:                    <
                    case MYSQL_TYPE_NEWDECIMAL:                 <
                        rep = new Item_decimal(p, lengths[0], i <
                        break;                                  <
                    case MYSQL_TYPE_VARCHAR:                    <
                    case MYSQL_TYPE_VAR_STRING:                 <
                        rep = new Item_string(thd->strdup(p),   <
                                              lengths[0],       <
                                              i->default_charse <
                        break;                                  <
                    default:                                    <
                        // TODO(stephentu): implement the rest  <
                        break;                                  <
                }                                               <
            } else {                                            <
                // this represents NULL                         <
                rep = new Item_null();                          <
            }                                                   <
            mysql_free_result(r);                               <
            if (rep != NULL) {                                  <
                rep->name = i->name;                            <
                return rep;                                     <
            }                                                   <
        } else {                                                <
            // some error in dealing with the DB                <
            LOG(warn) << "could not retrieve result set";       <
        }                                                       <
    }                                                           <
    */                                                          <
Item *                                                          |  //层次化的解密
decrypt_item_layers(Item *const i, const FieldMeta *const fm, o |  static Item *
                                                                >  decrypt_item_layers(const Item &i, const FieldMeta *const fm, o
    assert(!i->is_null());                                      |      assert(!RiboldMYSQL::is_null(i));
                                                                <
    Item *dec = i;                                              <
                                                                >      const Item *dec = &i;
                                                                >      Item *out_i = NULL;
                                                                >      //有fieldmeta但是不用全部, 只用其中的一个onionMeta, 这个根
    const auto &enc_layers = om->layers;                        |      //onionmeta的使用方法很简单, getlayers, 然后层层使用.
                                                                >      const auto &enc_layers = om->getLayers();
        dec = (*it)->decrypt(dec, IV);                          |          out_i = (*it)->decrypt(*dec, IV);
                                                                >          assert(out_i);
                                                                >          dec = out_i;
    return dec;                                                 |      assert(out_i && out_i != &i);
                                                                >      return out_i;
// returns the intersection of the es and fm.encdesc            <
// by also taking into account what onions are stale            <
// on fm                                                        <
/*static OnionLevelFieldMap                                     <
intersect(const EncSet & es, FieldMeta * fm) {                  <
    OnionLevelFieldMap res;                                     <
                                                                <
    for (auto it : es.osl) {                                    <
        onion o = it.first;                                     <
        auto ed_it = fm->encdesc.olm.find(o);                   <
        if ((ed_it != fm->encdesc.olm.end()) && (!fm->onions[o] <
            //an onion to keep                                  <
            res[o] = LevelFieldPair(min(it.second.first, ed_it- <
        }                                                       <
    }                                                           <
                                                                <
    return res;                                                 <
}                                                               <
*/                                                              <
                                                                >  // if more complicated subqueries begin to give us problems,
                                                                >  // subselect_engine::prepare(...) and Item_subselect::fix_field
                                                                >  // worth investigating
                                                                >          // create an Analysis object for subquery gathering/rew
                                                                >          std::unique_ptr<Analysis> subquery_analysis(new Analysi
                                                                >          // aliases should be available to the subquery as well
                                                                >          subquery_analysis->table_aliases = a.table_aliases;
                                                                >
        std::unique_ptr<Analysis>                               <
            subquery_analysis(new Analysis(a.getDatabaseName(), <
                                           a.getSchema()));     <
        const EncSet out_es = PLAIN_EncSet;                     |          const EncSet &out_es = PLAIN_EncSet;
        const reason rsn = reason(out_es, why, i);              |          const reason &rsn = reason(out_es, why, i);
                assert(false);                                  |                  break;
        // Rewrite SELECT params.                               |          /* printing a single row subquery looks like this
        // HACK: The engine inside of the Item_subselect _can_  |           * ...
        // pointer back to the Item_subselect that contains it. |           * Item_singlerow_subselect::print(...) <--- defers to 
        // > ie, subselect_single_select_engine::join::select_l |           *   Item_subselect::print(...)
        // > The way this is done varies from engine to engine  |           *     subselect_engine::print(...)     <--- pure virtu
        //   general solution seems difficuly.                  |           *       subselect_single_select_engine::print(...)
        // > set_select_lex() attemps to rectify this problem i |           *         st_select_lex::print(...) on the engine ``st
        //   cases                                              |           *
        memcpy(const_cast<st_select_lex *>(select_lex), new_sel |           * if you can get the engine in the ``Item_subselect'' 
               sizeof(st_select_lex));                          |           * our rewritten ``st_select_lex'' you will get the des
                                                                >           *
                                                                >           * the next step is to properly build a new ``Item_sing
                                                                >           * the constructor for ``Item_singlerow_subselect'' wil
                                                                >           * new engine or use an old one from the ``st_select_le
                                                                >           * we want it to use a new one, otherwise it will be th
                                                                >           * the original Item_subselect.  setting master_unit()-
                                                                >           * rewritten ``st_select_lex'' to NULL will give us thi
                                                                >           *
                                                                >           * the ``Item_singlerow_subselect'' constructor calls
                                                                >           * Item_subselect::init(...) which takes the ``st_selec
                                                                >           * parameter. provided the aforementioned NULL conditio
                                                                >           * init(...) then constructs the new ``subselect_single
                                                                >           * and our rewritten ``Item_singlerow_subselect'' keeps
                                                                >           * pointer. The ``subselect_single_select_engine'' cons
                                                                >           * takes the ``st_select_lex'' as a parameter and sets
                                                                >           * st_select_lex::master_unit()->item as a backpointer 
                                                                >           * ``Item_singlerow_subselect'' that owns the engine.
                                                                >           *
                                                                >           * sql/item_subselect.{cc,hh} has all the details shoul
                                                                >           */
                                                                >          new_select_lex->master_unit()->item = NULL;
                case Item_subselect::subs_type::SINGLEROW_SUBS: |                  case Item_subselect::subs_type::SINGLEROW_SUBS:
                    return new Item_singlerow_subselect(new_sel |                      Item_singlerow_subselect *const new_item_si
                                                                >                          new Item_singlerow_subselect(new_select
                                                                >                      // ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                                >                      //          sanity check
                                                                >                      // ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                                                >                      // did the old engine get replaced?
                                                                >                      subselect_single_select_engine *const old_e
                                                                >                          static_cast<subselect_single_select_eng
                                                                >                                  i.*rob<Item_subselect, subselec
                                                                >                                         &Item_subselect::engine>
                                                                >                      subselect_single_select_engine *const rewri
                                                                >                          static_cast<subselect_single_select_eng
                                                                >                                  new_item_single->*rob<Item_subs
                                                                >                                                        &Item_sub
                                                                >                      assert(old_engine != rewrite_engine);
                                                                >                      // does the new engine have a backpointer t
                                                                >                      // rewritten Item?
                                                                >                      st_select_lex *const old_select_lex =
                                                                >                          old_engine->*rob<subselect_single_selec
                                                                >                                           st_select_lex *,
                                                                >                                           &subselect_single_sele
                                                                >                      st_select_lex *const rewrite_select_lex =
                                                                >                          rewrite_engine->*rob<subselect_single_s
                                                                >                                               st_select_lex *,
                                                                >                                               &subselect_single_
                                                                >                      assert(old_select_lex == select_lex);
                                                                >                      assert(rewrite_select_lex == new_select_lex
                                                                >                      assert(rewrite_select_lex->master_unit()->i
                                                                >
                                                                >                      return new_item_single;
                                                                >                  }
                    assert(false);                              |                      return new Item_exists_subselect(new_select
        /*                                                      <
        TEST_TextMessageError(false ==                          <
                                i->field()->orig_table->alias_n <
                              "Can not mix CACHE_ITEM and table <
        const std::string table_name =                          <
            std::string(i->field()->orig_table->alias);         <
        const std::string field_name =                          <
            std::string(i->field()->field_name);                <
        OnionMeta *const om =                                   <
            a.getOnionMeta(table_name, field_name, oPLAIN);     <
        if (a.getOnionLevel(om) != SECLEVEL::PLAINVAL) {        <
            const FieldMeta *const fm =                         <
                a.getFieldMeta(table_name, field_name);         <
                                                                <
            throw OnionAdjustExcept(oPLAIN, fm, SECLEVEL::PLAIN <
                                    table_name);                <
        }                                                       <
                                                                <
        const EncSet out_es = PLAIN_EncSet;                     <
        tr = reason(out_es, "is cache item", i);                <
                                                                <
        return new RewritePlan(out_es, tr);                     <
        */                                                      <
                                                                <
        /*                                                      <
        Item *example = i->*rob<Item_cache, Item*, &Item_cache: <
        if (example)                                            <
            return gather(example, tr, a);                      <
        return tr.encset;                                       <
        UNIMPLEMENTED;                                          <
        return NULL;                                            <
        */                                                      <
    case SQLCOM_SET_OPTION:                                     |      // case SQLCOM_SET_OPTION:
    case SQLCOM_SHOW_TABLES:                                    <
                                                                >      case SQLCOM_SHOW_STORAGE_ENGINES:
                                                                >      case SQLCOM_SHOW_COLLATIONS:
static std::string                                              <
lex_to_query(LEX *const lex)                                    <
{                                                               <
    std::ostringstream o;                                       <
    o << *lex;                                                  <
    return o.str();                                             <
}                                                               <
                                                                <
                                                                >
                                                                >
                                                                >
                                                                >  static std::string serilize_OnionAdjustExcept(OnionAdjustExcept
                                                                >      //onion and level
                                                                >      std::string res;
                                                                >      if(e.o==oDET){
                                                                >         res+="oDET";
                                                                >      }else if(e.o==oOPE){
                                                                >          res+="oOPE";
                                                                >      }else if(e.o==oAGG){
                                                                >          res+="oAGG";
                                                                >      }else if(e.o==oSWP){
                                                                >          res+="oSWP";
                                                                >      }else if(e.o==oPLAIN){
                                                                >          res+="oPLAIN";
                                                                >      }else{
                                                                >          res+="NULLONION";
                                                                >      }
                                                                >      res+="::::";
                                                                >      if(e.tolevel==SECLEVEL::INVALID){
                                                                >          res+="INVALID";
                                                                >      }else if(e.tolevel==SECLEVEL::PLAINVAL){
                                                                >          res+="PLAINVAL";
                                                                >      }else if(e.tolevel==SECLEVEL::OPEFOREIGN){
                                                                >          res+="OPEFOREIGN";
                                                                >      }else if(e.tolevel==SECLEVEL::OPE){
                                                                >          res+="OPE";
                                                                >      }else if(e.tolevel==SECLEVEL::DETJOIN){
                                                                >          res+="DETJOIN";
                                                                >      }else if(e.tolevel==SECLEVEL::DET){
                                                                >          res+="DET";
                                                                >      }else if(e.tolevel==SECLEVEL::SEARCH){
                                                                >          res+="SEARCH";
                                                                >      }else if(e.tolevel==SECLEVEL::HOM){
                                                                >          res+="HOM";
                                                                >      }else if(e.tolevel==SECLEVEL::RND){
                                                                >          res+="RND";
                                                                >      }else{
                                                                >          res+="nulllevel";
                                                                >      }
                                                                >      return res;
                                                                >  }
                                                                >
                                                                >
RewriteOutput *                                                 |  AbstractQueryExecutor *
Rewriter::dispatchOnLex(Analysis &a, const ProxyState &ps,      |  Rewriter::dispatchOnLex(Analysis &a, const std::string &query)
                        const std::string &query)               <
    } catch (std::runtime_error &e) {                           |      } catch (const CryptDBError &e) {
        FAIL_TextMessageError("Bad Query: [" + query + "]\t"    |          FAIL_TextMessageError("Bad Query: [" + query + "]\n"
                              "Error Data: " + e.what());       |                                "Error Data: " + e.msg);
    LOG(cdb_v) << "pre-analyze " << *lex;                       <
                                                                <
        return new SimpleOutput(query);                         |          return new SimpleExecutor();
                                                                >          // HACK: We don't want to process INFORMATION_SCHEMA qu
                                                                >          if (SQLCOM_SELECT == lex->sql_command &&
                                                                >              lex->select_lex.table_list.first) {
                                                                >              const std::string &db = lex->select_lex.table_list.
                                                                >              if (equalsIgnoreCase("INFORMATION_SCHEMA", db)) {
                                                                >                  return new SimpleExecutor();
                                                                >              }
                                                                >          }
        AssignOnce<LEX *> out_lex;                              |          AssignOnce<AbstractQueryExecutor *> executor;
                                                                <
            out_lex = handler.transformLex(a, lex, ps);         |              executor = handler.transformLex(a, lex);
            std::cout << "Adjusting onion!" << std::endl;       |
                                                                >              //We use deltas to remove layers in the metadata, a
            std::vector<std::unique_ptr<Delta> > &deltas =      |              std::vector<std::unique_ptr<Delta> > &deltas = out_
                out_data.first;                                 |              const std::list<std::string> &adjust_queries = out_
            const std::list<std::string>  &adjust_queries =     <
                out_data.second;                                <
            std::function<std::string(const std::string &)>     <
                hackEscape = [&ps](const std::string &s)        <
            {                                                   <
                return escapeString(ps.getConn(), s);           <
            };                                                  <
            return new AdjustOnionOutput(query, std::move(delta <
                                         adjust_queries, hackEs <
        }                                                       <
        // Return if it's a regular DML query.                  |              return new OnionAdjustmentExecutor(std::move(deltas
        if (false == a.special_update) {                        |                                                 adjust_queries);
            return new DMLOutput(query, lex_to_query(out_lex.ge <
        }                                                       <
                                                                <
        // Handle HOMorphic UPDATE.                             <
        const auto plain_table =                                <
            lex->select_lex.top_join_list.head()->table_name;   <
        const auto crypted_table =                              <
            out_lex.get()->select_lex.top_join_list.head()->tab <
        std::string where_clause;                               <
        if (lex->select_lex.where) {                            <
            std::ostringstream where_stream;                    <
            where_stream << " " << *lex->select_lex.where << "  <
            where_clause = where_stream.str();                  <
        } else {                                                <
            where_clause = " TRUE ";                            <
                                                                |          //为什么两种情况返回的executor是不一样的?一个用了get一
        return new SpecialUpdate(query,  plain_table, crypted_t |          return executor.get();
                                 where_clause, a.getDatabaseNam <
        LEX *const out_lex = handler.transformLex(a, lex, ps);  |          AbstractQueryExecutor * executor ;
        // HACK.                                                |          try{
        const std::string &original_query =                     |              executor = handler.transformLex(a, lex);
            lex->sql_command != SQLCOM_LOCK_TABLES ? query : "d |          }catch(OnionAdjustExcept e){ 
                                                                |              // if an error occur in the first line of code, gdb
        return new DDLOutput(original_query, lex_to_query(out_l |              //We use deltas to remove layers in the metadata, a
                             std::move(a.deltas));              |              std::pair<std::vector<std::unique_ptr<Delta> >,
    } else {                                                    |                        std::list<std::string> >
        return NULL;                                            |                  out_data = adjustOnion(a, e.o, e.tm, e.fm, e.to
    }                                                           <
}                                                               <
                                                                <
struct DirectiveData {                                          <
    std::string table_name;                                     <
    std::string field_name;                                     <
    SECURITY_RATING sec_rating;                                 <
                                                                <
    DirectiveData(const std::string query)                      <
    {                                                           <
        std::list<std::string> tokens = split(query, " ");      <
        assert(tokens.size() == 4);                             <
        tokens.pop_front();                                     <
                                                                <
        table_name = tokens.front();                            <
        tokens.pop_front();                                     <
                                                                <
        field_name = tokens.front();                            <
        tokens.pop_front();                                     <
                                                                <
        sec_rating = TypeText<SECURITY_RATING>::toType(tokens.f <
        tokens.pop_front();                                     <
    }                                                           <
};                                                              <
                                                                <
// FIXME: Implement.                                            <
// SYNTAX                                                       <
// > DIRECTIVE UPDATE cryptdb_metadata                          <
//                SET <table_name | field_name | rating> = [val <
// > DIRECTIVE SELECT <table_name | field_name | rating>        <
//               FROM cryptdb_metadata                          <
//              WHERE <table_name | field_name | rating> = [val <
RewriteOutput *                                                 <
Rewriter::handleDirective(Analysis &a, const ProxyState &ps,    <
                          const std::string &query)             <
{                                                               <
    DirectiveData data(query);                                  <
    const FieldMeta &fm =                                       <
        a.getFieldMeta(a.getDatabaseName(), data.table_name,    <
                       data.field_name);                        <
    const SECURITY_RATING current_rating = fm.getSecurityRating <
    if (current_rating < data.sec_rating) {                     <
        FAIL_TextMessageError("cryptdb does not support going t <
                              " secure rating!");               <
    } else if (current_rating == data.sec_rating) {             <
        return new SimpleOutput(mysql_noop());                  <
    } else {                                                    <
        // Actually do things.                                  <
        FAIL_TextMessageError("implement handleDirective!");    <
    }                                                           <
}                                                               <
static                                                          |              std::string resadjust = serilize_OnionAdjustExcept(
bool                                                            |              std::cout<<"#######################################
cryptdbDirective(const std::string &query)                      |              std::vector<std::unique_ptr<Delta> > &deltas = out_
{                                                               |              const std::list<std::string> &adjust_queries = out_
    std::size_t found = query.find("DIRECTIVE");                |              return new OnionAdjustmentExecutor(std::move(deltas
    if (std::string::npos == found) {                           |                                                 adjust_queries);
        return false;                                           <
    }                                                           <
    for (std::size_t i = 0; i < found; ++i) {                   <
        if (!std::isspace(query[i])) {                          <
            return false;                                       <
                                                                >          return executor;
    return true;                                                |      return NULL;
Rewriter::rewrite(const ProxyState &ps, const std::string &q,   |  Rewriter::rewrite(const std::string &q, const SchemaInfo &schem
                  SchemaInfo const &schema,                     |                    const std::string &default_db, const ProxySta
                  const std::string &default_db)                <
    //assert(0 == create_embedded_thd(0));                      <
    Analysis analysis(default_db, schema);                      |      Analysis analysis(default_db, schema, ps.getMasterKey(),
                                                                >                        ps.defaultSecurityRating());
    RewriteOutput *output;                                      <
    if (cryptdbDirective(q)) {                                  <
        output = Rewriter::handleDirective(analysis, ps, q);    <
    } else {                                                    <
        output = Rewriter::dispatchOnLex(analysis, ps, q);      |      AbstractQueryExecutor *const executor =
        if (!output) {                                          |          Rewriter::dispatchOnLex(analysis, q);
            output = new SimpleOutput(mysql_noop());            |      if (!executor) {
        }                                                       |          return QueryRewrite(true, analysis.rmeta, analysis.kill
                                                                >                              new NoOpExecutor());       
                                                                |      return QueryRewrite(true, analysis.rmeta, analysis.kill_zon
    return QueryRewrite(true, analysis.rmeta, output);          <
                                                                <
                                                                >
                                                                >  //有了准备好的合适的meta以后, 对于ResType类型进来的加密数据, 可
                                                                >      //这个success是构造的时候写入的.
                                                                >      assert(dbres.success());
                                                                >
    LOG(cdb_v) << "rows in result " << rows << "\n";            <
    ResType res;                                                <
                                                                <
                                                                >      std::vector<std::string> dec_names;
                                                                >
                                                                >          //返回的匿名的名字, 一列下标从0开始.
                                                                >          //根据下标获得rfmeta
            res.names.push_back(rf.fieldCalled());              |              //存的时候, 不是salt, 已经存储了明文的名字.
            // switch types to original ones : TODO             |              dec_names.push_back(rf.fieldCalled());
                                                                <
    const unsigned int real_cols = res.names.size();            |      const unsigned int real_cols = dec_names.size();
    //allocate space in results for decrypted rows              |      //为每个数据行初始化指针空间
    res.rows = std::vector<std::vector<std::shared_ptr<Item> >  |      std::vector<std::vector<Item *> > dec_rows(rows);
        res.rows[i] = std::vector<std::shared_ptr<Item> >(real_ |          dec_rows[i] = std::vector<Item *>(real_cols);
                                                                |      //
    // decrypt rows                                             <
                                                                |          //获得key, 存在fieldMeta中
                                                                >
                                                                >
                res.rows[r][col_index] = dbres.rows[r][c];      |                  dec_rows[r][col_index] = dbres.rows[r][c];
                                                                >                  //如果存在salt, 则读取远端的salt值, 转化以后用
                        static_cast<Item_int *>(dbres.rows[r][s |                          static_cast<Item_int *>(dbres.rows[r][s
                                                                |                  //层次化的解密.
                std::shared_ptr<Item> dec_item(                 |                  dec_rows[r][col_index] = 
                    decrypt_item_layers(dbres.rows[r][c].get(), |                      decrypt_item_layers(*dbres.rows[r][c],
                                        fm, rf.getOLK().o, salt |                                          fm, rf.getOLK().o, salt
                res.rows[r][col_index] = dec_item;              <
    return res;                                                 |      //加密和解密之前之后, 用的都是ResType类型.通过这个解密函数
                                                                >      return ResType(dbres.ok, dbres.affected_rows, dbres.insert_
                                                                >                     std::move(dec_names),
                                                                >                     std::vector<enum_field_types>(dbres.types),
                                                                >                     std::move(dec_rows));
static ResType                                                  <
mysql_noop_res(const ProxyState &ps)                            <
{                                                               <
    std::unique_ptr<DBResult> noop_dbres;                       <
    assert(ps.getConn()->execute(mysql_noop(), &noop_dbres));   <
    return ResType(noop_dbres->unpack());                       <
}                                                               <
                                                                <
EpilogueResult                                                  <
executeQuery(const ProxyState &ps, const std::string &q,        <
             const std::string &default_db,                     <
             SchemaCache *const schema_cache, bool pp)          <
{                                                               <
    assert(schema_cache);                                       <
                                                                <
    std::unique_ptr<QueryRewrite> qr;                           <
    // out_queryz: queries intended to be run against remote se <
    std::list<std::string> out_queryz;                          <
    queryPreamble(ps, q, &qr, &out_queryz, schema_cache, defaul <
    assert(qr);                                                 <
                                                                <
    std::unique_ptr<DBResult> dbres;                            <
    for (auto it : out_queryz) {                                <
        if (true == pp) {                                       <
            prettyPrintQuery(it);                               <
        }                                                       <
                                                                <
        TEST_Sync(ps.getConn()->execute(it, &dbres,             <
                                    qr->output->multipleResultS <
                  "failed to execute query!");                  <
        // XOR: Either we have one result set, or we were expec <
        // multiple result sets and we threw them all away.     <
        assert(!!dbres != !!qr->output->multipleResultSets());  <
    }                                                           <
                                                                <
    // ----------------------------------                       <
    //       Post Query Processing                              <
    // ----------------------------------                       <
    const ResType &res =                                        <
        dbres ? ResType(dbres->unpack()) : mysql_noop_res(ps);  <
    assert(res.success());                                      <
    const EpilogueResult epi_result =                           <
        queryEpilogue(ps, *qr.get(), res, q, default_db, pp);   <
    assert(epi_result.res_type.success());                      <
                                                                <
    return epi_result;                                          <
}                                                               <
                                                                <
    //if (!cryptdb_logger::enabled(log_group::log_edb_v))       <
    //return;                                                   <
                                                                <
    std::cerr << ssn.str() << std::endl;                        |      std::cerr << terminalEscape(ssn.str()) << std::endl;
        std::cerr << ss.str() << std::endl;                     |          std::cerr << terminalEscape(ss.str()) << std::endl;
        //LOG(edb_v) << ss.str();                               <
    EncLayer *const out_layer = duped_layers.back();            |      EncLayer &out_layer = *duped_layers.back();
    return *out_layer;                                          |      return out_layer;
                                                                >      
    auto const &enc_layers = om.layers;                         |      auto const &enc_layers = om.getLayers();
    for (auto it = enc_layers.begin(); it != enc_layers.end();  |      for (const auto &it : enc_layers) {
        v.push_back((*it).get());                               |          v.push_back(it.get());
                                                                >
                                                                >
                                                                >  //Write delta into the local meta database to remove layers, is
                                                                >  std::pair<AbstractQueryExecutor::ResultType, AbstractAnything *
                                                                >  OnionAdjustmentExecutor::
                                                                >  nextImpl(const ResType &res, const NextParams &nparams)
                                                                >  {
                                                                >      reenter(this->corot) {
                                                                >          yield {
                                                                >              assert(this->adjust_queries.size() == 1
                                                                >                     || this->adjust_queries.size() == 2);
                                                                >
                                                                >              {
                                                                >                  uint64_t embedded_completion_id;
                                                                >                  deltaOutputBeforeQuery(nparams.ps.getEConn(),
                                                                >                                         nparams.original_query, 
                                                                >                                         this->deltas,
                                                                >                                         CompletionType::Onion,
                                                                >                                         &embedded_completion_id)
                                                                >                  this->embedded_completion_id = embedded_complet
                                                                >              }
                                                                >
                                                                >              return CR_QUERY_AGAIN(
                                                                >                  "CALL " + MetaData::Proc::activeTransactionP())
                                                                >          }
                                                                >          TEST_ErrPkt(res.success(),
                                                                >                      "failed to determine if there is an active 
                                                                >          this->in_trx = handleActiveTransactionPResults(res);
                                                                >
                                                                >          // always rollback
                                                                >          yield return CR_QUERY_AGAIN("ROLLBACK");
                                                                >          TEST_ErrPkt(res.success(), "failed to rollback");
                                                                >
                                                                >          yield return CR_QUERY_AGAIN("START TRANSACTION");
                                                                >          TEST_ErrPkt(res.success(), "failed to start transaction
                                                                >
                                                                >          // issue first adjustment
                                                                >          yield return CR_QUERY_AGAIN(this->adjust_queries.front(
                                                                >          CR_ROLLBACK_AND_FAIL(res,
                                                                >                          "failed to execute first onion adjustme
                                                                >
                                                                >          // issue (possible) second adjustment
                                                                >          yield {
                                                                >              assert(res.success());
                                                                >
                                                                >              return CR_QUERY_AGAIN(
                                                                >                      this->adjust_queries.size() == 2 ? this->ad
                                                                >                                                       : "DO 0;")
                                                                >          }
                                                                >          CR_ROLLBACK_AND_FAIL(res,
                                                                >                          "failed to execute second onion adjustm
                                                                >
                                                                >          yield {
                                                                >              return CR_QUERY_AGAIN(
                                                                >                  " INSERT INTO " + MetaData::Table::remoteQueryC
                                                                >                  "   (embedded_completion_id, completion_type) V
                                                                >                  "   (" + std::to_string(this->embedded_completi
                                                                >                  "   '"+TypeText<CompletionType>::toText(Complet
                                                                >                  "        );");
                                                                >          }
                                                                >          TEST_ErrPkt(res.success(), "failed issuing adjustment c
                                                                >
                                                                >          yield return CR_QUERY_AGAIN("COMMIT");
                                                                >          TEST_ErrPkt(res.success(), "failed to commit");
                                                                >
                                                                >          TEST_ErrPkt(deltaOutputAfterQuery(nparams.ps.getEConn()
                                                                >                                            this->embedded_comple
                                                                >                      "deltaOutputAfterQuery failed for onion adj
                                                                >
                                                                >          // if the client was in the middle of a transaction we 
                                                                >          // him that we had to rollback his queries
                                                                >          if (true == this->in_trx.get()) {
                                                                >              ROLLBACK_ERROR_PACKET
                                                                >          }
                                                                >
                                                                >          try {
                                                                >              this->reissue_query_rewrite = new QueryRewrite(
                                                                >                  Rewriter::rewrite(
                                                                >                      nparams.original_query, *nparams.ps.getSche
                                                                >                      nparams.default_db, nparams.ps));
                                                                >          } catch (const AbstractException &e) {
                                                                >              FAIL_GenericPacketException(e.to_string());
                                                                >          } catch (...) {
                                                                >              FAIL_GenericPacketException(
                                                                >                  "unknown error occured while rewriting onion ad
                                                                >          }
                                                                >
                                                                >          this->reissue_nparams =
                                                                >              NextParams(nparams.ps, nparams.default_db, nparams.
                                                                >          while (true) {
                                                                >              yield {
                                                                >                  auto result =
                                                                >                      this->reissue_query_rewrite->executor->next
                                                                >                          first_reissue ? ResType(true, 0, 0)
                                                                >                                        : res,
                                                                >                          reissue_nparams.get());
                                                                >                  this->first_reissue = false;
                                                                >                  return result;
                                                                >              }
                                                                >          }
                                                                >      }
                                                                >      assert(false);
                                                                >  }
                                                                >
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/rewrite_main.hh Practical-Cryptdb/main/rewrite_main.hh
                                                                >  #include <exception>
#include <parser/Annotation.hh>                                 |  //#include <parser/Annotation.hh>
                                                                >  #include <util/util.hh>
                                                                >  #include <util/onions.hh>
                                                                >
                                                                >  class CrashTestException: public std::exception {};
                                                                >
    QueryRewrite(bool wasRes, ReturnMeta rmeta, RewriteOutput * |      QueryRewrite(bool wasRes, ReturnMeta rmeta, const KillZone 
        : rmeta(rmeta), output(std::unique_ptr<RewriteOutput>(o |                   AbstractQueryExecutor *const executor)
                                                                >          : rmeta(rmeta), kill_zone(kill_zone),
                                                                >            executor(std::unique_ptr<AbstractQueryExecutor>(execu
        output(std::move(other_qr.output)) {}                   |          executor(std::move(other_qr.executor)) {}
    std::unique_ptr<RewriteOutput> output;                      |      const KillZone kill_zone;
                                                                >      std::unique_ptr<AbstractQueryExecutor> executor;
                                                                <
        rewrite(const ProxyState &ps, const std::string &q,     |          rewrite(const std::string &q, SchemaInfo const &schema,
                SchemaInfo const &schema, const std::string &de |                  const std::string &default_db,
                                                                >                  const ProxyState &ps);
                                                                >
    static RewriteOutput *                                      |      static AbstractQueryExecutor *
        dispatchOnLex(Analysis &a, const ProxyState &ps,        |          dispatchOnLex(Analysis &a, const std::string &query);
                      const std::string &query);                <
    static RewriteOutput *                                      <
        handleDirective(Analysis &a, const ProxyState &ps,      <
                        const std::string &query);              <
class SchemaCache;                                              <
class EpilogueResult;                                           <
EpilogueResult                                                  <
executeQuery(const ProxyState &ps, const std::string &q,        <
             const std::string &default_db,                     <
             SchemaCache *const schema_cache, bool pp=true);    <
                                                                <
        throw std::runtime_error(std::string("Unimplemented: ") |      FAIL_TextMessageError(std::string("Unimplemented: ") +     
class reason;                                                   <
                                                                >  //this is cryptdb type. 
                                                                >      //add things to types, the map
                                                                |      //take a mysql type and return the conresponding cryptdb ty
                                                                >      //map cryptdb type to mysql type
    CItemSubtypeIT() { itemTypes.reg(TYPE, *this); }            |      CItemSubtypeIT() {
                                                                >        itemTypes.reg(TYPE, *this); 
                                                                >      }
    CItemSubtypeFT() { funcTypes.reg(TYPE, *this); }            |      CItemSubtypeFT() { 
                                                                >       funcTypes.reg(TYPE, *this); 
                                                                >      }
    CItemSubtypeST() { sumFuncTypes.reg(TYPE, *this); }         |      CItemSubtypeST() {
                                                                >          sumFuncTypes.reg(TYPE, *this); 
                                                                >      }
    CItemSubtypeFN() { funcNames.reg(std::string(TYPE), *this); |      CItemSubtypeFN() { 
                                                                >          funcNames.reg(std::string(TYPE), *this); 
                                                                >      }
SchemaInfo *                                                    |
                                                                >  std::unique_ptr<SchemaInfo>
                                                                >
                                                                >  class OnionAdjustmentExecutor : public AbstractQueryExecutor {
                                                                >      const std::vector<std::unique_ptr<Delta> > deltas;
                                                                >      const std::list<std::string> adjust_queries;
                                                                >
                                                                >      // coroutine state
                                                                >      bool first_reissue;
                                                                >      AssignOnce<std::shared_ptr<const SchemaInfo> > reissue_sche
                                                                >      AssignOnce<uint64_t> embedded_completion_id;
                                                                >      AssignOnce<bool> in_trx;
                                                                >      QueryRewrite *reissue_query_rewrite;
                                                                >      AssignOnce<NextParams> reissue_nparams;
                                                                >
                                                                >  public:
                                                                >      OnionAdjustmentExecutor(std::vector<std::unique_ptr<Delta> 
                                                                >                              const std::list<std::string> &adjus
                                                                >          : deltas(std::move(deltas)),
                                                                >            adjust_queries(adjust_queries), first_reissue(true) {
                                                                >
                                                                >      std::pair<ResultType, AbstractAnything *>
                                                                >          nextImpl(const ResType &res, const NextParams &nparams)
                                                                >
                                                                >  private:
                                                                >      bool stales() const {return true;}
                                                                >      bool usesEmbedded() const {return true;}
                                                                >  };
                                                                >
                                                                >
                                                                >
                                                                >
                                                                >
                                                                >
                                                                >  std::pair<std::vector<std::unique_ptr<Delta> >,
                                                                >                   std::list<std::string>>
                                                                >  adjustOnion(const Analysis &a, onion o, const TableMeta &tm,
                                                                >              const FieldMeta &fm, SECLEVEL tolevel);
                                                                >
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/rewrite_sum.cc Practical-Cryptdb/main/rewrite_sum.cc
                                                                >          // FIXME: this test is correct; but the higher level co
                                                                >          // to act properly first
                                                                >          // TEST_Text(rp.olk.o == constr.o && rp.olk.l == constr
                                                                >                    // "summation arguments do not match constrai
                                                                >  // FIXME: this must be reworked such that constr and the child 
                                                                >  // align properly in do_rewrite_type(...)
        const EncSet out = EncSet(olk);                         |          const reason rsn(supported, why, i);
        const reason rsn(out, why, i);                          <
        // INVESTIGATE: Should 'out' be 'supported'?            |          return new RewritePlanOneOLK(supported, olk, childr_rp,
        return new RewritePlanOneOLK(out, olk, childr_rp, rsn); <
        const EncSet my_es = ADD_EncSet;                        |          const EncSet &my_es = ADD_EncSet;
        const EncSet solution = my_es.intersect(childr_rp[0]->e |          const EncSet &solution = my_es.intersect(childr_rp[0]->
        const std::string why = "summation";                    |          const std::string &why = "summation";
        const OLK olk = solution.chooseOne();                   |          reason rsn(solution, why, i);
        const EncSet return_es = EncSet(olk);                   |          return new RewritePlanWithChildren(solution, rsn, child
        const reason rsn(return_es, why, i);                    <
                                                                <
        return new RewritePlanOneOLK(return_es, olk, childr_rp, <
                                                                >          auto rp_wc = static_cast<const RewritePlanWithChildren 
                                                                >          assert(rp_wc.childr_rp.size() == 1);
                                                                >
        std::list<Item *> args =                                |          TEST_Text(rp.es_out.contains(constr),
            rewrite_agg_args(i, constr,                         |            "summation cannot support it's argument");
                             static_cast<const RewritePlanOneOL |
                             a, 1);                             |          a.summation_hack = true;
                                                                >          Item *const new_child =
                                                                >              itemTypes.do_rewrite(*RiboldMYSQL::get_arg(i, 0), c
                                                                >                                   *rp_wc.childr_rp[0].get(), a);
                                                                >          a.summation_hack = false;
                                                                >          assert(new_child);
            return static_cast<const HOM &>(el).sumUDA(args.fro |              return static_cast<const HOM &>(el).sumUDA(new_chil
            Item *const new_arg =                               |              // FIXME: we cannot blindly return Item_sum_sum bec
                RiboldMYSQL::clone_item(*RiboldMYSQL::get_arg(i |              // have an AVG(...)
            return new Item_sum_sum(new_arg, i.has_with_distinc |              // > account for ``Item_sum_avg''
                                                                >              return new Item_sum_sum(new_child, i.has_with_disti
static CItemSum<Item_sum::Sumfunctype::AVG_FUNC> ANON;          |  //static CItemSum<Item_sum::Sumfunctype::AVG_FUNC> ANON;
static CItemSum<Item_sum::Sumfunctype::AVG_DISTINCT_FUNC> ANON; |  //static CItemSum<Item_sum::Sumfunctype::AVG_DISTINCT_FUNC> ANO
                                                                >
                                                                >
                                                                >  template<Item_sum::Sumfunctype SFT>
                                                                >  class CItemAvg : public CItemSubtypeST<Item_sum_sum, SFT> {
                                                                >      virtual RewritePlan *
                                                                >      do_gather_type(const Item_sum_sum &i, Analysis &a) const
                                                                >      {
                                                                >          LOG(cdb_v) << "gather Item_sum_sum " << i << std::endl;
                                                                >
                                                                >          const unsigned int arg_count = RiboldMYSQL::get_arg_cou
                                                                >          TEST_BadItemArgumentCount(i.type(), 1, arg_count);
                                                                >          const Item *const child_item = RiboldMYSQL::get_arg(i, 
                                                                >
                                                                >          std::vector<std::shared_ptr<RewritePlan> >
                                                                >              childr_rp({std::shared_ptr<RewritePlan>(gather(*chi
                                                                >                                                             a))}
                                                                >
                                                                >          if (i.has_with_distinct()) {
                                                                >              UNIMPLEMENTED;
                                                                >          }
                                                                >
                                                                >          const EncSet &my_es = ADD_EncSet;
                                                                >          const EncSet &solution = my_es.intersect(childr_rp[0]->
                                                                >          const std::string &why = "summation";
                                                                >          TEST_NoAvailableEncSet(solution, i.type(), my_es, why,
                                                                >                                 childr_rp);
                                                                >
                                                                >          reason rsn(solution, why, i);
                                                                >          return new RewritePlanWithChildren(solution, rsn, child
                                                                >      }
                                                                >
                                                                >      virtual Item *
                                                                >      do_rewrite_type(const Item_sum_sum &i, const OLK &constr,
                                                                >                      const RewritePlan &rp, Analysis &a) const
                                                                >      {
                                                                >          auto rp_wc = static_cast<const RewritePlanWithChildren 
                                                                >          assert(rp_wc.childr_rp.size() == 1);
                                                                >
                                                                >          TEST_Text(rp.es_out.contains(constr),
                                                                >            "summation cannot support it's argument");
                                                                >          std::cout<<"avg!!!!!!!!"<<std::endl;
                                                                >          a.summation_hack = true;
                                                                >          Item *const new_child =
                                                                >              itemTypes.do_rewrite(*RiboldMYSQL::get_arg(i, 0), c
                                                                >                                   *rp_wc.childr_rp[0].get(), a);
                                                                >          a.summation_hack = false;
                                                                >          assert(new_child);
                                                                >
                                                                >          if (oAGG == constr.o) {
                                                                >              OnionMeta *const om = constr.key->getOnionMeta(oAGG
                                                                >              assert(om);
                                                                >              EncLayer const &el = a.getBackEncLayer(*om);
                                                                >              TEST_UnexpectedSecurityLevel(oAGG, SECLEVEL::HOM,
                                                                >                                           el.level());
                                                                >              return static_cast<const HOM &>(el).sumUDA(new_chil
                                                                >          } else {
                                                                >              TEST_UnexpectedSecurityLevel(constr.o, SECLEVEL::PL
                                                                >                                           constr.l);
                                                                >
                                                                >              // FIXME: we cannot blindly return Item_sum_sum bec
                                                                >              // have an AVG(...)
                                                                >              // > account for ``Item_sum_avg''
                                                                >              return new Item_sum_sum(new_child, i.has_with_disti
                                                                >          }
                                                                >      }
                                                                >  };
                                                                >
                                                                >  static CItemAvg<Item_sum::Sumfunctype::AVG_FUNC> ANON;
                                                                >  static CItemAvg<Item_sum::Sumfunctype::AVG_DISTINCT_FUNC> ANON;
                                                                >
                                                                >
                                                                >
        // HACK.                                                |          // SUPPORT
                                                                >          TEST_Text(Item::Type::FIELD_ITEM == (*i.ref)->type(),
                                                                >                    "Item_ref is not a field; no support");
        const std::string anon_table =                          |          const std::string &anon_table =
        for (uint j = 0; j < fm.children.size(); ++j) {         |          for (uint j = 0; j < fm.getChildren().size(); ++j) {
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/rewrite_util.cc Practical-Cryptdb/main/rewrite_util.cc
                                                                >  #include <main/schema.hh>
/*Item *i0 = itemTypes.do_optimize(*i, a);                      <
    if (i0 != *i) {                                             <
        // item i was optimized (replaced) by i0                <
        if (a.itemRewritePlans.find(*i) != a.itemRewritePlans.e <
            a.itemRewritePlans[i0] = a.itemRewritePlans[*i];    <
            a.itemRewritePlans.erase(*i);                       <
        }                                                       <
        *i = i0;                                                <
    } */                                                        <
rewrite(const Item &i, const EncSet &req_enc, Analysis &a)      |  rewrite(const Item &i, const EncSet &req_enc, Analysis &a) {
{                                                               <
rewrite_table_list(const TABLE_LIST * const t, const Analysis & |  rewrite_table_list(const TABLE_LIST * const t, const Analysis &
{                                                               <
                                                                >
rewrite_table_list(List<TABLE_LIST> tll, Analysis &a)           |  rewrite_table_list(List<TABLE_LIST> tll, Analysis &a) {
{                                                               <
                                                                <
        /* TODO: derived tables                                 <
        if (t->derived) {                                       <
            st_select_lex_unit *u = t->derived;                 <
            rewrite_select_lex(u->first_select(), a);           <
        }                                                       <
        */                                                      <
    LOG(cdb_v) << "calling gather for item " << i << std::endl; <
LEX *                                                           |  std::vector<std::tuple<std::vector<std::string>, Key::Keytype> 
begin_transaction_lex(const std::string &dbname)                |  collectKeyData(const LEX &lex)
    static const std::string query = "START TRANSACTION;";      |      std::vector<std::tuple<std::vector<std::string>, Key::Keyty
    query_parse *const begin_parse = new query_parse(dbname, qu |
    return begin_parse->lex();                                  |      auto key_it =
                                                                >          RiboldMYSQL::constList_iterator<Key>(lex.alter_info.key
                                                                >      for (;;) {
                                                                >          const Key *const key = key_it++;
                                                                >          if (nullptr == key) {
                                                                >              break;
LEX *                                                           |          // collect columns
commit_transaction_lex(const std::string &dbname)               |          std::vector<std::string> columns;
{                                                               |          auto col_it =
    static const std::string query = "COMMIT;";                 |              RiboldMYSQL::constList_iterator<Key_part_spec>(key-
    query_parse *const commit_parse = new query_parse(dbname, q |          for (;;) {
    return commit_parse->lex();                                 |              const Key_part_spec *const key_part = col_it++;
                                                                >              if (nullptr == key_part) {
                                                                >                  break;
                                                                >              }
                                                                >
                                                                >              columns.push_back(convert_lex_str(key_part->field_n
                                                                >          }
                                                                >
                                                                >          output.push_back(std::make_tuple(columns, key->type));
                                                                >      }
                                                                >
                                                                >      return output;
    f->def = NULL;                                              |      f->def = nullptr;
    for (auto it = enc_layers.begin(); it != enc_layers.end();  |      for (const auto &it : enc_layers) {
        new_cf = (*it)->newCreateField(old_cf, name);           |          new_cf = it->newCreateField(*old_cf, name);
    assert(fm->children.size() > 0);                            |      assert(fm->getChildren().size() > 0);
        // > NOT_NULL_FLAG is useful for debugging if mysql str |          // > salt can only be NOT NULL if column is NOT NULL
        //   (ie, STRICT_ALL_TABLES) is turned on.              |          f0->flags               = (f0->flags | UNSIGNED_FLAG)
        f0->flags               =                               <
            (f0->flags | UNSIGNED_FLAG | NOT_NULL_FLAG)         <
                                                                >      //for(auto item:output_cfields){
                                                                >      //}
getOriginalKeyName(Key *const key)                              |  getOriginalKeyName(const Key &key)
    if (Key::PRIMARY == key->type) {                            |      if (Key::PRIMARY == key.type) {
    const std::string out_name = convert_lex_str(key->name);    |      std::string out_name = convert_lex_str(key.name);
    TEST_TextMessageError(out_name.size() > 0,                  |
                          "Non-Primary keys can not have blank  |      //TEST_TextMessageError(out_name.size() > 0,
                                                                >      //                      "Non-Primary keys can not have blan
                                                                >      if(out_name.size()==0){
                                                                >          out_name="nonekey";
                                                                >      }
std::vector<Key *>                                              |  /*
rewrite_key(const TableMeta &tm, Key *const key, const Analysis |  static std::vector<Key *>
                                                                >  rewrite_key(const TableMeta &tm, const Key &key, const Analysis
                                                                >      //从左到右分别是三种类型: oOPE, oDET, oPLAIN, 对于每个语句
                                                                >      //比如自己要alter table add 的index, 其对应index的名字, 以
                                                                >      //比如create的时候, 产生的index, 其对应的名字以及相关的colu
        Key *const new_key = key->clone(current_thd->mem_root); |          THD* cthd = current_thd;
                                                                |          //原始key的拷贝
                                                                >          Key *const new_key = key.clone(cthd->mem_root);
                                                                >          //通过key的原始名字+onion+tm哈希获得新的key名字,用的是s
                                                                >          //设置key的新名字, 以及新的key对应的column清空??
                                                                >          //遍历原始的key的columns, 改写, 变成新key的colukns
            RiboldMYSQL::constList_iterator<Key_part_spec>(key- |              RiboldMYSQL::constList_iterator<Key_part_spec>(key.
                                                                |              //复制一个column信息
                                                                >              //原始的key_part, 也就是一个column, 里面取一个field
                                                                >              //通过column查tablemeta, 然后差当前的onion在不在那
                                                                |              //如果存在, 那么新的column的名字就是洋葱的名字, 然
                                                                >              //可以看到, 对于索引里面的每个field, 都选择一个洋葱
                                                                >      //上面, 对于一个key来说, 可以查三个洋葱
                                                                >      //对于每个洋葱,都可能构造一个key, 这是根据这个key对应的colu
                                                                >      //主键特殊处理, 之根据一个洋葱构造.
    if (Key::PRIMARY == key->type) {                            |      if (Key::PRIMARY == key.type) {
                                                                >  */
                                                                >
                                                                >
                                                                >  /*
                                                                >  only rewrite normal keys here, do not process foreign keys.
                                                                >
                                                                >  */
                                                                >  static std::vector<Key *>
                                                                >  rewrite_key1(const TableMeta &tm, const Key &key, const Analysi
                                                                >
                                                                >      //leave foreign key unchanged
                                                                >      std::vector<Key *> output_keys;
                                                                >      if(key.type==Key::FOREIGN_KEY){
                                                                >          THD* cthd = current_thd;
                                                                >          Key *const new_key = key.clone(cthd->mem_root);
                                                                >          output_keys.push_back(new_key);
                                                                >          return output_keys;
                                                                >      }
                                                                >
                                                                >      //从左到右分别是三种类型: oOPE, oDET, oPLAIN, 对于每个语句
                                                                >      //比如自己要alter table add 的index, 其对应index的名字, 以
                                                                >      //比如create的时候, 产生的index, 其对应的名字以及相关的colu
                                                                >      const std::vector<onion> key_onions = getOnionIndexTypes();
                                                                >      for (auto onion_it : key_onions) {
                                                                >          const onion o = onion_it;
                                                                >          THD* cthd = current_thd;
                                                                >          //原始key的拷贝
                                                                >          Key *const new_key = key.clone(cthd->mem_root);
                                                                >          //通过key的原始名字+onion+tm哈希获得新的key名字,用的是s
                                                                >          // Set anonymous name.
                                                                >          const std::string new_name =
                                                                >              a.getAnonIndexName(tm, getOriginalKeyName(key), o);
                                                                >          //设置key的新名字, 以及新的key对应的column清空??
                                                                >          new_key->name = string_to_lex_str(new_name);
                                                                >          new_key->columns.empty();
                                                                >
                                                                >          //遍历原始的key的columns, 改写, 变成新key的colukns
                                                                >          // Set anonymous columns.
                                                                >          auto col_it =
                                                                >              RiboldMYSQL::constList_iterator<Key_part_spec>(key.
                                                                >          for (;;) {
                                                                >              const Key_part_spec *const key_part = col_it++;
                                                                >              if (NULL == key_part) {
                                                                >                  output_keys.push_back(new_key);
                                                                >                  break;
                                                                >              }
                                                                >              //复制一个column信息
                                                                >              Key_part_spec *const new_key_part = copyWithTHD(key
                                                                >              //原始的key_part, 也就是一个column, 里面取一个field
                                                                >              const std::string field_name =
                                                                >                  convert_lex_str(new_key_part->field_name);
                                                                >              //通过column查tablemeta, 然后差当前的onion在不在那
                                                                >              // > the onion may not exist; ie oPLAIN with SENSIT
                                                                >              // an AUTO INCREMENT column
                                                                >              const FieldMeta &fm = a.getFieldMeta(tm, field_name
                                                                >              const OnionMeta *const om = fm.getOnionMeta(o);
                                                                >              if (NULL == om) {
                                                                >                  break;
                                                                >              }
                                                                >              //如果存在, 那么新的column的名字就是洋葱的名字, 然
                                                                >              //可以看到, 对于索引里面的每个field, 都选择一个洋葱
                                                                >              new_key_part->field_name =
                                                                >                  string_to_lex_str(om->getAnonOnionName());
                                                                >              new_key->columns.push_back(new_key_part);
                                                                >          }
                                                                >      }
                                                                >
                                                                >      //上面, 对于一个key来说, 可以查三个洋葱
                                                                >      //对于每个洋葱,都可能构造一个key, 这是根据这个key对应的colu
                                                                >      //主键特殊处理, 之根据一个洋葱构造.
                                                                >      // Only create one PRIMARY KEY.
                                                                >      if (Key::PRIMARY == key.type) {
                                                                >          if (output_keys.size() > 0) {
                                                                >              return std::vector<Key *>({output_keys.front()});
                                                                >          }
                                                                >      }
                                                                >      return output_keys;
                                                                >  }
                                                                >
                                                                >
                                                                >
                                                                >
                                                                >  // 'seed_lex' and 'out_lex' can be the same object.
                                                                >  void
                                                                >  highLevelRewriteKey(const TableMeta &tm, const LEX &seed_lex,
                                                                >                      LEX *const out_lex, const Analysis &a){
                                                                >      assert(out_lex);
                                                                >
                                                                >      // Add each new index.
                                                                >      auto key_it =
                                                                >          List_iterator<Key>(const_cast<LEX &>(seed_lex).alter_in
                                                                >      out_lex->alter_info.key_list =
                                                                >          accumList<Key>(key_it,
                                                                >              [&tm, &a] (List<Key> out_list, const Key *const key
                                                                >                  // -----------------------------
                                                                >                  //         Rewrite INDEX
                                                                >                  // -----------------------------
                                                                >                  auto new_keys = rewrite_key1(tm, *key, a);
                                                                >                  out_list.concat(vectorToListWithTHD(new_keys));
                                                                >
                                                                >                  return out_list;
                                                                >          });
                                                                >
                                                                >      return;
                                                                >  }
                                                                >
                                                                >  void 
                                                                >  highLevelRewriteForeignKey(const TableMeta &tm, const LEX &seed
                                                                >              LEX *const out_lex, const Analysis &a,std::string t
                                                                >      std::string dbname = a.getDatabaseName();
                                                                >      auto it =
                                                                >               List_iterator<Key>(out_lex->alter_info.key_list);
                                                                >      std::vector<Key *> output_keys;
                                                                >
                                                                >      while(auto cur = it++){
                                                                >          if(cur->type== Key::FOREIGN_KEY){
                                                                >             THD* cthd = current_thd;
                                                                >              //process current names
                                                                >              Key* const new_key = cur->clone(cthd->mem_root);
                                                                >              std::string new_name = "newfkname";
                                                                >              new_key->name = string_to_lex_str(new_name);
                                                                >
                                                                >              //process current columns
                                                                >              auto col_it_cur = List_iterator<Key_part_spec>((cur
                                                                >
                                                                >              new_key->columns.empty();
                                                                >
                                                                >              while(1){
                                                                >                  const Key_part_spec *const key_part = col_it_cu
                                                                >                  if(NULL == key_part){
                                                                >                      break;
                                                                >                  }
                                                                >                  Key_part_spec *const new_key_part = copyWithTHD
                                                                >                  std::string field_name =
                                                                >                  convert_lex_str(new_key_part->field_name);
                                                                >                  //get current field name, and then replace it w
                                                                >                  //currently we choose det onion, without caring
                                                                >                  //OnionMeta *om = a.getOnionMeta2(dbname,tbname
                                                                >                  OnionMeta *om = tm.getChild(IdentityMetaKey(fie
                                                                >                  assert(om!=NULL);                
                                                                >                  field_name=om->getAnonOnionName();
                                                                >                  new_key_part->field_name = string_to_lex_str(fi
                                                                >                  new_key->columns.push_back(new_key_part);
                                                                >              }
                                                                >
                                                                >              //process ref tables
                                                                >              Table_ident* ref_table = ((Foreign_key*)cur)->ref_t
                                                                >
                                                                >              std::string ref_table_name = std::string(ref_table-
                                                                >              TableMeta &rtm = a.getTableMeta(a.getDatabaseName()
                                                                >
                                                                >              std::string ref_table_annoname = rtm.getAnonTableNa
                                                                >              ref_table->table = string_to_lex_str(ref_table_anno
                                                                >
                                                                >              //process ref columns
                                                                >              auto col_it =
                                                                >              List_iterator<Key_part_spec>(((Foreign_key*)cur)->r
                                                                >              ((Foreign_key*)new_key)->ref_columns.empty();
                                                                >              while(1){
                                                                >                  const Key_part_spec *const key_part = col_it++;
                                                                >                  if(NULL == key_part){
                                                                >                      break;
                                                                >                  }
                                                                >                  Key_part_spec *const new_key_part = copyWithTHD
                                                                >                  std::string field_name =
                                                                >                  convert_lex_str(new_key_part->field_name);
                                                                >                  //update field name here
                                                                >                  OnionMeta * om = a.getOnionMeta2(dbname,ref_tab
                                                                >                  assert(om!=NULL);
                                                                >                  field_name=om->getAnonOnionName();
                                                                >                  new_key_part->field_name = string_to_lex_str(fi
                                                                >                  ((Foreign_key*)new_key)->ref_columns.push_back(
                                                                >              }
                                                                >              output_keys.push_back(new_key);
                                                                >          }else{
                                                                >              THD* cthd = current_thd;
                                                                >              Key* const new_key = cur->clone(cthd->mem_root);
                                                                >              output_keys.push_back(new_key);
                                                                >          }
                                                                >      }
                                                                >         
                                                                >      out_lex->alter_info.key_list = *vectorToListWithTHD(output_
                                                                >     
                                                                >
                                                                >  }
                                                                >
                                                                >
                                                                >
                                                                >  static bool
                                                                >  isUnique(const std::string &name,
                                                                >           const std::vector<std::tuple<std::vector<std::string>,
                                                                >               key_data)
                                                                >  {
                                                                >      bool unique = false;
                                                                >      for (const auto &it : key_data) {
                                                                >          const auto &found =
                                                                >              std::find(std::get<0>(it).begin(), std::get<0>(it).
                                                                >          if (found != std::get<0>(it).end()
                                                                >              && (std::get<1>(it) == Key::PRIMARY || std::get<1>(
                                                                >              unique = true;
                                                                >              break;
                                                                >          }
                                                                >      }
                                                                >
                                                                >      return unique;
                                                                >  }
                                                                >
                                                                >
                                                                >  //from one filed to multiple fields. the fields are automatical
createAndRewriteField(Analysis &a, const ProxyState &ps,        |  createAndRewriteField(Analysis &a, Create_field * const cf,
                      Create_field * const cf,                  <
                                                                >                        const std::vector<std::tuple<std::vector<
                                                                >                                          Key::Keytype> >
                                                                >                            &key_data,
    const std::string name = std::string(cf->field_name);       |      // we only support the creation of UNSIGNED fields
    auto buildFieldMeta =                                       |      //add this to support plaintext data and decimal
        [] (const std::string name, Create_field * const cf,    |      if(cf->sql_type != enum_field_types::MYSQL_TYPE_DECIMAL && 
            const ProxyState &ps, TableMeta *const tm)          |         cf->sql_type != enum_field_types::MYSQL_TYPE_FLOAT &&
    {                                                           |         cf->sql_type != enum_field_types::MYSQL_TYPE_DOUBLE &&
        return new FieldMeta(name, cf, ps.getMasterKey().get(), |         cf->sql_type != enum_field_types::MYSQL_TYPE_TIMESTAMP &
                             ps.defaultSecurityRating(),        |         cf->sql_type != enum_field_types::MYSQL_TYPE_DATE &&
                             tm->leaseIncUniq());               |         cf->sql_type != enum_field_types::MYSQL_TYPE_TIME &&
    };                                                          |         cf->sql_type != enum_field_types::MYSQL_TYPE_DATETIME &&
    std::unique_ptr<FieldMeta> fm(buildFieldMeta(name, cf, ps,  |         cf->sql_type != enum_field_types::MYSQL_TYPE_YEAR &&
                                                                |         cf->sql_type != enum_field_types::MYSQL_TYPE_NEWDATE &&
                                                                >         cf->sql_type != enum_field_types::MYSQL_TYPE_NEWDECIMAL
                                                                >       )
                                                                >       cf->flags = cf->flags | UNSIGNED_FLAG;
                                                                >
                                                                >      const std::string &name = std::string(cf->field_name);
                                                                >      std::unique_ptr<FieldMeta>
                                                                >          fm(new FieldMeta(*cf, a.getMasterKey().get(),
                                                                >                           a.getDefaultSecurityRating(), tm->leas
                                                                >                           isUnique(name, key_data)));
                                                                >      //for each onion, we have new fields and salts, salts have 
                                                                <
                                                                <
                                                                |      //这里是onionMeta中的vector, enclayers.也就是洋葱不同层次的
                                                                >      //encLary中的加解密算法来完成.
                                                                |      //这段代码体现了层次加密,也就是说, 通过IV,每个洋葱的层次通
    for (auto it = enc_layers.begin(); it != enc_layers.end();  |      //直接调用其加密和解密函数, 就可以完成加密工作. 加密以后获
                                                                >      for (const auto &it : enc_layers) {
                  << TypeText<SECLEVEL>::toText((*it)->level()) |                    << TypeText<SECLEVEL>::toText(it->level()) <<
        new_enc = (*it)->encrypt(*enc, IV);                     |          new_enc = it->encrypt(*enc, IV);
                                                                <
rewriteAndGetSingleQuery(const ProxyState &ps, const std::strin <
                         SchemaInfo const &schema,              <
                         const std::string &default_db)         <
{                                                               <
    const QueryRewrite qr(Rewriter::rewrite(ps, q, schema, defa <
    assert(false == qr.output->stalesSchema());                 <
    assert(QueryAction::VANILLA == qr.output->queryAction(ps.ge <
                                                                <
    std::list<std::string> out_queryz;                          <
    qr.output->getQuery(&out_queryz, schema);                   <
    assert(out_queryz.size() == 1);                             <
                                                                <
    return out_queryz.back();                                   <
}                                                               <
                                                                <
std::string                                                     <
                                                                >         
                                                                >          //一个fieldmeta表示一个field, 内部的不同洋葱表现在onion
                                                                >          //在enclyer. 而保持的时候, 是onometekey,onoinmeta这种pa
                                                                >          //枚举的洋葱类型.
                            Analysis &a, std::vector<Item *> *l |                              Analysis &a, std::vector<Item *> *l
{                                                               |
                                                                >
                                                                >      //对于每种类型, 除了保存加密的洋葱, 还把fm中的salt也变成Int
                                                                >      //这个东西是什么时候应用.
std::string                                                     <
mysql_noop()                                                    <
{                                                               <
    return "do 0;";                                             <
}                                                               <
                                                                <
                                                                >      //这里是多行的字符串.
void                                                            |  std::string
queryPreamble(const ProxyState &ps, const std::string &q,       |  terminalEscape(const std::string &s)
              std::unique_ptr<QueryRewrite> *const qr,          |  {
              std::list<std::string> *const out_queryz,         |      std::string out;
              SchemaCache *const schema_cache,                  |      for (auto it : s) {
              const std::string &default_db)                    |          if (isprint(it)) {
{                                                               |              out.push_back(it);
    const SchemaInfo &schema =                                  |              continue;
        schema_cache->getSchema(ps.getConn(), ps.getEConn());   <
                                                                <
    *qr = std::unique_ptr<QueryRewrite>(                        <
            new QueryRewrite(Rewriter::rewrite(ps, q, schema,   <
                                               default_db)));   <
                                                                <
    // We handle before any queries because a failed query      <
    // may stale the database during recovery and then          <
    // we'd have to handle there as well.                       <
    schema_cache->updateStaleness(ps.getEConn(),                <
                                  (*qr)->output->stalesSchema() <
                                                                <
    // ASK bites again...                                       <
    // We want the embedded database to reflect the metadata fo <
    // current remote connection.                               <
    if ((*qr)->output->usesEmbeddedDB()) {                      <
        TEST_TextMessageError(lowLevelSetCurrentDatabase(ps.get <
                                                         defaul <
                              "Failed to set default embedded d <
    }                                                           <
                                                                <
    (*qr)->output->beforeQuery(ps.getConn(), ps.getEConn());    <
    (*qr)->output->getQuery(out_queryz, schema);                <
                                                                <
    return;                                                     <
/*                                                              |          out.push_back('?');
static void                                                     <
printEC(std::unique_ptr<Connect> e_conn, const std::string & co <
    DBResult * dbres;                                           <
    assert_s(e_conn->execute(command, dbres), "command failed") <
    ResType res = dbres->unpack();                              <
    printRes(res);                                              <
*/                                                              <
static void                                                     |      return out;
printEmbeddedState(const ProxyState &ps) {                      <
/*                                                              <
    printEC(ps.e_conn, "show databases;");                      <
    printEC(ps.e_conn, "show tables from pdb;");                <
    std::cout << "regular" << std::endl << std::endl;           <
    printEC(ps.e_conn, "select * from pdb.MetaObject;");        <
    std::cout << "bleeding" << std::endl << std::endl;          <
    printEC(ps.e_conn, "select * from pdb.BleedingMetaObject;") <
    printEC(ps.e_conn, "select * from pdb.Query;");             <
    printEC(ps.e_conn, "select * from pdb.DeltaOutput;");       <
*/                                                              <
                                                                <
              << "QUERY: " << COLOR_END << query << std::endl;  |                << "QUERY: " << COLOR_END << terminalEscape(query
}                                                               <
                                                                <
static void                                                     <
prettyPrintQueryResult(const ResType &res)                      <
{                                                               <
    std::cout << std::endl << RED_BEGIN                         <
              << "RESULTS: " << COLOR_END << std::endl;         <
    printRes(res);                                              <
    std::cout << std::endl;                                     <
}                                                               <
                                                                <
EpilogueResult                                                  <
queryEpilogue(const ProxyState &ps, const QueryRewrite &qr,     <
              const ResType &res, const std::string &query,     <
              const std::string &default_db, bool pp)           <
{                                                               <
    qr.output->afterQuery(ps.getEConn());                       <
                                                                <
    const QueryAction action = qr.output->queryAction(ps.getCon <
    if (QueryAction::AGAIN == action) {                         <
        std::unique_ptr<SchemaCache> schema_cache(new SchemaCac <
        const EpilogueResult &epi_res =                         <
            executeQuery(ps, query, default_db, schema_cache.ge <
        TEST_Sync(schema_cache->cleanupStaleness(ps.getEConn()) <
                  "failed to cleanup cache after requery!");    <
        return epi_res;                                         <
    }                                                           <
                                                                <
    if (pp) {                                                   <
        printEmbeddedState(ps);                                 <
        prettyPrintQueryResult(res);                            <
    }                                                           <
                                                                <
    if (qr.output->doDecryption()) {                            <
        const ResType &dec_res =                                <
            Rewriter::decryptResults(res, qr.rmeta);            <
        assert(dec_res.success());                              <
        if (pp) {                                               <
            prettyPrintQueryResult(dec_res);                    <
        }                                                       <
                                                                <
        return EpilogueResult(action, dec_res);                 <
    }                                                           <
                                                                <
    return EpilogueResult(action, res);                         <
}                                                               <
                                                                <
static bool                                                     <
lowLevelGetCurrentStaleness(const std::unique_ptr<Connect> &e_c <
                            unsigned int cache_id)              <
{                                                               <
    const std::string &query =                                  <
        " SELECT stale FROM " + MetaData::Table::staleness() +  <
        "  WHERE cache_id = " + std::to_string(cache_id) + ";"; <
    std::unique_ptr<DBResult> db_res;                           <
    TEST_TextMessageError(e_conn->execute(query, &db_res),      <
                          "failed to get schema!");             <
    assert(1 == mysql_num_rows(db_res->n));                     <
                                                                <
    const MYSQL_ROW row = mysql_fetch_row(db_res->n);           <
    const unsigned long *const l = mysql_fetch_lengths(db_res-> <
    assert(l != NULL);                                          <
                                                                <
    return string_to_bool(std::string(row[0], l[0]));           <
}                                                               <
                                                                <
const SchemaInfo &                                              <
SchemaCache::getSchema(const std::unique_ptr<Connect> &conn,    <
                       const std::unique_ptr<Connect> &e_conn)  <
{                                                               <
    if (true == this->no_loads) {                               <
        // Use this cleanup if we can't maintain consistent sta <
        /*                                                      <
        TEST_TextMessageError(cleanupStaleness(e_conn),         <
                              "Failed to cleanup staleness for  <
                              " usage!");                       <
        */                                                      <
        TEST_TextMessageError(initialStaleness(e_conn),         <
                              "Failed to initialize staleness f <
                              " usage!");                       <
        this->no_loads = false;                                 <
    }                                                           <
    const bool stale = lowLevelGetCurrentStaleness(e_conn, this <
                                                                <
    if (true == stale) {                                        <
        this->schema.reset(loadSchemaInfo(conn, e_conn));       <
    }                                                           <
                                                                <
    assert(this->schema);                                       <
    return *this->schema.get();                                 <
}                                                               <
                                                                <
static void                                                     <
lowLevelAllStale(const std::unique_ptr<Connect> &e_conn)        <
{                                                               <
    const std::string &query =                                  <
        " UPDATE " + MetaData::Table::staleness() +             <
        "    SET stale = TRUE;";                                <
                                                                <
    TEST_TextMessageError(e_conn->execute(query),               <
                          "failed to all stale!");              <
void                                                            |  SECURITY_RATING
SchemaCache::updateStaleness(const std::unique_ptr<Connect> &e_ |  determineSecurityRating()
                             bool staleness)                    <
    if (true == staleness) {                                    |      const char *const secure = getenv("SECURE_CRYPTDB");
        // Make everyone stale.                                 |      if (secure && equalsIgnoreCase("FALSE", secure)) {
        lowLevelAllStale(e_conn);                               |          return SECURITY_RATING::BEST_EFFORT;
    } else {                                                    <
        // We are no longer stale.                              <
        this->lowLevelCurrentUnstale(e_conn);                   <
    }                                                           <
bool                                                            |      return SECURITY_RATING::SENSITIVE;
SchemaCache::initialStaleness(const std::unique_ptr<Connect> &e <
{                                                               <
    const std::string seed_staleness =                          <
        " INSERT INTO " + MetaData::Table::staleness() +        <
        "   (cache_id, stale) VALUES " +                        <
        "   (" + std::to_string(this->id) + ", TRUE);";         <
    RETURN_FALSE_IF_FALSE(e_conn->execute(seed_staleness));     <
                                                                <
    return true;                                                <
SchemaCache::cleanupStaleness(const std::unique_ptr<Connect> &e |  handleActiveTransactionPResults(const ResType &res)
{                                                               <
    const std::string remove_staleness =                        <
        " DELETE FROM " + MetaData::Table::staleness() +        <
        "       WHERE cache_id = " + std::to_string(this->id) + <
    RETURN_FALSE_IF_FALSE(e_conn->execute(remove_staleness));   <
                                                                <
    return true;                                                <
}                                                               <
static void                                                     <
lowLevelToggleCurrentStaleness(const std::unique_ptr<Connect> & <
                               unsigned int cache_id, bool stal <
{                                                               <
    const std::string &query =                                  <
        " UPDATE " + MetaData::Table::staleness() +             <
        "    SET stale = " + bool_to_string(staleness) +        <
        "  WHERE cache_id = " + std::to_string(cache_id) + ";"; <
                                                                <
    TEST_TextMessageError(e_conn->execute(query),               <
                          "failed to unstale current!");        <
}                                                               <
                                                                <
void                                                            <
SchemaCache::lowLevelCurrentStale(const std::unique_ptr<Connect <
    lowLevelToggleCurrentStaleness(e_conn, this->id, true);     |      assert(res.success());
}                                                               |      assert(res.rows.size() == 1);
void                                                            |      const std::string &trx = ItemToString(*res.rows.front().fro
SchemaCache::lowLevelCurrentUnstale(const std::unique_ptr<Conne |      assert("1" == trx || "0" == trx);
{                                                               |      return ("1" == trx);
    lowLevelToggleCurrentStaleness(e_conn, this->id, false);    <
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/rewrite_util.hh Practical-Cryptdb/main/rewrite_util.hh
                                                                >  #include <main/schema.hh>
                                                                >  const bool PRETTY_DEMO = false;
LEX *                                                           |  std::vector<std::tuple<std::vector<std::string>, Key::Keytype> 
begin_transaction_lex(const std::string &dbname);               |  collectKeyData(const LEX &lex);
                                                                <
LEX *                                                           <
commit_transaction_lex(const std::string &dbname);              <
std::vector<Key *>                                              |  void
rewrite_key(const TableMeta &tm, Key * const key, const Analysi |  highLevelRewriteKey(const TableMeta &tm, const LEX &seed_lex,
                                                                >                      LEX *const out_lex, const Analysis &a);
                                                                >
                                                                >  //added
                                                                >  void 
                                                                >  highLevelRewriteForeignKey(const TableMeta &tm, const LEX &seed
                                                                >                      LEX *const out_lex, const Analysis &a,std::
                                                                >
createAndRewriteField(Analysis &a, const ProxyState &ps,        |  createAndRewriteField(Analysis &a, Create_field * const cf,
                      Create_field * const cf,                  <
                                                                >                        const std::vector<std::tuple<std::vector<
                                                                >                                          Key::Keytype> >
                                                                >                            &key_data,
std::string                                                     <
rewriteAndGetSingleQuery(const ProxyState &ps, const std::strin <
                         SchemaInfo const &schema,              <
                         const std::string &default_db);        <
                                                                <
    for (typename std::vector<T>::iterator it = v.begin();      |      for (const auto &it : v) {
         it != v.end(); ++it) {                                 |          const std::string &element = finalize(static_cast<T>(it
        const std::string &element = finalize(static_cast<T>(*i <
                                                                >  static std::string identity(std::string s) {return s;}
                                                                >
                                                                >  inline std::string
                                                                >  vector_join(std::vector<std::string> v, const std::string &deli
                                                                >  {
                                                                >      return vector_join<std::string>(v, delim, identity);
                                                                >  }
                                                                >
mysql_noop();                                                   <
                                                                <
std::string                                                     <
void                                                            |  std::string terminalEscape(const std::string &s);
queryPreamble(const ProxyState &ps, const std::string &q,       <
              std::unique_ptr<QueryRewrite> *qr,                <
              std::list<std::string> *const out_queryz,         <
              SchemaCache *const schema,                        <
              const std::string &default_db);                   <
                                                                <
bool                                                            <
queryHandleRollback(const ProxyState &ps, const std::string &qu <
                    SchemaInfo const &schema);                  <
class EpilogueResult {                                          |  SECURITY_RATING
public:                                                         |  determineSecurityRating();
    EpilogueResult(QueryAction action, const ResType &res_type) |
        : action(action), res_type(res_type) {}                 |  bool
                                                                |  handleActiveTransactionPResults(const ResType &res);
    const QueryAction action;                                   <
    const ResType res_type;                                     <
};                                                              <
                                                                <
EpilogueResult                                                  <
queryEpilogue(const ProxyState &ps, const QueryRewrite &qr,     <
              const ResType &res, const std::string &query,     <
              const std::string &default_db, bool pp);          <
                                                                <
class SchemaCache {                                             <
public:                                                         <
    SchemaCache() : no_loads(true), id(randomValue() % UINT_MAX <
                                                                <
    const SchemaInfo &getSchema(const std::unique_ptr<Connect>  <
                                const std::unique_ptr<Connect>  <
    void updateStaleness(const std::unique_ptr<Connect> &e_conn <
                         bool staleness);                       <
    bool initialStaleness(const std::unique_ptr<Connect> &e_con <
    bool cleanupStaleness(const std::unique_ptr<Connect> &e_con <
    void lowLevelCurrentStale(const std::unique_ptr<Connect> &e <
    void lowLevelCurrentUnstale(const std::unique_ptr<Connect>  <
                                                                <
private:                                                        <
    std::unique_ptr<const SchemaInfo> schema;                   <
    bool no_loads;                                              <
    const unsigned int id;                                      <
};                                                              <
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/schema.cc Practical-Cryptdb/main/schema.cc
                                                                >  #include <parser/mysql_type_metadata.hh>
                                                                >  //对于schemaInfo而言, 先获得自己的id, 作为parent, 可以查找底下
                                                                >  //然后通过lambda表达式,先把databasemeta加入到schemainfo的map中,
                                                                >
                                                                >  /*
                                                                >  *for example, we have schemaInfo, then in this function, it fir
                                                                >  *to fetch its children, the databasemeta. Then it adds those da
                                                                >  *databasemeta as a vector for recursive processing.
                                                                >
                                                                >  for this function, it only extract the dbmeta and 
                                                                >  */
                            deserialHandler)                    |                              deserialHandler) {
{                                                               <
    const std::string table_name = MetaData::Table::metaObject( <
                                                                >      const std::string table_name = MetaData::Table::metaObject(
                                                                >      //this is the id of the current class.
    // FIXME: Throw exception.                                  |      //all the metadata are fetched here.
    assert(e_conn->execute(serials_query, &db_res));            |      TEST_TextMessageError(e_conn->execute(serials_query, &db_re
                                                                >                            "doFetchChildren query failed");
                                                                <
                                                                <
                                                                <
                                                                >
                                                                >  //new onion, 这里的uniq_count是通过fieldMeta获得的, 本身没有集
                     Create_field * const cf, unsigned long uni |                       const Create_field &cf, unsigned long uniq
                                                                >                       SECLEVEL minimum_seclevel)
      uniq_count(uniq_count)                                    |        uniq_count(uniq_count), minimum_seclevel(minimum_seclevel
{                                                               |      assert(levels.size() >= 1);
    Create_field * newcf = cf;                                  |
                                                                >      const Create_field * newcf = &cf;
            el(EncLayerFactory::encLayer(o, l, newcf, key));    |              el(EncLayerFactory::encLayer(o, l, *newcf, key));
        Create_field * const oldcf = newcf;                     |          const Create_field &oldcf = *newcf;
                                                                >      assert(this->layers.size() >= 1);
                                                                >  //onionmeta解序列化
                                                                >      //OnionMeta序列化的结果有三个.
                                                                >      assert(3 == vec.size());
                                                                >      //名字
                                                                >      //count
                                                                >      //level
                                                                >      const SECLEVEL minimum_seclevel = TypeText<SECLEVEL>::toTyp
    return std::unique_ptr<OnionMeta>(new OnionMeta(id, onionna |      //在什么位置调用的, id应该是查表获得的id, 为什么需要unique_
                                                    uniq_count) |      return std::unique_ptr<OnionMeta>
                                                                >          (new OnionMeta(id, onionname, uniq_count, minimum_secle
                                                                >  //序列化的结果
                                                                >      //就是名字,count,以及level分别转换成字符串, 然后用字符串序
        serialize_string(std::to_string(this->uniq_count));     |          serialize_string(std::to_string(this->uniq_count)) +
                                                                |          serialize_string(TypeText<SECLEVEL>::toText(this->minim
    for (auto it = layers.begin(); it != layers.end(); it++) {  |      for (const auto &it : layers) {
        if (false == fn(*(*it).get())) {                        |          if (false == fn(*it.get())) {
    for (auto it = layers.begin(); it != layers.end(); it++) {  |      for (const auto &it : layers) {
        if ((*it)->level() == sl) {                             |          if (it->level() == sl) {
    for (auto it = layers.begin(); it != layers.end(); it++) {  |      for (const auto &it : layers) {
        if ((*it)->level() == sl) {                             |          if (it->level() == sl) {
            out = (*it).get();                                  |              out = it.get();
SECLEVEL OnionMeta::getSecLevel() const                         |  SECLEVEL OnionMeta::getSecLevel() const {
{                                                               <
                                                                >
FieldMeta::deserialize(unsigned int id, const std::string &seri |  FieldMeta::deserialize(unsigned int id, const std::string &seri
{                                                               |      assert(id != 0);
                                                                >      assert(9 == vec.size());
                                                                >  // first element is the levels that the onionmeta should implem
                                                                >  // second element is the minimum level that should be gone down
                                                                >  static std::pair<std::vector<SECLEVEL>, SECLEVEL>
                                                                >  determineSecLevelData(onion o, std::vector<SECLEVEL> levels, bo
                                                                >  {
                                                                >      if (false == unique) {
                                                                >          return std::make_pair(levels, levels.front());
                                                                >      }
                                                                >
                                                                >      // the oDET onion should start at DET and stay at DET
                                                                >      if (oDET == o) {
                                                                >          assert(SECLEVEL::RND == levels.back());
                                                                >          levels.pop_back();
                                                                >          assert(SECLEVEL::DET == levels.back());
                                                                >          return std::make_pair(levels, levels.front());
                                                                >      }
                                                                >
                                                                >      // oPLAIN may be starting at PLAINVAL if we have an autoinc
                                                                >      if (oPLAIN == o) {
                                                                >          assert(SECLEVEL::PLAINVAL == levels.back()
                                                                >                 || SECLEVEL::RND == levels.back());
                                                                >      } else if (oOPE == o) {
                                                                >          assert(SECLEVEL::RND == levels.back());
                                                                >          levels.pop_back();
                                                                >          assert(SECLEVEL::OPE == levels.back());
                                                                >          levels.pop_back();
                                                                >          assert(SECLEVEL::OPEFOREIGN==levels.back());
                                                                >      } else if (oAGG == o) {
                                                                >          assert(SECLEVEL::HOM == levels.back());
                                                                >      } else {
                                                                >          assert(false);
                                                                >      }
                                                                >      return std::make_pair(levels, levels.front());
                                                                >  }
                                                                >
init_onions_layout(const AES_KEY *const m_key,                  |  init_onions_layout(const AES_KEY *const m_key, FieldMeta *const
                   FieldMeta *const fm, Create_field *const cf) |                     const Create_field &cf, bool unique)
    if (0 != fm->children.size()) {                             |      if (0 != fm->getChildren().size()) {
        const std::vector<SECLEVEL> levels = it.second;         |          const std::vector<SECLEVEL> &levels = it.second;
                                                                >
                                                                >          assert(levels.size() >= 1);
                                                                >          const std::pair<std::vector<SECLEVEL>, SECLEVEL> level_
                                                                >              determineSecLevelData(o, levels, unique);
                                                                >          assert(level_data.first.size() >= 1);
                                                                >
            om(new OnionMeta(o, levels, m_key, cf, fm->leaseInc |              om(new OnionMeta(o, std::get<0>(level_data), m_key,
        const std::string onion_name = om->getAnonOnionName();  |                               fm->leaseCount(), std::get<1>(leve
                                                                >          //only for log
                                                                >          const std::string &onion_name = om->getAnonOnionName();
                   << " for " << fm->fname;                     |                     << " for " << fm->getFieldName();
                                                                <
        //set outer layer                                       <
        // fm->setCurrentOnionLevel(o, it.second.back());       <
FieldMeta::FieldMeta(const std::string &name, Create_field * co |  FieldMeta::FieldMeta(const Create_field &field,
                     unsigned long uniq_count)                  |                       unsigned long uniq_count,
    : fname(name), salt_name(BASE_SALT_NAME + getpRandomName()) |                       bool unique)
                                                                >      : fname(std::string(field.field_name)),
                                                                >        salt_name(BASE_SALT_NAME + getpRandomName()),
      default_value(determineDefaultValue(has_default, field))  |        default_value(determineDefaultValue(has_default, field)) 
{                                                               |
    TEST_TextMessageError(init_onions_layout(m_key, this, field |      TEST_TextMessageError(init_onions_layout(m_key, this, field
                                                                <
                                                                >  //这里FieldMeta的getChildren是pair,OnionMetaKey,OnionMeta, 其中
                                                                >  //onionMeta有根据Uniq排序输出为vector
    for (auto it = children.begin(); it != children.end(); it++ |      for (const auto &it : this->getChildren()) {
        v.push_back(std::make_pair(&(*it).first, (*it).second.g |          v.push_back(std::make_pair(&it.first, it.second.get()))
static bool encryptionNotSupported(const Create_field *const cf <
{                                                               <
    switch (cf->sql_type) {                                     <
        case MYSQL_TYPE_FLOAT:                                  <
        case MYSQL_TYPE_DOUBLE:                                 <
        case MYSQL_TYPE_TIMESTAMP:                              <
        case MYSQL_TYPE_DATE:                                   <
        case MYSQL_TYPE_TIME:                                   <
        case MYSQL_TYPE_DATETIME:                               <
        case MYSQL_TYPE_YEAR:                                   <
        case MYSQL_TYPE_NEWDATE:                                <
        case MYSQL_TYPE_BIT:                                    <
        case MYSQL_TYPE_ENUM:                                   <
        case MYSQL_TYPE_SET:                                    <
        case MYSQL_TYPE_GEOMETRY:                               <
            return true;                                        <
        default:                                                <
            return false;                                       <
    }                                                           <
}                                                               <
                                                                <
                                            const Create_field  |                                              const Create_field 
                                                                <
                                                                |      if (false == encryptionSupported(f)) {
    if (encryptionNotSupported(f)) {                            |          //TEST_TextMessageError(SECURITY_RATING::SENSITIVE != s
        TEST_TextMessageError(SECURITY_RATING::SENSITIVE != sec |          //                      "A SENSITIVE security rating re
                              "A SENSITIVE security rating requ |          //                      " field to be supported with cr
                              " field to be supported with cryp <
    if (Field::NEXT_NUMBER == f->unireg_check) {                |      if (Field::NEXT_NUMBER == f.unireg_check) {
                                                                <
        if (true == IsMySQLTypeNumeric(f->sql_type)) {          |          if (true == isMySQLTypeNumeric(f)) {
        if (true == IsMySQLTypeNumeric(f->sql_type)) {          |          if (true == isMySQLTypeNumeric(f)) {
bool FieldMeta::determineHasDefault(const Create_field *const c |  bool FieldMeta::determineHasDefault(const Create_field &cf) {
{                                                               |      return cf.def || cf.flags & NOT_NULL_FLAG;
    return cf->def || cf->flags & NOT_NULL_FLAG;                <
                                             const Create_field |                                               const Create_field
    if (cf->def) {                                              |      if (cf.def) {
        return ItemToString(*cf->def);                          |          return ItemToString(*cf.def);
        if (true == IsMySQLTypeNumeric(cf->sql_type)) {         |          if (true == isMySQLTypeNumeric(cf)) {
                                                                >      assert(id != 0);
                                                                >      //table 的解序列化有5个项目.
                                                                >      assert(5 == vec.size());
                                                                >  //table有5个要素需要进行编码, 匿名的名字, sensitive的bool,salt
                                                                >  //为什么tableMeta和FieldMeta需要继承UniqueCounter
                                                                <
    for (auto it = children.begin(); it != children.end(); it++ |      for (const auto &it : this->getChildren()) {
        v.push_back((*it).second.get());                        |          v.push_back(it.second.get());
                                                                >  /*use fm->hasDefault() to test whether the filed has default va
    for (auto it = children.begin(); it != children.end(); it++ |      for (const auto &it : this->getChildren()) {
        v.push_back((*it).second.get());                        |          v.push_back(it.second.get());
                                                                >      assert(id != 0);
                                                                >
                                                                >  //查询Id对应的stale的值
                                                                >  static bool
                                                                >  lowLevelGetCurrentStaleness(const std::unique_ptr<Connect> &e_c
                                                                >                              unsigned int cache_id)
                                                                >  {
                                                                >      const std::string &query =
                                                                >          " SELECT stale FROM " + MetaData::Table::staleness() +
                                                                >          "  WHERE cache_id = " + std::to_string(cache_id) + ";";
                                                                >      std::unique_ptr<DBResult> db_res;
                                                                >      RFIF(e_conn->execute(query, &db_res));
                                                                >      assert(1 == mysql_num_rows(db_res->n));
                                                                >
                                                                >      const MYSQL_ROW row = mysql_fetch_row(db_res->n);
                                                                >      const unsigned long *const l = mysql_fetch_lengths(db_res->
                                                                >      assert(l != NULL);
                                                                >
                                                                >      return string_to_bool(std::string(row[0], l[0]));
                                                                >  }
                                                                >
                                                                >  std::shared_ptr<const SchemaInfo>
                                                                >  SchemaCache::getSchema(const std::unique_ptr<Connect> &conn,
                                                                >                         const std::unique_ptr<Connect> &e_conn) 
                                                                >  {
                                                                >      if (true == this->no_loads) {
                                                                >          //设置当前id对应的stale的值为true.        
                                                                >          TEST_SchemaFailure(initialStaleness(e_conn));
                                                                >          this->no_loads = false;
                                                                >      }else{
                                                                >      }
                                                                >
                                                                >         //查询当前ID对应的Stale的值
                                                                >      if (true == lowLevelGetCurrentStaleness(e_conn, this->id)) 
                                                                >          this->schema =
                                                                >              std::shared_ptr<SchemaInfo>(loadSchemaInfo(conn, e_
                                                                >      }else{
                                                                >      }
                                                                >
                                                                >      assert(this->schema);
                                                                >      return this->schema;
                                                                >  }
                                                                >
                                                                >  static void
                                                                >  lowLevelAllStale(const std::unique_ptr<Connect> &e_conn)
                                                                >  {
                                                                >      const std::string &query =
                                                                >          " UPDATE " + MetaData::Table::staleness() +
                                                                >          "    SET stale = TRUE;";
                                                                >
                                                                >      TEST_SchemaFailure(e_conn->execute(query));
                                                                >  }
                                                                >
                                                                >  void
                                                                >  SchemaCache::updateStaleness(const std::unique_ptr<Connect> &e_
                                                                >                               bool staleness) const
                                                                >  {
                                                                >      if (true == staleness) {
                                                                >          // Make everyone stale.
                                                                >          return lowLevelAllStale(e_conn);
                                                                >      }
                                                                >
                                                                >      // We are no longer stale.
                                                                >      return this->lowLevelCurrentUnstale(e_conn);
                                                                >  }
                                                                >
IsMySQLTypeNumeric(enum_field_types t) {                        |  SchemaCache::initialStaleness(const std::unique_ptr<Connect> &e
    switch (t) {                                                |  {
        case MYSQL_TYPE_DECIMAL:                                |      const std::string seed_staleness =
        case MYSQL_TYPE_TINY:                                   |          " INSERT INTO " + MetaData::Table::staleness() +
        case MYSQL_TYPE_SHORT:                                  |          "   (cache_id, stale) VALUES " +
        case MYSQL_TYPE_LONG:                                   |          "   (" + std::to_string(this->id) + ", TRUE);";
        case MYSQL_TYPE_FLOAT:                                  |      RFIF(e_conn->execute(seed_staleness));
        case MYSQL_TYPE_DOUBLE:                                 |
        case MYSQL_TYPE_LONGLONG:                               <
        case MYSQL_TYPE_INT24:                                  <
        case MYSQL_TYPE_NEWDECIMAL:                             <
        default: return false;                                  <
                                                                >
                                                                >  bool
                                                                >  SchemaCache::cleanupStaleness(const std::unique_ptr<Connect> &e
                                                                >  {
                                                                >      const std::string remove_staleness =
                                                                >          " DELETE FROM " + MetaData::Table::staleness() +
                                                                >          "       WHERE cache_id = " + std::to_string(this->id) +
                                                                >      RFIF(e_conn->execute(remove_staleness));
                                                                >
                                                                >      return true;
                                                                >  static bool
                                                                >  lowLevelToggleCurrentStaleness(const std::unique_ptr<Connect> &
                                                                >                                 unsigned int cache_id, bool stal
                                                                >  {
                                                                >      const std::string &query =
                                                                >          " UPDATE " + MetaData::Table::staleness() +
                                                                >          "    SET stale = " + bool_to_string(staleness) +
                                                                >          "  WHERE cache_id = " + std::to_string(cache_id) + ";";
                                                                >      RFIF(e_conn->execute(query));
                                                                >
                                                                >      return true;
                                                                >  }
                                                                >
                                                                >  void
                                                                >  SchemaCache::lowLevelCurrentStale(const std::unique_ptr<Connect
                                                                >      const
                                                                >  {
                                                                >      TEST_SchemaFailure(lowLevelToggleCurrentStaleness(e_conn, t
                                                                >  }
                                                                >
                                                                >  void
                                                                >  SchemaCache::lowLevelCurrentUnstale(const std::unique_ptr<Conne
                                                                >      const
                                                                >  {
                                                                >      TEST_SchemaFailure(lowLevelToggleCurrentStaleness(e_conn, t
                                                                >  }
                                                                >
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/schema.hh Practical-Cryptdb/main/schema.hh
// > FIXME: We are Memleaking                                   <
// SchemaInfo/TableMeta/FieldMeta/OnionMeta/EncLayer and the ke <
                                                                <
class Analysis;                                                 <
class FieldMeta;                                                <
                                                                <
typedef class OnionMeta : public DBMeta {                       |  class OnionMeta : public DBMeta {
    // New.                                                     <
              const AES_KEY * const m_key, Create_field * const |                const AES_KEY * const m_key, const Create_field &
              unsigned long uniq_count);                        |                unsigned long uniq_count, SECLEVEL minimum_seclev
                                                                <
              unsigned long uniq_count)                         |                unsigned long uniq_count, SECLEVEL minimum_seclev
        : DBMeta(id), onionname(onionname), uniq_count(uniq_cou |          : DBMeta(id), onionname(onionname), uniq_count(uniq_cou
                                                                >            minimum_seclevel(minimum_seclevel) {}
    // FIXME: Use rtti.                                         |      TYPENAME("onionMeta")
    std::string typeName() const {return type_name;}            <
    static std::string instanceTypeName() {return type_name;}   <
                                                                >
                                                                >
    unsigned long getUniq() const {return uniq_count;}          |      SECLEVEL getSecLevel() const;
    // Need access to layers.                                   |      unsigned long getUniq() const {return uniq_count;}
    friend class Analysis;                                      |      const std::vector<std::unique_ptr<EncLayer> > &getLayers() 
    friend class FieldMeta;                                     |          {return layers;}
    friend class OnionMetaAdjustor;                             |      SECLEVEL getMinimumSecLevel() const {return minimum_secleve
    friend bool sanityCheck(FieldMeta &);                       |      void setMinimumSecLevel(SECLEVEL seclevel) {this->minimum_s
    friend Item *decrypt_item_layers(Item *const, const FieldMe <
                                     onion, uint64_t);          <
    std::vector<std::unique_ptr<EncLayer>> layers; // first in  |      // first in list is lowest layer
                                                   // lowest la |      std::vector<std::unique_ptr<EncLayer> > layers;
    constexpr static const char *type_name = "onionMeta";       <
    unsigned long uniq_count;                                   |      const unsigned long uniq_count;
                                                                >      SECLEVEL minimum_seclevel;
                                                                >      /*what are those keys used for?*/
                                                                >  };
    SECLEVEL getSecLevel() const;                               |  class UniqueCounter {
} OnionMeta;                                                    |  public:
                                                                >      uint64_t leaseCount() {return getCounter_()++;}
                                                                >      uint64_t currentCount() {return getCounter_();}
                                                                >
                                                                >  private:
                                                                >      virtual uint64_t &getCounter_() = 0;
                                                                >  };
class TableMeta;                                                |  class FieldMeta : public MappedDBMeta<OnionMeta, OnionMetaKey>,
//TODO: FieldMeta and TableMeta are partly duplicates with the  |                    public UniqueCounter {
// FieldMetadata an TableMetadata                               <
// which contains data we want to add to this structure soon    <
typedef class FieldMeta : public MappedDBMeta<OnionMeta, OnionM <
    const std::string fname;                                    |      // New a fieldmeta, Create_field  and unique are used for d
    const std::string salt_name;                                |      //fieldmeta, they are not part of fieldmeta.
                                                                >      FieldMeta(const Create_field &field, const AES_KEY * const 
                                                                >                SECURITY_RATING sec_rating, unsigned long uniq_co
                                                                >                bool unique);
    // New.                                                     <
    FieldMeta(const std::string &name, Create_field * const fie <
              const AES_KEY * const mKey, SECURITY_RATING sec_r <
              unsigned long uniq_count);                        <
                                                                >
                                                                >      //read serialized data, deserialize it, and then construct 
              unsigned long counter, bool has_default,          |                uint64_t counter, bool has_default,
          default_value(default_value) {}                       |            default_value(default_value) {
                                                                >      }
                                                                >
                                                                >
                                                                >
                                                                >
                                                                >
    // FIXME: Use rtti.                                         |
    std::string typeName() const {return type_name;}            |      TYPENAME("fieldMeta");
    static std::string instanceTypeName() {return type_name;}   <
    unsigned long leaseIncUniq() {return counter++;}            |
    // FIXME: Change name.                                      <
    unsigned long getCurrentUniqCounter() const {return counter <
                                                                >      const std::string getFieldName() const {return fname;}
    constexpr static const char *type_name = "fieldMeta";       |      const std::string fname;
                                                                >      const std::string salt_name;
    unsigned long uniq_count;                                   |      const unsigned long uniq_count;
    unsigned long counter;                                      |      uint64_t counter;
                                                                >
                                            const Create_field  |                                              const Create_field 
    static bool determineHasDefault(const Create_field *const c |      static bool determineHasDefault(const Create_field &cf);
                                                                >
                                             const Create_field |                                               const Create_field
} FieldMeta;                                                    |      uint64_t &getCounter_() {return counter;}
                                                                >  };
typedef class TableMeta : public MappedDBMeta<FieldMeta, Identi |  //salt只是一个IV, 为什么还需要随机的名字: 因为field 需要有名字,
                                                                >  class TableMeta : public MappedDBMeta<FieldMeta, IdentityMetaKe
                                                                >                    public UniqueCounter {
    const bool hasSensitive;                                    <
    const bool has_salt;                                        <
    const std::string salt_name;                                <
    const std::string anon_table_name;                          <
                                                                <
          counter(0) {}                                         |            counter(0) {
                                                                >
                                                                >            }
                                                                >
          anon_table_name(anon_table_name), counter(counter) {} |            anon_table_name(anon_table_name), counter(counter) {
                                                                >            }
                                                                >
                                                                >      /* return fieldmeta of fields that has default value */
    // FIXME: Use rtti.                                         |      TYPENAME("tableMeta")
    std::string typeName() const {return type_name;}            |      std::string getAnonIndexName(const std::string &index_name,
    static std::string instanceTypeName() {return type_name;}   |                                   onion o) const;
    unsigned long leaseIncUniq() {return counter++;}            <
    unsigned long getCurrentUniqCounter() {return counter;}     <
                                                                <
    friend class Analysis;                                      <
    constexpr static const char *type_name = "tableMeta";       |      const bool hasSensitive;
    unsigned int counter;                                       |      const bool has_salt;
                                                                >      const std::string salt_name;
                                                                >      const std::string anon_table_name;
                                                                >      uint64_t counter;
    std::string getAnonIndexName(const std::string &index_name, |      uint64_t &getCounter_() {return counter;}
                                 onion o) const;                |  };
} TableMeta;                                                    <
    // FIXME: rtti                                              |      TYPENAME("databaseMeta")
    std::string typeName() const {return type_name;}            <
    static std::string instanceTypeName() {return type_name;}   <
                                                                <
private:                                                        <
    constexpr static const char *type_name = "databaseMeta";    <
typedef class SchemaInfo : public MappedDBMeta<DatabaseMeta,    |  class SchemaInfo : public MappedDBMeta<DatabaseMeta, IdentityMe
                                               IdentityMetaKey> |
    std::string typeName() const {return type_name;}            |      TYPENAME("schemaInfo")
    static std::string instanceTypeName() {return type_name;}   <
    constexpr static const char *type_name = "schemaInfo";      <
                                                                <
} SchemaInfo;                                                   <
bool                                                            |  };
IsMySQLTypeNumeric(enum_field_types t);                         |
                                                                >  class SchemaCache {
                                                                >      SchemaCache(const SchemaCache &cache) = delete;
                                                                >      SchemaCache &operator=(const SchemaCache &cache) = delete;
                                                                >      SchemaCache &operator=(SchemaCache &&cache) = delete;
                                                                >
                                                                >  public:
                                                                >      SchemaCache() : no_loads(true), id(randomValue() % UINT_MAX
                                                                >      }
                                                                >      SchemaCache(SchemaCache &&cache)
                                                                >          : schema(std::move(cache.schema)), no_loads(cache.no_lo
                                                                >            id(cache.id) {
                                                                >      }
                                                                >
                                                                >      std::shared_ptr<const SchemaInfo>
                                                                >          getSchema(const std::unique_ptr<Connect> &conn,
                                                                >                    const std::unique_ptr<Connect> &e_conn) const
                                                                >      void updateStaleness(const std::unique_ptr<Connect> &e_conn
                                                                >                           bool staleness) const;
                                                                >      bool initialStaleness(const std::unique_ptr<Connect> &e_con
                                                                >      bool cleanupStaleness(const std::unique_ptr<Connect> &e_con
                                                                >      void lowLevelCurrentStale(const std::unique_ptr<Connect> &e
                                                                >      void lowLevelCurrentUnstale(const std::unique_ptr<Connect> 
                                                                >
                                                                >  private:
                                                                >      mutable std::shared_ptr<const SchemaInfo> schema;
                                                                >      mutable bool no_loads;
                                                                >      const unsigned int id;
                                                                >  };
                                                                >  typedef std::shared_ptr<const SchemaInfo> SchemaInfoRef;
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/serializers.hh Practical-Cryptdb/main/serializers.hh
                                                                >  //简单的字符串序列化方法, 长度_str
        std::size_t length =                                    |          const std::size_t length =
                                                                <
                                                                <
Only in Practical-Cryptdb/main: sql_handler.cc
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/sql_handler.hh Practical-Cryptdb/main/sql_handler.hh
                                                                >  #include <util/yield.hpp>
                                                                >  #define CR_QUERY_AGAIN(query)                                  
                                                                >      std::make_pair(AbstractQueryExecutor::ResultType::QUERY_COM
                                                                >                     newAnything(std::make_pair(true, std::string
                                                                >
                                                                >  #define CR_QUERY_RESULTS(query)                                
                                                                >      std::make_pair(AbstractQueryExecutor::ResultType::QUERY_USE
                                                                >                     newAnything(std::string(query)))
                                                                >
                                                                >  #define CR_RESULTS(value)                                      
                                                                >      std::make_pair(AbstractQueryExecutor::ResultType::RESULTS, 
                                                                >                     newAnything(value))
                                                                >
                                                                >  template <typename Type>
                                                                >  class Anything;
                                                                >
                                                                >  class AbstractAnything {
                                                                >  public:
                                                                >      virtual ~AbstractAnything() = 0;
                                                                >
                                                                >      template <typename Type>
                                                                >      Type
                                                                >      extract() const
                                                                >      {
                                                                >          return static_cast<const Anything<Type> *>(this)->get()
                                                                >      }
                                                                >  };
                                                                >
                                                                >  template <typename Type>
                                                                >  class Anything : public AbstractAnything {
                                                                >      const Type value;
                                                                >
                                                                >  public:
                                                                >      Anything(const Type &value) : value(value) {}
                                                                >      Type get() const {return value;}
                                                                >  };
                                                                >
                                                                >  template <typename Type>
                                                                >  Anything<Type> *
                                                                >  newAnything(const Type &t)
                                                                >  {
                                                                >      return new Anything<Type>(t);
                                                                >  }
                                                                >
                                                                >  struct NextParams {
                                                                >      const ProxyState &ps;
                                                                >      const std::string &default_db;
                                                                >      const std::string original_query;
                                                                >      NextParams(const ProxyState &ps, const std::string &default
                                                                >                 const std::string &original_query)
                                                                >          : ps(ps), default_db(default_db), original_query(origin
                                                                >  };
                                                                >
                                                                >  class AbstractQueryExecutor {
                                                                >  protected:
                                                                >      coroutine corot;
                                                                >
                                                                >  public:
                                                                >      enum class ResultType {RESULTS, QUERY_COME_AGAIN, QUERY_USE
                                                                >
                                                                >      AbstractQueryExecutor() {}
                                                                >      virtual ~AbstractQueryExecutor();
                                                                >      std::pair<ResultType, AbstractAnything *>
                                                                >          next(const ResType &res, const NextParams &nparams);
                                                                >
                                                                >      virtual std::pair<ResultType, AbstractAnything *>
                                                                >          nextImpl(const ResType &res, const NextParams &nparams)
                                                                >      virtual bool stales() const {return false;}
                                                                >      virtual bool usesEmbedded() const {return false;}
                                                                >
                                                                >  private:
                                                                >      void genericPreamble(const NextParams &nparams);
                                                                >  };
                                                                >
                                                                >  class SimpleExecutor : public AbstractQueryExecutor {
                                                                >  public:
                                                                >      SimpleExecutor() {}
                                                                >      ~SimpleExecutor() {}
                                                                >
                                                                >      std::pair<ResultType, AbstractAnything *>
                                                                >          nextImpl(const ResType &res, const NextParams &nparams)
                                                                >  };
                                                                >
                                                                >  class NoOpExecutor : public AbstractQueryExecutor {
                                                                >  public:
                                                                >      NoOpExecutor() {}
                                                                >      ~NoOpExecutor() {}
                                                                >
                                                                >      std::pair<ResultType, AbstractAnything *>
                                                                >          nextImpl(const ResType &res, const NextParams &nparams)
                                                                >  };
                                                                >
    virtual LEX *transformLex(Analysis &a, LEX *lex, const Prox |      virtual AbstractQueryExecutor * transformLex(Analysis &a, L
                                                                >  struct Preamble {
                                                                >      Preamble(const std::string &dbname, const std::string &tabl
                                                                >          : dbname(dbname), table(table) {}
                                                                >      const std::string dbname;
                                                                >      const std::string table;
                                                                >  };
                                                                >
                                                                >  #include <util/unyield.hpp>
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/stored_procedures.cc Practical-Cryptdb/main/stored_procedures.cc
    const std::string current_transaction_id =                  |      const std::vector<std::string> &add_procs{
        MetaData::Proc::currentTransactionID();                 |          " CREATE PROCEDURE " + MetaData::Proc::activeTransactio
    const std::string hom_addition_transaction =                <
        MetaData::Proc::homAdditionTransaction();               <
    const std::string adjust_onion =                            <
        MetaData::Proc::adjustOnion();                          <
    const std::string remote_completion_table =                 <
        MetaData::Table::remoteQueryCompletion();               <
                                                                <
    const std::vector<std::string> add_procs({                  <
        // ---------------------------------------              <
        //      def currentTransactionID(id)                    <
        // ---------------------------------------              <
        " CREATE PROCEDURE " + current_transaction_id + "\n"    <
        "   (OUT out_id VARCHAR(20))\n"                         <
        "   SELECT trx_id INTO out_id FROM INFORMATION_SCHEMA.I |          "   DECLARE eat_result BIGINT;\n"
                                                                >          "   DECLARE trx_count BIGINT;\n\n"
                                                                >
                                                                >              // force transaction propagation
                                                                >          "   SELECT 1 FROM remote_db.generic_prefix_remoteQueryC
                                                                >          "    LIMIT 1\n"
                                                                >          "     INTO eat_result;\n\n"
                                                                >
                                                                >          "   SELECT COUNT(trx_id) INTO trx_count\n"
                                                                >          "     FROM INFORMATION_SCHEMA.INNODB_TRX\n"
        "          'RUNNING';\n"                                |          "          'RUNNING';\n\n"
        " END\n",                                               <
                                                                <
        // ----------------------------------------------       <
        //   def homAdditionTransaction(delete, insert)         <
        // ----------------------------------------------       <
        /*                                                      <
            The corner case for this procedure is a call graph  <
            >>> START TRANSACTION;                              <
            >>> UPDATE t SET x = x + 1;                         <
                > homAdditionTransaction(...);                  <
            >>> ...                                             <
                > ...                                           <
                > ...                                           <
            >>> COMMIT;                                         <
                                                                <
            Where '>>>' are queries issue by user and '>' are C <
            transformations.                                    <
                                                                <
            (*) It appers that transactions are not propagated  <
            INFORMATION_SCHEMA.INNODB_TRX table until a query i <
            issued against a table that supports transactions.  <
                                                                <
            So it follows that in the above sequence the        <
            'START TRANSACTION' issued by the user will essenti <
            ignored in favor of a transaction started by        <
            homAdditionTransction(). This should lead to consis <
            expected behavior provided (*) is correct rationale <
        */                                                      <
        " CREATE PROCEDURE " + hom_addition_transaction + "\n"  <
        "       (IN delete_query VARBINARY(50000),\n"           <
        "        IN insert_query VARBINARY(50000))\n"           <
        " BEGIN\n"                                              <
        "   DECLARE old_transaction_id VARCHAR(20);\n\n"        <
                                                                <
        "   CALL " + current_transaction_id + " (old_transactio <
            // Start a transaction if necessary.                |          "   SELECT NOT 0 = trx_count AS ACTIVE_TRX;\n"
        "   IF old_transaction_id IS NULL THEN\n"               |          " END\n"};
        "       START TRANSACTION;\n"                           <
        "   END IF;\n\n"                                        <
                                                                <
            // DELETE old values pertaining to WHERE clause     <
        "   SET @query = delete_query;\n"                       <
        "   PREPARE dq FROM @query;\n"                          <
        "   EXECUTE dq;\n\n"                                    <
                                                                <
            // INSERT new values using subquery from temp table <
        "   SET @query = insert_query;\n"                       <
        "   PREPARE iq FROM @query;\n"                          <
        "   EXECUTE iq;\n\n"                                    <
                                                                <
            // Close our transaction if we started one.         <
        "   IF old_transaction_id IS NULL THEN\n"               <
        "       COMMIT;\n\n"                                    <
        "   END IF;\n"                                          <
        " END\n",                                               <
                                                                <
        // ---------------------------------------              <
        //         def adjustOnion(id)                          <
        // ---------------------------------------              <
        // NOTE: If we need N queries, we will have to use an a <
        // table + cursors.                                     <
        " CREATE PROCEDURE " + adjust_onion + "\n"              <
        "       (IN completion_id INTEGER,\n"                   <
        "        IN adjust_query0 VARBINARY(500),\n"            <
        "        IN adjust_query1 VARBINARY(500))\n"            <
        " BEGIN\n"                                              <
        "   DECLARE old_transaction_id VARCHAR(20);\n"          <
        "   DECLARE b_reissue BOOLEAN;\n\n"                     <
                                                                <
            // Are we in a transaction?                         <
        "   CALL " + current_transaction_id + "(old_transaction <
                                                                <
            // if not, we will want to reissue the original que <
        "   IF old_transaction_id IS NULL THEN\n"               <
        "       SET b_reissue = TRUE;\n"                        <
        "   ELSE\n"                                             <
        "       SET b_reissue = FALSE;\n"                       <
        "   END IF;\n\n"                                        <
                                                                <
            // cancel pending transaction                       <
        "   ROLLBACK;\n\n"                                      <
                                                                <
            // start a new one for this proc call               <
        "   START TRANSACTION;\n\n"                             <
                                                                <
            // first onion adjustment                           <
        "   SET @query = adjust_query0;\n"                      <
        "   PREPARE aq0 FROM @query;\n"                         <
        "   EXECUTE aq0;\n\n"                                   <
                                                                <
            // (possibly) second onion adjustment               <
        "   SET @query = adjust_query1;\n"                      <
        "   PREPARE aq1 FROM @query;\n"                         <
        "   EXECUTE aq1;\n\n"                                   <
                                                                <
            // update metadata used for recovery                <
        "   INSERT INTO " + remote_completion_table + "\n"      <
        "      (begin, complete, embedded_completion_id, reissu <
        "       (TRUE,  TRUE,     completion_id,          b_rei <
                                                                <
        "   COMMIT;\n"                                          <
        " END\n"});                                             <
    const std::string current_transaction_id =                  <
        MetaData::Proc::currentTransactionID();                 <
    const std::string hom_addition_transaction =                <
        MetaData::Proc::homAdditionTransaction();               <
    const std::string adjust_onion =                            <
        MetaData::Proc::adjustOnion();                          <
                                                                <
        drop_procs({"DROP PROCEDURE IF EXISTS " +               |          drop_procs{MetaData::Proc::activeTransactionP()};
                        current_transaction_id,                 <
                    "DROP PROCEDURE IF EXISTS " +               <
                        hom_addition_transaction,               <
                    "DROP PROCEDURE IF EXISTS " +               <
                        adjust_onion});                         <
        RETURN_FALSE_IF_FALSE(conn->execute(it));               |          RETURN_FALSE_IF_FALSE(conn->execute("DROP PROCEDURE IF 
Only in Practical-Cryptdb/main: test_layer.cc
Only in Practical-Cryptdb/main: test_proxy.cc
Only in Practical-Cryptdb/main: test_schema.cc
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/Translator.cc Practical-Cryptdb/main/Translator.cc
getpRandomName()                                                |  getpRandomName(){
{                                                               <
        // "0123456789"                                         <
                                                                <
                                                                <
            std::string fullname)                               |              std::string fullname){
{                                                               <
bool                                                            <
isSalt(std::string id, bool & isTableSalt)                      <
{                                                               <
    if (id.find(BASE_SALT_NAME) == 0 || (isTableField(id) && (g <
        if (id.find(BASE_SALT_NAME+"_t_") == 0) {               <
            isTableSalt = true;                                 <
        } else {                                                <
            isTableSalt = false;                                <
        }                                                       <
        return true;                                            <
    }                                                           <
                                                                <
    return false;                                               <
}                                                               <
                                                                <
                                                                <
                  std::list<std::string>::iterator & it)        |                    std::list<std::string>::iterator & it) {
{                                                               <
                                                                <
}                                                               <
                                                                <
/*                                                              <
 * The following functions return field name and table name.    <
 * Require the data to be in the format table.field or field.   <
 *                                                              <
 */                                                             <
std::string                                                     <
getField(std::string tablefield)                                <
{                                                               <
    if (isTableField(tablefield)) {                             <
        size_t pos = tablefield.find(".");                      <
        return tablefield.substr(pos+1, tablefield.length() - p <
    } else {                                                    <
        return tablefield;                                      <
    }                                                           <
}                                                               <
                                                                <
std::string                                                     <
getTable(std::string tablefield)                                <
{                                                               <
    if (isTableField(tablefield)) {                             <
        size_t pos = tablefield.find(".");                      <
        return tablefield.substr(0, pos);                       <
    } else {                                                    <
        return "";                                              <
    }                                                           <
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/main/Translator.hh Practical-Cryptdb/main/Translator.hh
//bool isTableField(std::string token);                         <
//std::string fullName(std::string field, std::string name);    <
//given table.field, the following two return the appropriate p <
//if the structure given is not of this form, it is considered  <
// table                                                        <
std::string getField(std::string tablefield);                   <
std::string getTable(std::string tablefield);                   <
// a table salt                                                 <
bool isSalt(std::string id, bool & isTableSalt);                <
Only in cryptdb-popa/main: .vimrc
Only in Practical-Cryptdb: Makefile
Only in Practical-Cryptdb: mbk.cc
Only in Practical-Cryptdb: metadata.data
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/mysqlproxy/ConnectWrapper.cc Practical-Cryptdb/mysqlproxy/ConnectWrapper.cc
                                                                >  #include <util/util.hh>
                                                                >  #include <main/schema.hh>
                                                                >  #include <main/Analysis.hh>
                                                                >
                                                                >  #include <parser/mysql_type_metadata.hh>
                                                                >
                                                                >  //为什么需要这个?
                                                                >  __thread ProxyState *thread_ps = NULL;
// FIXME: Ownership semantics.                                  <
                                                                >      KillZone kill_zone;
                                                                >
    SchemaCache &getSchemaCache() {return schema_cache;}        <
    void setQueryRewrite(QueryRewrite *const in_qr) {           |      void setQueryRewrite(std::unique_ptr<QueryRewrite> &&in_qr)
        // assert(!this->qr);                                   |          this->qr = std::move(in_qr);
        this->qr = std::unique_ptr<QueryRewrite>(in_qr);        |      }
                                                                >      void selfKill(KillZone::Where where) {
                                                                >          kill_zone.die(where);
                                                                >      void setKillZone(const KillZone &kz) {
                                                                >          kill_zone = kz;
                                                                >      }
                                                                >
                                                                >      std::unique_ptr<ProxyState> ps;
                                                                >      // we are running cryptdb in a threaded environment without
                                                                >      // locking; this leads to crashes during onion adjustment u
                                                                >      // take some minimal precautions
                                                                >      // > everytime we process a query we take a reference to th
                                                                >      //   so that we know the same SchemaInfo (and it's children
                                                                >      //   available on the backend for Deltaz; this handles the 
                                                                >      //   known bad cases.
                                                                >      //   a. thread A marks the cache as stale; thread B sees th
                                                                >      //      stale and updates the cache; thread A crashes while
                                                                >      //      trying to do onion adjustment
                                                                >      //   b. we must take the reference at the same time we get 
                                                                >      //      from the cache, otherwise ...
                                                                >      //      + thread A takes the reference to SchemaInfo when t
                                                                >      //        already stale, now he ``gets'' his SchemaInfo; be
                                                                >      //        cache is stale the second SchemaInfo is a new obj
                                                                >      //        reference doesn't protect it. now when thread B g
                                                                >      //        SchemaInfo the cache is still stale so he deletes
                                                                >      //        reference to the SchemaInfo thread A is using
                                                                >      //      + this case only applies if we aren't using the loc
                                                                >      //        function (connect, disonnect, rewrite, envoi); th
                                                                >      //        takes a reference to SchemaInfo then before he ca
                                                                >      //        the SchemaInfo thread B stales the cache. now thr
                                                                >      //        gets the SchemaInfo and his reference doesn't pro
                                                                >      //        when thread C gets his SchemaInfo the cache is st
                                                                >      //        he deletes the only reference to the SchemaInfo t
                                                                >      //        is using
                                                                >      std::vector<SchemaInfoRef> schema_info_refs;
    SchemaCache schema_cache;                                   <
static Timer t;                                                 |  //commented
                                                                >  //static Timer t;
static ProxyState * ps = NULL;                                  |  static SharedProxyState * shared_ps = NULL;
static int                                                      |  static void
static Item *                                                   <
make_item_by_type(const std::string &value, enum_field_types ty <
{                                                               <
    Item * i;                                                   <
                                                                <
    switch(type) {                                              <
    case MYSQL_TYPE_SHORT:                                      <
    case MYSQL_TYPE_LONG:                                       <
    case MYSQL_TYPE_LONGLONG:                                   <
    case MYSQL_TYPE_INT24:                                      <
    case MYSQL_TYPE_TINY:                                       <
        i = new (current_thd->mem_root) Item_int(static_cast<lo <
        break;                                                  <
                                                                <
    case MYSQL_TYPE_DOUBLE:                                     <
        i = new (current_thd->mem_root) Item_float(value.c_str( <
                                                   value.size() <
        break;                                                  <
                                                                <
    case MYSQL_TYPE_BLOB:                                       <
    case MYSQL_TYPE_TINY_BLOB:                                  <
    case MYSQL_TYPE_MEDIUM_BLOB:                                <
    case MYSQL_TYPE_LONG_BLOB:                                  <
    case MYSQL_TYPE_VARCHAR:                                    <
    case MYSQL_TYPE_VAR_STRING:                                 <
    case MYSQL_TYPE_TIMESTAMP:                                  <
    case MYSQL_TYPE_DATE:                                       <
    case MYSQL_TYPE_NEWDATE:                                    <
    case MYSQL_TYPE_TIME:                                       <
    case MYSQL_TYPE_DATETIME:                                   <
        i = new (current_thd->mem_root) Item_string(make_thd_st <
                                                    value.lengt <
                                                    &my_charset <
        break;                                                  <
                                                                <
    default:                                                    <
        thrower() << "unknown data type " << type;              <
    }                                                           <
    return i;                                                   <
}                                                               <
                                                                <
connect(lua_State *const L)                                     |  connect(lua_State *const L) {
{                                                               |  //TODO: added, why test here?
                                                                >      assert(test64bitZZConversions());
                                                                >
                                                                >      //来自lua脚本的参数.
    if (clients.find(client) != clients.end()) {                |      assert(clients.end() == clients.find(client));
           LOG(warn) << "duplicate client entry";               |      //一个用户进入的时候, 新建一个wrapper, 走的时候删除.
    }                                                           <
                                                                <
    if (!ps) {                                                  |      if (!shared_ps) {
        //cryptdb_logger::setConf(string(getenv("CRYPTDB_LOG")? <
                                                                <
        std::string const false_str = "FALSE";                  |          const std::string &false_str = "FALSE";
        const std::string dbname = "cryptdbtest";               |          const std::string &mkey      = "113341234";  // XXX do 
        const std::string mkey = "113341234";  // XXX do not ch <
        const char * ev = getenv("ENC_BY_DEFAULT");             |                  //const std::string &mkey = "887766908";
        if (ev && equalsIgnoreCase(false_str, ev)) {            |          shared_ps =
            std::cerr << "\n\n enc by default false " << "\n\n" |              new SharedProxyState(ci, embed_dir, mkey,
            ps = new ProxyState(ci, embed_dir, mkey,            |                                   determineSecurityRating());
                                SECURITY_RATING::PLAIN);        <
        } else {                                                <
            std::cerr << "\n\nenc by default true" << "\n\n";   <
            ps = new ProxyState(ci, embed_dir, mkey,            <
                                SECURITY_RATING::BEST_EFFORT);  <
        }                                                       <
                                                                <
        ev = getenv("TRAIN_QUERY");                             |          const char *ev = getenv("TRAIN_QUERY");
            //cerr << "loading enc tables\n";                   <
            //cl->loadEncTables(string(ev));                    <
                                                                >      clients[client]->ps =
                                                                >          std::unique_ptr<ProxyState>(new ProxyState(*shared_ps))
                                                                >      // We don't want to use the THD from the previous connectio
                                                                >      // if such is even possible...
                                                                >      clients[client]->ps->safeCreateEmbeddedTHD();
disconnect(lua_State *const L)                                  |  disconnect(lua_State *const L) {
{                                                               <
    SchemaCache &schema_cache = ws->getSchemaCache();           |      thread_ps = NULL;
    TEST_TextMessageError(schema_cache.cleanupStaleness(ps->get <
                          "Failed to cleanup staleness!");      <
                                                                >      mysql_thread_end();
rewrite(lua_State *const L)                                     |  rewrite(lua_State *const L) {
{                                                               <
        return 0;                                               |          lua_pushnil(L);
                                                                >          xlua_pushlstring(L, "failed to recognize client");     
                                                                >          return 2;
                                                                >
                                                                >      ProxyState *const ps = thread_ps = c_wrapper->ps.get();
                                                                >      assert(ps);
    const std::string query = xlua_tolstring(L, 2);             |      const std::string &query = xlua_tolstring(L, 2);
                                                                |      //std::cout<<query<<std::endl;
    std::list<std::string> new_queries;                         |      //this is not used??
                                                                <
    t.lap_ms();                                                 <
            assert(ps);                                         |              TEST_Text(retrieveDefaultDatabase(_thread_id, ps->g
                                                                <
            SchemaCache &schema_cache = c_wrapper->getSchemaCac <
            std::unique_ptr<QueryRewrite> qr;                   <
            TEST_TextMessageError(retrieveDefaultDatabase(_thre <
                                                          ps->g <
            queryPreamble(*ps, query, &qr, &new_queries, &schem |              // save a reference so a second thread won't eat ob
                          c_wrapper->default_db);               |              // that DeltaOuput wants later
                                                                >              const std::shared_ptr<const SchemaInfo> &schema =
                                                                >                  ps->getSchemaInfo();
                                                                >              c_wrapper->schema_info_refs.push_back(schema);
                                                                >
                                                                >              //parse, rewrite, delta, adjust, returnMeta, 
                                                                >              std::unique_ptr<QueryRewrite> qr =
                                                                >                  std::unique_ptr<QueryRewrite>(new QueryRewrite(
                                                                >                      Rewriter::rewrite(query, *schema.get(),
                                                                >                                        c_wrapper->default_db, *p
                                                                |              c_wrapper->setQueryRewrite(std::move(qr));
            c_wrapper->setQueryRewrite(qr.release());           <
        } catch (const SynchronizationException &e) {           <
            lua_pushboolean(L, false);              // status   <
            xlua_pushlstring(L, e.to_string());     // error me <
            lua_pushnil(L);                         // new quer <
            return 3;                                           <
            lua_pushnil(L);                         // new quer |              return 2;
            return 3;                                           <
            LOG(wrapper) << "cannot rewrite " << query << ": "  <
            lua_pushnil(L);                         // new quer |              return 2;
            return 3;                                           <
        }                                                       <
                                                                <
    if (LOG_PLAIN_QUERIES) {                                    <
        *(c_wrapper->PLAIN_LOG) << query << "\n";               <
                                                                <
                                                                |      return 2;
    // NOTE: Potentially out of int range.                      <
    assert(new_queries.size() < INT_MAX);                       <
    lua_createtable(L, static_cast<int>(new_queries.size()), 0) <
    const int top = lua_gettop(L);                              <
    int index = 1;                                              <
    for (auto it : new_queries) {                               <
        xlua_pushlstring(L, it);                    // new quer <
        lua_rawseti(L, top, index);                             <
        index++;                                                <
    return 3;                                                   |  inline std::vector<Item *>
}                                                               <
                                                                <
inline std::vector<std::shared_ptr<Item> >                      <
    std::vector<std::shared_ptr<Item> > out;                    |      std::vector<Item *> out;
        out.push_back(std::shared_ptr<Item>(make_null()));      |          out.push_back(make_null());
static void                                                     |  struct rawReturnValue{
                                                                >      std::vector<std::vector<std::string> > rowValues;
                                                                >      std::vector<std::string> fieldNames;
                                                                >      std::vector<int> fieldTypes;
                                                                >  };
                                                                >
                                                                >  static ResType
                       int rows_index, ResType *const out_res)  |                         int rows_index, int affected_rows_index,
{                                                               |                         int insert_id_index, int status_index) {
                                                                >      const bool status = lua_toboolean(L, status_index);
                                                                >      if (false == status) {
                                                                >          return ResType(false, 0, 0);
                                                                >      }
                                                                >
                                                                >      rawReturnValue myRawFromLua;
                                                                >
                                                                >      std::vector<std::string> names;
                                                                >      std::vector<enum_field_types> types;
                                                                <
                out_res->names.push_back(xlua_tolstring(L, -1)) |                  names.push_back(xlua_tolstring(L, -1));
                                                                >                  myRawFromLua.fieldNames.push_back(xlua_tolstrin
                out_res->types.push_back(static_cast<enum_field |                  types.push_back(static_cast<enum_field_types>(l
                                                                >                  myRawFromLua.fieldTypes.push_back(static_cast<e
                                                                <
    assert(out_res->names.size() == out_res->types.size());     |      assert(names.size() == types.size());
                                                                >      std::vector<std::vector<Item *> > rows;
                                                                >
                                                                >      //没有kv对了, 则退出.
        std::vector<std::shared_ptr<Item> > row =               |          std::vector<Item *> row = itemNullVector(types.size());
            itemNullVector(out_res->types.size());              |          std::vector<std::string> curRow;
                                                                <
                                                                |              assert(key >= 0 && static_cast<uint>(key) < types.s
            assert(key >= 0                                     <
                   && static_cast<uint>(key) < out_res->types.s <
            Item *const value =                                 |              curRow.push_back(data);
                make_item_by_type(data, out_res->types[key]);   |              row[key] = MySQLFieldTypeToItem(types[key], data);
            row[key] = std::shared_ptr<Item>(value);            <
                                                                <
        // We can not use this assert because rows that contain |          rows.push_back(row);
        // NULLs don't return their columns in a strictly incre |          myRawFromLua.rowValues.push_back(curRow);
        // order.                                               <
        // assert((unsigned int)key == out_res->names.size() -  <
                                                                <
        out_res->rows.push_back(row);                           <
                                                                >
                                                                >      //printrawReturnValue(myRawFromLua);
                                                                >
                                                                >      return ResType(status, lua_tointeger(L, affected_rows_index
                                                                >                     lua_tointeger(L, insert_id_index), std::move
                                                                >                     std::move(types), std::move(rows));
static int                                                      |  static void
envoi(lua_State *const L)                                       |  nilBuffer(lua_State *const L, size_t count)
    ANON_REGION(__func__, &perf_cg);                            |      while (count--) {
    scoped_lock l(&big_lock);                                   |          lua_pushnil(L);
    assert(0 == mysql_thread_init());                           |      }
    THD *const thd = static_cast<THD *>(create_embedded_thd(0)) |      return;
    auto thd_cleanup = cleanup([&thd]                           |  }
        {                                                       <
            thd->clear_data_list();                             <
            thd->store_globals();                               <
            thd->unlink();                                      <
            delete thd;                                         <
        });                                                     <
                                                                >  /*
                                                                >   *return mete for dectypting data.
                                                                >   * */
                                                                >  static void 
                                                                >  parseReturnMeta(const ReturnMeta & rtm){
                                                                >  }
                                                                >
                                                                >
                                                                >  static int
                                                                >  next(lua_State *const L) {
                                                                >      scoped_lock l(&big_lock);
                                                                >      assert(0 == mysql_thread_init());
                                                                >      //查找client
        return 0;                                               |          xlua_pushlstring(L, "error");
                                                                >          xlua_pushlstring(L, "unknown client");
                                                                >           lua_pushinteger(L,  100);
                                                                >          xlua_pushlstring(L, "12345");
                                                                >
                                                                >          nilBuffer(L, 1);
                                                                >          return 5;
                                                                >
                                                                >
                                                                >      ProxyState *const ps = thread_ps = c_wrapper->ps.get();
                                                                >      ps->safeCreateEmbeddedTHD();
                                                                >
                                                                >      const ResType &res = getResTypeFromLuaTable(L, 2, 3, 4, 5, 
                                                                >
    ResType res;                                                <
    getResTypeFromLuaTable(L, 2, 3, &res);                      <
                                                                >      parseReturnMeta(qr->rmeta);
        const EpilogueResult &epi_result =                      |          NextParams nparams(*ps, c_wrapper->default_db, c_wrappe
            queryEpilogue(*ps, *qr.get(), res, c_wrapper->last_ |
                          c_wrapper->default_db, false);        |          c_wrapper->selfKill(KillZone::Where::Before);
        if (QueryAction::ROLLBACK == epi_result.action) {       |          const auto &new_results = qr->executor->next(res, npara
            lua_pushboolean(L, true);           // success      |          c_wrapper->selfKill(KillZone::Where::After);
            lua_pushboolean(L, true);           // rollback     |
            lua_pushnil(L);                     // error messag |          const auto &result_type = new_results.first;
            lua_pushnil(L);                     // plaintext fi |          if (result_type != AbstractQueryExecutor::ResultType::Q
            lua_pushnil(L);                     // plaintext ro |              // set the killzone when we are done with this quer
                                                                >              // > a given killzone will only apply to the next q
                                                                >              c_wrapper->setKillZone(qr->kill_zone);
                                                                >          }
                                                                >          switch (result_type) {
                                                                >          case AbstractQueryExecutor::ResultType::QUERY_COME_AGAI
                                                                >              // more to do before we have the client's results
                                                                >              xlua_pushlstring(L, "again");
                                                                >              const auto &output =
                                                                >                  std::get<1>(new_results)->extract<std::pair<boo
                                                                >              const auto &want_interim = output.first;
                                                                >              lua_pushboolean(L, want_interim);
                                                                >              const auto &next_query = output.second;
                                                                >              xlua_pushlstring(L, next_query);
                                                                >              nilBuffer(L, 2);
                                                                |          case AbstractQueryExecutor::ResultType::QUERY_USE_RESUL
        assert(QueryAction::VANILLA == epi_result.action);      |              // the results of executing this query should be se
        return returnResultSet(L, epi_result.res_type);         |              // back to the client
    } catch (const SynchronizationException &e) {               |              xlua_pushlstring(L, "query-results");
        lua_pushboolean(L, false);              // status       |              const auto &new_query =
        lua_pushboolean(L, false);              // rollback     |                  std::get<1>(new_results)->extract<std::string>(
        xlua_pushlstring(L, e.to_string());     // error messag |              xlua_pushlstring(L, new_query);
        lua_pushnil(L);                         // plaintext fi |              nilBuffer(L, 3);
        lua_pushnil(L);                         // plaintext ro <
    } catch (const AbstractException &e) {                      |          }
        lua_pushboolean(L, false);              // status       |          case AbstractQueryExecutor::ResultType::RESULTS: {
        lua_pushboolean(L, false);              // rollback     |              // ready to return results to the client
        xlua_pushlstring(L, e.to_string());     // error messag |              xlua_pushlstring(L, "results");
        lua_pushnil(L);                         // plaintext fi |              const auto &res = new_results.second->extract<ResTy
        lua_pushnil(L);                         // plaintext ro |              returnResultSet(L, res);        // pushes 4 items o
    } catch (const CryptDBError &e) {                           |          }
        lua_pushboolean(L, false);              // status       |          default:
        lua_pushboolean(L, false);              // rollback     |              assert(false);
        xlua_pushlstring(L, e.msg);             // error messag |          }
        lua_pushnil(L);                         // plaintext fi |      } catch (const ErrorPacketException &e) {
        lua_pushnil(L);                         // plaintext ro |          // lua_pop(L, lua_gettop(L));
                                                                >          xlua_pushlstring(L, "error");
                                                                >          xlua_pushlstring(L, e.getMessage());
                                                                >           lua_pushinteger(L, e.getErrorCode());
                                                                >          xlua_pushlstring(L, e.getSQLState());
                                                                >
                                                                >          nilBuffer(L, 1);
static int                                                      |  static void
    lua_pushboolean(L, true);                   // status       |      TEST_GenericPacketException(true == rd.ok, "something bad h
    lua_pushboolean(L, false);                  // rollback     |
    lua_pushnil(L);                             // error messag |      lua_pushinteger(L, rd.affected_rows);
                                                                >      lua_pushinteger(L, rd.insert_id);
                                                                >
                                                                <
/*                                                              <
        // FIXME.                                               <
        // set type for field                                   <
        lua_pushinteger(L, rd.types[i]);                        <
        lua_setfield(L, t_field, "type");                       <
*/                                                              <
                                                                <
    return 5;                                                   |      return;
    F(envoi),                                                   |      F(next),
lua_cryptdb_init(lua_State *const L)                            |  lua_cryptdb_init(lua_State *const L) {
{                                                               <
Only in cryptdb-popa/mysqlproxy: README.txt
Only in cryptdb-popa/mysqlproxy: .vimrc
Only in cryptdb-popa/mysqlproxy: wrapper.lua
Only in Practical-Cryptdb: mysql-proxy.cnf
Only in cryptdb-popa: negatives_status.txt
Only in Practical-Cryptdb: packages
Only in cryptdb-popa/parser: analyze.cc
Only in cryptdb-popa/parser: Annotation.cc
Only in cryptdb-popa/parser: Annotation.hh
Only in cryptdb-popa/parser: attic
Only in cryptdb-popa/parser: Debug
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/parser/embedmysql.cc Practical-Cryptdb/parser/embedmysql.cc
static bool embed_active = false;                               <
                                                                <
embedmysql::embedmysql(const std::string &dir)                  <
{                                                               <
    struct stat st;                                             <
    if (stat(dir.c_str(), &st) != 0) {                          <
        fatal() << "ERROR! The proxy_db directory: " << dir <<  <
    }                                                           <
                                                                <
    if (!__sync_bool_compare_and_swap(&embed_active, false, tru <
        fatal() << "only one embedmysql object can exist at onc <
                                                                <
    char dir_arg[1024];                                         <
    snprintf(dir_arg, sizeof(dir_arg), "--datadir=%s", dir.c_st <
                                                                <
    const char *mysql_av[] =                                    <
        { "progname",                                           <
          "--skip-grant-tables",                                <
          dir_arg,                                              <
          "--character-set-server=utf8",                        <
          "--language=" MYSQL_BUILD_DIR "/sql/share/"           <
        };                                                      <
                                                                <
    assert(0 == mysql_library_init(sizeof(mysql_av) / sizeof(my <
                                   (char**) mysql_av, 0));      <
    m = mysql_init(0);                                          <
                                                                <
    mysql_options(m, MYSQL_OPT_USE_EMBEDDED_CONNECTION, 0);     <
    if (!mysql_real_connect(m, 0, 0, 0, "information_schema", 0 <
        mysql_close(m);                                         <
        fatal() << "mysql_real_connect: " << mysql_error(m);    <
    }                                                           <
}                                                               <
                                                                <
embedmysql::~embedmysql()                                       <
{                                                               <
    mysql_close(m);                                             <
    mysql_server_end();                                         <
    assert(__sync_bool_compare_and_swap(&embed_active, true, fa <
}                                                               <
                                                                <
MYSQL *                                                         <
embedmysql::conn()                                              <
{                                                               <
    /*                                                          <
     * Need to call mysql_thread_init() in every thread that to <
     * MySQL state.  mysql_server_init() calls it internally.   <
     * to call mysql_thread_init() many times.                  <
     */                                                         <
    mysql_thread_init();                                        <
    return m;                                                   <
}                                                               <
                                                                <
mysql_thrower::~mysql_thrower()                                 <
{                                                               <
    *this << ": " << current_thd->stmt_da->message();           <
    throw std::runtime_error(str());                            <
}                                                               <
query_parse::cleanup()                                          |  query_parse::cleanup(){
{                                                               <
    if (annot) {                                                <
        delete annot;                                           <
    }                                                           <
                                                                >          --thread_count;
query_parse::~query_parse()                                     |  query_parse::~query_parse() {
{                                                               <
                                                                >
static void                                                     |   * For the whys and hows;
cloneItemInOrder(ORDER * o) {                                   |   * look at plugin_thdvar_init(...) in sql/sql_plugin.cc, there 
    assert_s((*o->item)->type() == Item::Type::FIELD_ITEM, " su |   * table_plugin (the default plugin for queries run on a given 
    Item ** tmp = (Item **)malloc(sizeof(Item *));              |   * from the global_system_variables.table_plugin which can pres
    *tmp = new  Item_field(current_thd, static_cast<Item_field  |   * toggled with the 'storage_engine' runtime variable (testing 
    assert_s(*tmp, "clone item failed on order by element, elem |   * in cryptDB however shows that setting the runtime variable d
    o->item = tmp;                                              |   * propagate the change to the global_system_variables.table_pl
}                                                               |   * this variable is initially set to the MyISAM engine
                                                                >   *
                                                                >   * since doing "SET storage_engine='InnoDB'" doesn't work; we n
                                                                >   * hack the correct default table_plugin into the THD
                                                                >   *
                                                                >   * continuing, we can see sql/sql_yacc.yy where
                                                                >   *   lex->create_info.db_type = ha_default_handlerton(thd);
                                                                >   * ha_default_handlerton(...) is in sql/handler.cc and it calls
                                                                >   * ha_default_plugin(...). this function returns thd->variables
                                                                >   *
                                                                >   * so if we change thd->variables.table_plugin to InnoDB, it wi
                                                                >   * default storage engine
                                                                >  static plugin_ref
                                                                >  getInnoDBPlugin()
                                                                >  {
                                                                >      static const LEX_STRING name = string_to_lex_str("InnoDB");
                                                                >      // singleton
                                                                >      static plugin_ref innodb_plugin = ha_resolve_by_name(0, &na
                                                                >      assert(innodb_plugin);
                                                                >
                                                                >      return innodb_plugin;
                                                                >  }
                                                                >
                                                                >      //类内自带的THD* t结构.
        annot = new Annotation(q);                              |          //do not use Annotation now
    } else {                                                    <
        annot = NULL;                                           <
                                                                <
                                                                >          //set db
                                                                >          //reset tdb, what does cur_thd conrespond to??
                                                                >          // default engine should always be InnoDB
                                                                >          t->variables.table_plugin = getInnoDBPlugin();
                                                                >          assert(t->variables.table_plugin);
                                                                >
            mysql_thrower() << "Parser_state::init";            |              throw CryptDBError("Parser_state::init");
                                                                >  //  This is a wrapper of MYSQLparse(). All the code should call
                                                                >  //  instead of MYSQLparse().
            mysql_thrower() << "parse_sql";                     |              throw CryptDBError("parse_sql");
                                                                >          case SQLCOM_SHOW_STORAGE_ENGINES:
                                                                >          case SQLCOM_REPLACE:
            mysql_thrower() << "fill_derived_tables";           |              throw CryptDBError("fill_derived_tables");
            mysql_thrower() << "open_normal_and_derived_tables" |              throw CryptDBError("open_normal_and_derived_tables"
        if (lex->sql_command == SQLCOM_SELECT) {                |          if (SQLCOM_SELECT == lex->sql_command) {
                    mysql_thrower() << "JOIN::prepare";         |                      throw CryptDBError("JOIN::prepare");
                thrower() << "skip unions for now (union=" << l |                  thrower() << "skip unions for now (union="
                          << ", fake_select_lex=" << lex->selec |                            << lex->select_lex.master_unit()->is_
                                                                >                            << ", fake_select_lex="
                                                                >                            << lex->select_lex.master_unit()->fak
                                                                >                            << ")";
                    mysql_thrower() << "UNIT::prepare";         |                      throw CryptDBError("UNIT::prepare");
                 * for unions, it is insufficient to just print |                   * for unions, it is insufficient to just print
                 * because there are other select_lex's in the  |                   * lex->select_lex, because there are other
                                                                >                   * select_lex's in the unit..
        } else if (lex->sql_command == SQLCOM_DELETE) {         |          } else if (SQLCOM_DELETE == lex->sql_command) {
            if (mysql_prepare_delete(t, lex->query_tables, &lex |              if (mysql_prepare_delete(t, lex->query_tables,
                mysql_thrower() << "mysql_prepare_delete";      |                                       &lex->select_lex.where))
                                                                |                  throw CryptDBError("mysql_prepare_delete");
            if (lex->select_lex.setup_ref_array(t, lex->select_ |
                mysql_thrower() << "setup_ref_array";           |              if (lex->select_lex.setup_ref_array(t,
                                                                >                                      lex->select_lex.order_list.
                                                                >                  throw CryptDBError("setup_ref_array");
                mysql_thrower() << "setup_order";               |                  throw CryptDBError("setup_order");
        } else if (lex->sql_command == SQLCOM_INSERT) {         |          } else if (SQLCOM_DELETE_MULTI == lex->sql_command) {
                                                                >              if (mysql_multi_delete_prepare(t)
                                                                >                  || t->is_fatal_error)
                                                                >                  throw CryptDBError("mysql_multi_delete_prepare"
                                                                >
                                                                >              if (setup_conds(t, lex->auxiliary_table_list.first,
                                                                >                              lex->select_lex.leaf_tables,
                                                                >                              &lex->select_lex.where))
                                                                >                  throw CryptDBError("setup_conds");
                                                                >          } else if (lex->sql_command ==  SQLCOM_INSERT
                                                                >                     || lex->sql_command == SQLCOM_REPLACE) {
            if (mysql_prepare_insert(t, lex->query_tables, lex- |              if (mysql_prepare_insert(t, lex->query_tables,
                                                                >                                       lex->query_tables->table,
                mysql_thrower() << "mysql_prepare_insert";      |                  throw CryptDBError("mysql_prepare_insert");
                    mysql_thrower() << "setup_fields";          |                      throw CryptDBError("setup_fields");
            if (mysql_prepare_update(t, lex->query_tables, &lex |              if (mysql_prepare_update(t, lex->query_tables,
                                                                >                                       &lex->select_lex.where,
                mysql_thrower() << "mysql_prepare_update";      |                  throw CryptDBError("mysql_prepare_update");
                mysql_thrower() << "setup_fields_with_no_wrap"; |                  throw CryptDBError("setup_fields_with_no_wrap")
                mysql_thrower() << "setup_fields";              |                  throw CryptDBError("setup_fields");
                mysql_thrower() << "fix_inner_refs";            |                  throw CryptDBError("fix_inner_refs");
            thrower() << "don't know how to prepare command " < |              thrower() << "don't know how to prepare command "
                                                                >                        << lex->sql_command;
                                                                <
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/parser/embedmysql.hh Practical-Cryptdb/parser/embedmysql.hh
                                                                |  #include <util/util.hh>
#include <parser/Annotation.hh>                                 |  #include <util/onions.hh>
                                                                <
class embedmysql {                                              <
 public:                                                        <
    embedmysql(const std::string &dir);                         <
    virtual ~embedmysql();                                      <
                                                                <
    MYSQL *conn();                                              <
                                                                <
 private:                                                       <
    MYSQL *m;                                                   <
};                                                              <
                                                                <
class mysql_thrower : public std::stringstream {                <
 public:                                                        <
    ~mysql_thrower() __attribute__((noreturn));                 <
};                                                              <
                                                                <
    Annotation *annot;                                          <
                                                                <
                                                                <
    Parser_state ps;                                            |      Parser_state ps; /*这里包含了词法分析和语法分析时候, 使用的
                                                                >
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/parser/lex_util.cc Practical-Cryptdb/parser/lex_util.cc
            cryptdb_err() << "Can't clone function type: " << i |              thrower() << "Can't clone function type: " << i.typ
                                                                >  Item_field *
                                                                >  dup_item(const Item_field &i)
                                                                >  {
                                                                >      return new Item_field(current_thd, &const_cast<Item_field &
                                                                >  }
                                                                >
                                                                >          case Item::Type::FIELD_ITEM:
                                                                >              return dup_item(static_cast<const Item_field &>(i))
                                                                >  // a special type of Item used in ON DUPLICATE KEY UPDATE queri
                                                                >  // where the item is inside of a VALUES(...) function
Item *RiboldMYSQL::clone_item(const Item &i)                    |  // this will only work for constants
                                                                >  Item *
                                                                >  RiboldMYSQL::clone_item(const Item &i)
    return const_cast<Item &>(i).clone_item();                  |      Item *const out_i = const_cast<Item &>(i).clone_item();
                                                                >      if (NULL == out_i) {
                                                                >          thrower() << "attempted to clone a non constant Item";
                                                                >      }
                                                                >      return out_i;
// Item::val_str(...) modifies/returns an internal buffer somet <
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/parser/lex_util.hh Practical-Cryptdb/parser/lex_util.hh
                                                                >  Item_field *dup_item(const Item_field &i);
                                                                >  /* 注意这里的function返回值是List<Type>, 参数是List<Type>以及Ty
          std::function<List<Type>(List<Type>, Type *)> op)     |            std::function<List<Type>(List<Type>, Type *)> op) {
{                                                               <
vectorToListWithTHD(std::vector<T *> v)                         |  vectorToListWithTHD(std::vector<T *> v) {
{                                                               <
filterList(List_iterator<Type> it, std::function<bool(Type *)>  |  filterList(List_iterator<Type> it, std::function<bool(Type *)> 
{                                                               <
Only in cryptdb-popa/parser: load-schema.cc
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/parser/Makefrag Practical-Cryptdb/parser/Makefrag
PARSERSRC       := sql_utils.cc Annotation.cc lex_util.cc embed |  PARSERSRC       := sql_utils.cc lex_util.cc embedmysql.cc \
                   mysqld-filler.cc                             |                     mysqld-filler.cc mysql_type_metadata.cc
                                                                <
PARSERPROGS     := analyze load-schema print-back               <
                                                                <
PARSERPROGOBJS  := $(pathsubst %, $(OBJDIR)/parser/%,$(PARSERPR <
$(PARSERPROGOBJS): %: %.o $(OBJDIR)/libedbparser.so  $(OBJDIR)/ <
        $(CXX) $< -o $@ -ledbparser $(LDFLAGS) $(LDRPATH) -ledb <
                                                                <
                                                                <
Only in cryptdb-popa/parser: mysql_mods
Only in Practical-Cryptdb/parser: mysql_type_metadata.cc
Only in Practical-Cryptdb/parser: mysql_type_metadata.hh
Only in cryptdb-popa/parser: print-back.cc
Only in cryptdb-popa/parser: setup.sh
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/parser/sql_utils.cc Practical-Cryptdb/parser/sql_utils.cc
                                                                >  #include <ostream>
                                                                >
                                                                >  #include <parser/stringify.hh>
init_mysql(const string & embed_db)                             |  init_mysql(const string &embed_db){
{                                                               |      // FIXME: can still get a weird case where something calls
    if (lib_initialized) {                                      |      // init_mysql(...) and lib_initialized is true so it contin
                                                                >      // execute a query against the embedded database; but the t
                                                                >      // initializing the embedded database still hasn't complete
                                                                >      if (!__sync_bool_compare_and_swap(&lib_initialized, false, 
                                                                >
                                                                <
                                                                <
    lib_initialized = true;                                     <
}                                                               <
                                                                <
bool                                                            <
isTableField(string token)                                      <
{                                                               <
    size_t pos = token.find(".");                               <
                                                                <
    if (pos == string::npos) {                                  <
        return false;                                           <
    } else {                                                    <
        return true;                                            <
    }                                                           <
}                                                               <
                                                                <
// NOTE: Use FieldMeta::fullName if you know what onion's full  <
// need.                                                        <
string                                                          <
fullName(string field, string table)                            <
{                                                               <
    if (isTableField(field)) {                                  <
        return field;                                           <
    } else {                                                    <
        return table + "." + field;                             <
    }                                                           <
make_thd_string(const string &s, size_t *lenp)                  |  make_thd_string(const string &s, size_t *lenp){
{                                                               <
string                                                          |  std::string
ItemToStringWithQuotes(const Item &i) {                         |  printItemToString(const Item &i){
    if (RiboldMYSQL::is_null(i)) {                              |      std::ostringstream o;
        return std::string("NULL");                             |      o << i;
                                                                >      return o.str();
    bool is_null;                                               <
    const std::string &s0 = RiboldMYSQL::val_str(i, &is_null);  <
    assert(false == is_null);                                   <
    if (i.type() != Item::Type::STRING_ITEM) {                  <
        return s0;                                              <
    }                                                           <
                                                                <
    return "\"" + s0 + "\"";                                    <
}                                                               <
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/parser/sql_utils.hh Practical-Cryptdb/parser/sql_utils.hh
    bool ok;  // query executed successfully                    |      const bool ok;  // query executed successfully
    std::vector<std::string> names;                             |      const uint64_t affected_rows;
    std::vector<enum_field_types> types;                        |      const uint64_t insert_id;
    std::vector<std::vector<std::shared_ptr<Item> > > rows;     |      const std::vector<std::string> names;
                                                                >      const std::vector<enum_field_types> types;
                                                                >      const std::vector<std::vector<Item *> > rows;
                                                                >
                                                                >      ResType(bool okflag, uint64_t affected_rows, uint64_t inser
                                                                >              const std::vector<std::string> &&names = std::vecto
                                                                >              std::vector<enum_field_types> &&types =
                                                                >                  std::vector<enum_field_types>(),
                                                                >              std::vector<std::vector<Item *> > &&rows =
                                                                >                  std::vector<std::vector<Item *> >())
                                                                >          : ok(okflag), affected_rows(affected_rows),
                                                                >            insert_id(std::move(insert_id)), names(std::move(name
                                                                >            types(std::move(types)), rows(rows) {}
                                                                >
                                                                >      ResType(const ResType &res, const std::vector<std::vector<I
                                                                >          : ok(res.ok), affected_rows(res.affected_rows), insert_
                                                                >            names(res.names), types(res.types), rows(rows) {}
    explicit ResType(bool okflag = true) : ok(okflag) {}        <
bool isTableField(std::string token);                           <
std::string fullName(std::string field, std::string name);      <
                                                                <
std::string ItemToStringWithQuotes(const Item &i);              |  std::string printItemToString(const Item &i);
                                                                >
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/parser/stringify.hh Practical-Cryptdb/parser/stringify.hh
                                                                >  #include <util/util.hh>
                                                                >  #include <parser/mysql_type_metadata.hh>
operator<<(std::ostream &out, String &s)                        |  operator<<(std::ostream &out, const String &s)
                                                                <
static const char *                                             <
sql_type_to_string(enum_field_types tpe, CHARSET_INFO *charset) <
{                                                               <
#define ASSERT_NOT_REACHED() \                                  <
    do { \                                                      <
        assert(false); \                                        <
        return ""; \                                            <
    } while (0)                                                 <
                                                                <
    switch (tpe) {                                              <
    case MYSQL_TYPE_DECIMAL     : return "DECIMAL";             <
    case MYSQL_TYPE_TINY        : return "TINYINT";             <
    case MYSQL_TYPE_SHORT       : return "SMALLINT";            <
    case MYSQL_TYPE_LONG        : return "INT";                 <
    case MYSQL_TYPE_FLOAT       : return "FLOAT";               <
    case MYSQL_TYPE_DOUBLE      : return "DOUBLE";              <
    case MYSQL_TYPE_NULL        : ASSERT_NOT_REACHED();         <
    case MYSQL_TYPE_TIMESTAMP   : return "TIMESTAMP";           <
    case MYSQL_TYPE_LONGLONG    : return "BIGINT";              <
    case MYSQL_TYPE_INT24       : return "MEDIUMINT";           <
    case MYSQL_TYPE_DATE        : return "DATE";                <
    case MYSQL_TYPE_TIME        : return "TIME";                <
    case MYSQL_TYPE_DATETIME    : return "DATETIME";            <
    case MYSQL_TYPE_YEAR        : return "YEAR";                <
    case MYSQL_TYPE_NEWDATE     : ASSERT_NOT_REACHED();         <
    case MYSQL_TYPE_VARCHAR     :                               <
        if (charset == &my_charset_bin) {                       <
            return "VARBINARY";                                 <
        } else {                                                <
            return "VARCHAR";                                   <
        }                                                       <
    case MYSQL_TYPE_BIT         : return "BIT";                 <
    case MYSQL_TYPE_NEWDECIMAL  : return "DECIMAL";             <
    case MYSQL_TYPE_ENUM        : return "ENUM";                <
    case MYSQL_TYPE_SET         : return "SET";                 <
    case MYSQL_TYPE_TINY_BLOB   :                               <
        if (charset == &my_charset_bin) {                       <
            return "TINYBLOB";                                  <
        } else {                                                <
            return "TINYTEXT";                                  <
        }                                                       <
    case MYSQL_TYPE_MEDIUM_BLOB :                               <
        if (charset == &my_charset_bin) {                       <
            return "MEDIUMBLOB";                                <
        } else {                                                <
            return "MEDIUMTEXT";                                <
        }                                                       <
    case MYSQL_TYPE_LONG_BLOB   :                               <
        if (charset == &my_charset_bin) {                       <
            return "LONGBLOB";                                  <
        } else {                                                <
            return "LONGTEXT";                                  <
        }                                                       <
    case MYSQL_TYPE_BLOB        :                               <
        if (charset == &my_charset_bin) {                       <
            return "BLOB";                                      <
        } else {                                                <
            return "TEXT";                                      <
        }                                                       <
    case MYSQL_TYPE_VAR_STRING  : ASSERT_NOT_REACHED();         <
    case MYSQL_TYPE_STRING      : return "CHAR";                <
                                                                <
    /* don't bother to support */                               <
    case MYSQL_TYPE_GEOMETRY    : ASSERT_NOT_REACHED();         <
    }                                                           <
                                                                <
    ASSERT_NOT_REACHED();                                       <
}                                                               <
                                                                <
    out << f.field_name << " " << sql_type_to_string(f.sql_type |      out << f.field_name << " " << MySQLTypeToText(f);
                                                                >          if (isRealEncoded(f)) {
                                                                >              break;
                                                                >          }
                                                                >
                                                                >  inline std::string
                                                                >  convert_lex_str(const LEX_CSTRING &l)
                                                                >  {
                                                                >      return std::string(l.str, l.length);
                                                                >  }
                                                                >  inline std::string
                                                                >  nullAccomodationConvertLexStr(const LEX_STRING &l)
                                                                >  {
                                                                >      if (NULL == l.str) {
                                                                >          return "";
                                                                >      }
                                                                >
                                                                >      return convert_lex_str(l);
                                                                >  }
                                                                >
                                                                >  inline std::string
                                                                >  String_to_std_string(const String &s)
                                                                >  {
                                                                >      std::cout << s.ptr() << std::endl;
                                                                >      return std::string(s.ptr(), s.length());
                                                                >  }
                                                                >
                                                                >  inline std::string
                                                                >  printItem(const Item &i)
                                                                >  {
                                                                >      std::ostringstream o;
                                                                >      o << i;
                                                                >      return o.str();
                                                                >  }
                                                                >
        assert(false);                                          |          thrower() << "Unsupported key type " << std::to_string(
        break;                                                  <
    std::string key_name(k.name.str, k.name.length);            |      const std::string key_name(k.name.str, k.name.length);
        const std::string &db_str(convert_lex_str(fk.ref_table- |          const std::string &db_str =
                                                                >              nullAccomodationConvertLexStr(fk.ref_table->db);
                                                                >          out << " AUTO_INCREMENT=" << lex.create_info.auto_incre
                                                                >      return key_output.str();
                                                                >  }
                                                                >
                                                                >  static std::string
                                                                >  prefix_add_foreign(Key *key){
                                                                >      const std::string index_name = convert_lex_str(key->name);
                                                                >      std::ostringstream key_output;
                                                                >      key_output << " ADD constraint "<<" FOREIGN KEY "<<index_na
                                                                >      key_output << ListJoin<Key_part_spec>(key->columns, ",",
                                                                >                                            do_prefix_add_index()
                                                                >                 << ")";
                                                                >      
                                                                >      Table_ident* ref_table = ((Foreign_key*)key)->ref_table;
                                                                >      std::string ref_table_name = convert_lex_str(ref_table->tab
                                                                >      
                                                                >      key_output <<" REFERENCES "<< ref_table_name<<" (";
                                                                >      key_output<<ListJoin<Key_part_spec>( ((Foreign_key*)key)->r
                                                                >
/*                                                              |  //process normal key in alter table command, do not process for
static std::string                                              |  static std::string process_normal_key(LEX &lex){
prettyLockType(enum thr_lock_type lock_type)                    |      std::ostringstream key_output;
{                                                               |      auto it =
    switch (lock_type) {                                        |               List_iterator<Key>(lex.alter_info.key_list);
        case TL_READ:                                           |      while(auto cur = it++){
        case TL_READ_NO_INSERT:                                 |          switch(cur->type){
            return "READ";                                      |              case Key::PRIMARY:{
        case TL_WRITE:                                          |                  key_output<<prefix_add_index(*cur)<<",";
        case TL_WRITE_DEFAULT:                                  |                  break;
            return "WRITE";                                     |              }
        default:                                                |              case Key::UNIQUE:
            // FIXME: Use TEST_TextMessageError                 |              case Key::MULTIPLE:
            std::cerr << "Unsupported lock type: " << lock_type |              case Key::FULLTEXT:
                      << std::endl;                             |              case Key::SPATIAL:{
            assert(false);                                      |                  key_output<<prefix_add_index(*cur)<<",";       
                                                                >                  break;
                                                                >              case Key::FOREIGN_KEY:{
                                                                >                  break;
                                                                >              }
                                                                >              default:{
                                                                >                  break;
                                                                >              }
                                                                >          }
                                                                >      } 
                                                                >      std::string orig = key_output.str();
                                                                >      std::string res = orig.substr(0,orig.length()-1);
                                                                >      return res;
*/                                                              |
                                                                >  static std::string process_foreign_key(LEX &lex){
                                                                >      std::ostringstream key_output;
                                                                >      auto it =
                                                                >               List_iterator<Key>(lex.alter_info.key_list);
                                                                >      while(auto cur = it++){
                                                                >          switch(cur->type){
                                                                >              case Key::PRIMARY:{
                                                                >                  break;
                                                                >              }
                                                                >              case Key::UNIQUE:
                                                                >              case Key::MULTIPLE:
                                                                >              case Key::FULLTEXT:
                                                                >              case Key::SPATIAL:{
                                                                >                  break;
                                                                >              }
                                                                >              case Key::FOREIGN_KEY:{
                                                                >                  key_output<<prefix_add_foreign(cur)<<",";
                                                                >                  break;
                                                                >              }
                                                                >              default:{
                                                                >                  break;
                                                                >              }
                                                                >          }
                                                                >      } 
                                                                >      std::string orig = key_output.str();
                                                                >      std::string res = orig.substr(0,orig.length()-1);
                                                                >      return res;
                                                                >  }
                                                                >
                                                                >
                                                                >
                                                                >
                                                                >              assert(SQLCOM_DELETE_MULTI == lex.sql_command);
                                                                >
                                                                >              // the alias hackery is necesary because we don't w
                                                                >              // print a table with it's alias; we want to print 
                                                                >              // the real table name or the alias;
                                                                >              // TABLE_LIST::print(...) will print both together
                                                                >              {
                                                                >                      out << (f ? "" : ", ");
                                                                >                      if (true == tbl->is_alias) {
                                                                >                          out << quoteText(tbl->alias);
                                                                >                      } else {
                out << (f ? "" : ", ") << s0;                   |                          out << s0;
                                                                >                      }
                                                                >                  }
                TABLE_LIST tl;                                  |
                st_nested_join nj;                              |                  // code ripped then mutilated from print_join(.
                tl.nested_join = &nj;                           |                  // in sql/sql_select.cc
                nj.join_list = lex.select_lex.top_join_list;    |                  TABLE_LIST *table = lex.query_tables;
                tl.print(t, &s0, QT_ORDINARY);                  |                  // print the first table
                                                                >                  table->print(current_thd, &s0, QT_ORDINARY);
                                                                >                  while ((table = table->next_local)) {
                                                                >                      // print join type
                                                                >                      if (table->outer_join)
                                                                >                          s0.append(STRING_WITH_LEN(" left join "
                                                                >                      else if (table->straight)
                                                                >                          s0.append(STRING_WITH_LEN(" straight_jo
                                                                >                      else
                                                                >                          s0.append(STRING_WITH_LEN(" join "));
                                                                >
                                                                >                      table->print(current_thd, &s0, QT_ORDINARY)
                                                                >
                                                                >                      // print on clause
                                                                >                      if (table->on_expr)  {
                                                                >                        s0.append(STRING_WITH_LEN(" on("));
                                                                >                        table->on_expr->print(&s0, QT_ORDINARY);
                                                                >                        s0.append(')');
                                                                >                      }
                                                                >                  }
                                                                >
        out << convert_lex_str(lex.name);                       |          out << quoteText(convert_lex_str(lex.name));
        out << "USE " << lex.select_lex.db;                     |          out << "USE " << quoteText(lex.select_lex.db);
        out << convert_lex_str(lex.name);                       |          out << quoteText(convert_lex_str(lex.name));
                                                                >      case SQLCOM_CREATE_INDEX:
        // ALTER_ADD_COLUMN, ALTER_CHANGE_COLUMN, ALTER_ADD_IND |          //  > ALTER_CHANGE_COLUMN, ALTER_FOREIGN_KEY
        // ALTER_DROP_INDEX, ALTER_FOREIGN_KEY                  <
                                                                >          if(lex.alter_info.flags & ALTER_FOREIGN_KEY){
                                                                >              if (true == prev) {
                                                                >                  out << ", ";
                                                                >              }
                                                                >              std::string keys;
                                                                >              keys = process_foreign_key(lex);
                                                                >              out<<" "<<keys;
                                                                >              prev = true;           
                                                                >          }
            out << " " << ListJoin<Key>(lex.alter_info.key_list |              //process primary and index here
                                        prefix_add_index);      |              //out << " " << ListJoin<Key>(lex.alter_info.key_li
                                                                >              //                            prefix_add_index);
                                                                >              //get a vector of key type, key name, and key colum
                                                                >              std::string keys;
                                                                >              keys = process_normal_key(lex);
                                                                >              out<<" "<<keys;
                                                                >
                                                                >      case SQLCOM_SHOW_COLLATIONS:
                                                                >          out << "SHOW COLLATION";
                                                                >          break;
                                                                >
    case SQLCOM_SHOW_COLLATIONS:                                |      case SQLCOM_SHOW_STORAGE_ENGINES:
                                                                |      //ADDED
    default:                                                    |      case SQLCOM_SHOW_CREATE:{
        for (std::stringstream ss;;) {                          |          int elements = lex.select_lex.table_list.elements;
            ss << "unhandled sql command " << lex.sql_command;  |          if(elements==1){
            throw std::runtime_error(ss.str());                 |              TABLE_LIST *tbl = lex.select_lex.table_list.first;
                                                                >              std::string db(tbl->db);
                                                                >              std::string tbn(tbl->table_name);
                                                                >              out<< "SHOW CREATE TABLE "+db+"."+tbn;
                                                                >          }else{
                                                                >              out<<"ONLY SUPPORT ONE TABLE";
                                                                >          break;
                                                                >      }
                                                                >      default:
                                                                >          thrower() << "unhandled sql command " << lex.sql_comman
                                                                >
                                                                >
Only in cryptdb-popa/parser: .vimrc
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/README.md Practical-Cryptdb/README.md
CryptDB's website (including latest source code): http://css.cs |  ### Make cryptdb Practical
Wiki: https://github.com/burrows-labs/cryptdb-wiki/wiki/_pages  |  Cryptdb originated from MIT. This is a modified version. In thi
Convention : When this document uses syntax like                |  To deploy this version, you need follow the following steps.
                single-quote text single-quote                  <
                + 'some-text-here'                              <
                + 'a second example'                            <
             it indicates that the reader is to use the value _ <
             the single-quotes.                                 <
                                                                <
#########################################                       <
#########################################                       <
########### Getting started   ###########                       <
#########################################                       <
#########################################                       <
    * Requirements:                                             <
      > Ubuntu 12.04, 13.04; Not tested on a different OS.      <
      > ruby                                                    <
    * Build CryptDB using the installation script.              <
      > note, this script will stop and start your mysql instan <
      > scripts/install.rb <path-to-cryptdb>                    <
        + <path-to-cryptdb> should just be '.' if you are in th <
          directory                                             <
        + the script will likely require root privileges in ord <
          install dependencies and UDFs.                        <
    * Username/Password                                         <
        By default cryptdb uses 'root' for the username and 'le <
        for the password. You can change this by modifying the  <
            + Tests: test/test_utils.hh                         <
            + Shell: main/cdb_test.cc                           <
            + Proxy: mysqlproxy/wrapper.lua                     <
    * Rebuildling CryptDB                                       <
        If you modify the source and want to rebuild, issue 'ma <
        cryptdb directory.  If you change the UDFs you will als <
        'make install' (which will likely require root privileg <
                                                                <
#########################################                       <
#########################################                       <
####### A few ways to run CryptDB #######                       <
#########################################                       <
#########################################                       <
    Set (or place in your .bashrc):                             <
    > export EDBDIR=/full/path/to/cryptdb/                      <
                                                                <
    I. Shell                                                    <
        > To Start: obj/main/cdb_test  ./shadow <some-database- <
        > Type SQL queries that will be encrypted.              <
                                                                <
    II. Proxy                                                   <
        A) To Start:                                            <
             > /path/to/cryptdb/bins/proxy-bin/bin/mysql-proxy  <
                         --plugins=proxy --event-threads=4      <
                         --max-open-files=1024                  <
                         --proxy-lua-script=$EDBDIR/mysqlproxy/ <
                         --proxy-address=127.0.0.1:3307         <
                         --proxy-backend-addresses=localhost:33 <
                                                                <
        B) Connect to CryptDB: (where root/letmein are username <
           mysql -u root -pletmein -h 127.0.0.1 -P 3307         <
        C) CREATE a database; USE it; Then type queries that wi <
           on encrypted data at the DB server!                  <
                                                                <
    III. Tests                                                  <
        > To Start:                                             <
            obj/test/test queries plain proxy-single            <
                                                                <
                                                                <
#########################################                       <
#########################################                       <
############ Failing queries ############                       <
#########################################                       <
#########################################                       <
                                                                <
                                                                <
    Note that CryptDB is not a product, but just a more advance <
    prototype. It only has implemented a subset of SQL queries. <
    it supports the regular MySQL client and a variety of queri <
    play with from this shell, Wordpress, and other apps. We di <
    it with other MySQL clients (e.g., PHP, Java) and these lik <
    some uncommon metadata query we did not implement. Feel fre <
    implement what's missing!                                   <
                                                                <
                                                                <
    > Queries can fail for a few reasons.                       <
      I) CryptDB can support the query, but we have not yet imp <
         This should throw an UNIMPLEMENTED exception.          <
      II) CryptDB can not support this type of query, likely fo <
          cryptographic reasons. The error should include a mes <
          you more about the issue.                             <
                                                                <
            For example if you issue this query to the shell.   <
            SELECT * FROM t WHERE x + 10 < 50                   <
                                                                <
            You should get feedback. You will see that the feed <
            tells you the desired security level for the operat <
            each onion, and the current security level of each  <
            for each onion.                                     <
                                                                <
            In the case of this query, you can see that it woul <
            to compare order with onion 1 (OPE), 4 (PLAIN) or 6 <
                                                                <
            But if you look at it's first child "additive", you <
            that it would like to use the HOM onion.  Because t <
            onion is not supported by the order operation, the  <
            fails and gives you this error message.             <
                                                                <
            Look to the CryptDB paper for more information rega <
            how MySQL operations correspond to the cryptographi <
      III) State corruption (ie a bug in our code), this will l <
           to a crash.                                          <
      IV) Invalid query; problem with the query syntax.         <
                                                                <
#########################################                       <
#########################################                       <
################ Misc ###################                       <
#########################################                       <
#########################################                       <
                                                                <
    > The benchmarks in the CryptDB paper are based on an older <
      CryptDB. We have added new features and functionality to  <
      version which we have not yet optimized (but it is part o <
      roadmap).                                                 <
    > For example queries, take a look at our tests test/TestQu <
    > Consider connecting directly to MySQL to see what is in t <
      database.                                                 <
    > Resetting state (e.g., after running tests)               <
        > Take a look at scripts/refresh.sh ; you probably want <
        > If you create a database in cryptdb and then reset    <
          the state without first dropping the database from _w <
          cryptdb; you will need to drop it from the regular my <
    > Modifying the UDFs.                                       <
        + If you make changes to edb/udf.cc, you must reinstall <
          before your changes will take affect.                 <
            > sudo service mysql stop                           <
            > sudo make install                                 <
            > sudo service mysql start                          <
    > This new version of CryptDB is only single principal. We  <
      process of developling a new platform that more affective <
      multiple principals.                                      <
                                                                >  + have ubuntu 16.04 installed
                                                                >  + install mysql-server 5.5 or higher, with the root password 'l
                                                                >          To verify this, you can use the command mysql -uroot -p
                                                                >  + ./INSTALL.sh
                                                                >  + source ~/.bashrc
                                                                >  + source setup.sh
                                                                >  + run ./cdbserver.sh
                                                                >  + run ./cdbclient.sh 
                                                                >  + enjoy it!
                                                                >
                                                                >
                                                                >
                                                                >  If you meet any problems installing it, or if you meet bugs or 
                                                                >
                                                                >
                                                                >
                                                                >  New features added
                                                                >
                                                                >  + foreign key constraint
                                                                >
                                                                >  ```
                                                                >  create table student (id integer primary key);
                                                                >  create table choose (sid integer, foreign key fk(sid) reference
                                                                >  insert into student values(1);
                                                                >  insert into choose values(1);
                                                                >
                                                                >  ```
                                                                >
                                                                >  + set user variable
                                                                >  + timestamp
                                                                >  + show create table
                                                                >  + cdb_test for simple curd
                                                                >
                                                                >  obselete functions deleted
                                                                >
                                                                >  + annotation
                                                                >  + dbobject.tt
                                                                >
                                                                >  ### features to be added
                                                                >
                                                                >  + extended-insert
                                                                >  + QUOTE
                                                                >  + Search
Only in Practical-Cryptdb: reset.sh
Only in Practical-Cryptdb: results
Only in cryptdb-popa: scripts
Only in Practical-Cryptdb: setup.sh
Only in cryptdb-popa: supps
Only in cryptdb-popa: test
Only in cryptdb-popa: tools
Only in Practical-Cryptdb: tutorial-basic.lua
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/udf/create.sql Practical-Cryptdb/udf/create.sql
                                                                >
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/udf/edb.cc Practical-Cryptdb/udf/edb.cc
                           false);                              |                             true);
    if (args->arg_count != 3 ||                                 |      if (args->arg_count != 2 ||
        args->arg_type[1] != STRING_RESULT ||                   |          args->arg_type[1] != STRING_RESULT)
        args->arg_type[2] != INT_RESULT)                        <
            const uint64_t shift = getui(args, 2);              <
                                                                <
            value = bf.decrypt(eValue) - shift;                 |              value = bf.decrypt(eValue);
                                                                <
            const std::string key = std::string(keyBytes, keyLe |              const std::string &key = std::string(keyBytes, keyL
            uint64_t salt = getui(args, 2);                     |              const uint64_t salt = getui(args, 2);
    if (NULL == args->args[0]) {                                |      if (NULL == args->args[0] || NULL == args->args[1]) {
Only in Practical-Cryptdb/util: coroutine.hpp
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/util/cryptdb_log.cc Practical-Cryptdb/util/cryptdb_log.cc
uint64_t cryptdb_logger::enable_mask = //0;                     |  uint64_t cryptdb_logger::enable_mask = cryptdb_logger::mask(log
//    cryptdb_logger::mask(log_group::log_debug) |              <
//    cryptdb_logger::mask(log_group::log_cdb_v) |              <
//    cryptdb_logger::mask(log_group::log_wrapper) |            <
    //   cryptdb_logger::mask(log_group::log_encl) |            <
//    cryptdb_logger::mask(log_group::log_edb_v) |              <
    //cryptdb_logger::mask(log_group::log_am_v) |               <
    // cryptdb_logger::mask(log_group::log_test) |              <
    cryptdb_logger::mask(log_group::log_warn);                  <
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/util/enum_text.hh Practical-Cryptdb/util/enum_text.hh
                                                                >  #include <util/util.hh>
                                                                >
                                                                >      // FIXME: abstract with matching op
                                                                >      // FIXME: ^^^
                                                                >      _type noCaseGetEnum(std::string t) {
                                                                >          auto it =
                                                                >              std::find_if(theTexts.begin(), theTexts.end(),
                                                                >                           [&t] (std::string match_p) {
                                                                >                              return equalsIgnoreCase(t, match_p)
                                                                >                           });
                                                                >          if (theTexts.end() == it) {
                                                                >              throw CryptDBError("text does not exist!");
                                                                >          }
                                                                >
                                                                >          return theEnums[it - theTexts.begin()];
                                                                >      }
                                                                >
                                                                >      }
                                                                >
                                                                >      static _type noCaseToType(std::string t) {
                                                                >          return TypeText<_type>::instance->noCaseGetEnum(t);
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/util/errstream.hh Practical-Cryptdb/util/errstream.hh
class fatal : public std::stringstream {                        |
                                                                >  class err_stream {
    ~fatal() __attribute__((noreturn)) {                        |      virtual ~err_stream() noexcept(false) {}
        std::cerr << str() << std::endl;                        |
        exit(-1);                                               |      template <typename T>
                                                                >      std::ostream &operator<<(T &s) {
                                                                >          stream << s;
                                                                >          return stream;
                                                                >
                                                                >   protected:
                                                                >      std::stringstream stream;
class cryptdb_err : public std::stringstream {                  |
                                                                >  class fatal : public err_stream {
    ~cryptdb_err() __attribute__((noreturn)) {                  |      ~fatal() noexcept(false) __attribute__((noreturn)) {
        std::cerr << str() << std::endl;                        |          std::cerr << stream.str() << std::endl;
        throw CryptDBError(str());                              |          exit(-1);
class thrower : public std::stringstream {                      |  class thrower : public err_stream {
    ~thrower() __attribute__((noreturn)) {                      |      ~thrower() noexcept(false) __attribute__((noreturn)) {
        throw std::runtime_error(str());                        |          throw CryptDBError(stream.str());
Only in Practical-Cryptdb/util: hello.cc
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/util/Makefrag Practical-Cryptdb/util/Makefrag
        $(CXX) -shared -o $@ $^ $(LDFLAGS) -lntl -lcrypto -lgmp |          $(CXX) -fPIC -shared -o $@ $^ $(LDFLAGS) -lntl -lcrypto
install: install_util                                           |  #install: install_util
.PHONY: install_util                                            |  #.PHONY: install_util
install_util: $(OBJDIR)/libedbutil.so                           |  #install_util: $(OBJDIR)/libedbutil.so
        install -m 644 $(OBJDIR)/libedbutil.so /usr/lib         |  #       install -m 644 $(OBJDIR)/libedbutil.so /usr/lib
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/util/onions.cc Practical-Cryptdb/util/onions.cc
#include "util/onions.hh"                                       <
#include "util/util.hh"                                         <
                                                                <
/*                                                              <
std::ostream&                                                   <
operator<<(std::ostream &out, const EncDesc & ed)               <
{                                                               <
    if (ed.olm.size() == 0) {                                   <
        out << "empty encdesc";                                 <
    }                                                           <
    for (auto it : ed.olm) {                                    <
        out << "(onion " << it.first                            <
            << ", level " << levelnames[(int)it.second]         <
            << ") ";                                            <
    }                                                           <
    return out;                                                 <
}                                                               <
*/                                                              <
                                                                <
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/util/onions.hh Practical-Cryptdb/util/onions.hh
                                                                >      OPEFOREIGN,
    {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPE, SECLEVEL::RND} |      {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPEFOREIGN,SECLEVEL
    {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPE, SECLEVEL::RND} |      {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPEFOREIGN,SECLEVEL
    {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPE, SECLEVEL::RND} |      {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPEFOREIGN,SECLEVEL
    {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPE, SECLEVEL::RND} |      {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPEFOREIGN,SECLEVEL
                                                                >  //这个会用到么?
Only in Practical-Cryptdb/util: unyield.hpp
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/util/util.cc Practical-Cryptdb/util/util.cc
uint64FromZZ(ZZ val)                                            |  uint64FromZZ(ZZ val){
{                                                               <
                                                                <
                                                                <
    unsigned int unit = 256;                                    |      const unsigned int unit = 256;
        res = res + ((long int)value % unit) * power;           |          res = res + (value % unit) * power;
};                                                              |  }
                                                                >  std::string
                                                                >  leadingZeros(const std::string &input, size_t count)
                                                                >  {
                                                                >      assert(count >= input.length());
                                                                >
                                                                >      // add leading zeros until the length matches count
                                                                >      std::string zeros;
                                                                >      while (zeros.length() < (count - input.length())) {
                                                                >          zeros.push_back(0);
                                                                >      }
                                                                >
                                                                >      return zeros + input;
                                                                >  }
                                                                >
                                                                >  std::string
                                                                >  trailingZeros(const std::string &input, size_t count)
                                                                >  {
                                                                >      assert(count >= input.length());
                                                                >
                                                                >      // add trailing zeros until the length matches count
                                                                >      std::string zeros;
                                                                >      while (zeros.length() < (count - input.length())) {
                                                                >          zeros.push_back(0);
                                                                >      }
                                                                >
                                                                >      return input + zeros;
                                                                >  }
                                                                >
                                                                >  void *
                                                                >  NormalAlloc::operator new(size_t n)
                                                                >  {
                                                                >      void *const p = malloc(n);
                                                                >      if (NULL == p) {
                                                                >          throw std::bad_alloc();
                                                                >      }
                                                                >
                                                                >      return p;
                                                                >  }
                                                                >
                                                                >  void
                                                                >  NormalAlloc::operator delete(void *const p)
                                                                >  {
                                                                >      if (p) {
                                                                >          free(p);
                                                                >      }
                                                                >
                                                                >      return;
                                                                >  }
                                                                >
                                                                >  static bool
                                                                >  do64Test(uint64_t n)
                                                                >  {
                                                                >      RFIF(n == uint64FromZZ(ZZFromUint64(n)));
                                                                >
                                                                >      #if __x86_64__
                                                                >          static_assert(sizeof(long) == sizeof(uint64_t),
                                                                >                        "64 bit platform without 64 bit longs");
                                                                >          auto const &nativeZZFromUint64 =
                                                                >              [] (uint64_t enn) {return to_ZZ(enn);};
                                                                >          auto const &nativeUint64FromZZ =
                                                                >              [] (ZZ zee)
                                                                >              {
                                                                >                  uint64_t out;
                                                                >                  conv(out, zee);
                                                                >                  return out;
                                                                >              };
                                                                >          RFIF(n == uint64FromZZ(nativeZZFromUint64(n)));
                                                                >          RFIF(n == nativeUint64FromZZ(ZZFromUint64(n)));
                                                                >      #endif
                                                                >
                                                                >      return true;
                                                                >  }
                                                                >
                                                                >  // quick n dirty unit testing
                                                                >  bool
                                                                >  test64bitZZConversions()
                                                                >  {
                                                                >      // there was a problem with numbers larger than 0x7FFFFFFFF
                                                                >      // were too small by 256 after conversions
                                                                >      const uint64_t low_bad = 0x7FFFFFFFFFFFFFF0;
                                                                >      for (uint64_t i = low_bad; i <= low_bad + 50; ++i) {
                                                                >          RFIF(do64Test(i));
                                                                >      }
                                                                >
                                                                >      // try some other value
                                                                >      const uint64_t other_start = 0x9ABCD00012340000;
                                                                >      for (uint64_t i = other_start; i <= other_start + 50; ++i) 
                                                                >          RFIF(do64Test(i));
                                                                >      }
                                                                >
                                                                >      // try the biggest values
                                                                >      {
                                                                >          const uint64_t high_bad = 0xFFFFFFFFFFFFFFC0;
                                                                >          uint64_t i = high_bad;
                                                                >          do {
                                                                >              RFIF(do64Test(i));
                                                                >          } while (i++ < 0xFFFFFFFFFFFFFFFF);
                                                                >      }
                                                                >
                                                                >      return true;
                                                                >  }
diff --suppress-common-lines '--exclude=.git' --strip-trailing-cr -rytwb cryptdb-popa/util/util.hh Practical-Cryptdb/util/util.hh
                                                                >  #define RETURN_FALSE_IF_FALSE(status)       \
                                                                >  {                                           \
                                                                >      if (!(status)) {                        \
                                                                >          return false;                       \
                                                                >      }                                       \
                                                                >  }
                                                                >
                                                                >  #define RFIF RETURN_FALSE_IF_FALSE
                                                                >
                                                                >
                                                                <
                                                                <
                                                                <
typedef struct AccessRelation {                                 <
    AccessRelation(const std::string &hacc, const std::string & <
        hasAccess = hacc;                                       <
        accessTo = acct;                                        <
    }                                                           <
    std::string hasAccess;                                      <
    std::string accessTo;                                       <
} AccessRelation;                                               <
                                                                <
                                                                <
typedef struct AccessRelationComp {                             <
  bool operator() (const AccessRelation& lhs, const AccessRelat <
         if (lhs.hasAccess < rhs.hasAccess) {                   <
              return true;                                      <
          }                                                     <
          if (lhs.hasAccess > rhs.hasAccess) {                  <
              return false;                                     <
          }                                                     <
                                                                <
          if (lhs.accessTo < rhs.accessTo) {                    <
              return true;                                      <
          } else {                                              <
              return false;                                     <
          }                                                     <
      }                                                         <
} AccessRelationComp;                                           <
                                                                <
//permanent metadata for multi-key CryptDB - stores which field <
// for which field                                              <
typedef struct MultiKeyMeta {                                   <
    //e.g., msg_text encrypted for principal u.id               <
    std::map<std::string, std::string> encForMap;               <
    //contains an element if that element has some field encryp <
    std::map<std::string, bool > reverseEncFor;                 <
    std::map<AccessRelation, Predicate *, AccessRelationComp> c <
                                             // any conditional <
                                             // may have        <
    MultiKeyMeta() {}                                           <
    ~MultiKeyMeta() {                                           <
        for (auto i = condAccess.begin(); i != condAccess.end() <
           delete i->second;                                    <
        }                                                       <
    }                                                           <
} MKM;                                                          <
                                                                <
//temporary metadata for multi-key CryptDB that belongs to the  <
// being processed                                              <
typedef struct TempMKM {                                        <
    //maps a field (fullname) that has another field encrypted  <
    // value                                                    <
    // groups.gid    23                                         <
    std::map<std::string, std::string> encForVal;               <
                                                                <
    //maps a field that has another field encrypted for it to t <
    // response std::list of values containing its value        <
    // groups.gid 5                                             <
    std::map<std::string, int> encForReturned;                  <
                                                                <
    // contains fullnames of principals that were seen already  <
    std::map<std::string, bool> principalsSeen;                 <
                                                                <
    //true if current processing is query rather                <
    bool processingQuery;                                       <
                                                                <
    //some fields will be selected in order to be able to decry <
    // should not                                               <
    // be returned in the response to the application           <
    // maps position in raw DBMS response to whether it should  <
    // user or not                                              <
    std::map<unsigned int, bool> returnBitMap;                  <
} TMKM;                                                         <
                                                                <
                                                                >  std::string leadingZeros(const std::string &input, size_t count
                                                                >  std::string trailingZeros(const std::string &input, size_t coun
                                                                >
            this->value = value;                                |              this->value = new T(value);
    const T get() const {                                       |      const T &get() const {
        return value;                                           |          return *value;
    T value;                                                    |      T *value;
                                                                >  template <typename Type>
                                                                >  class ScopedAssignment {
                                                                >      ScopedAssignment() = delete;
                                                                >      ScopedAssignment(const ScopedAssignment &a) = delete;
                                                                >      ScopedAssignment(ScopedAssignment &&a) = delete;
                                                                >      ScopedAssignment &operator=(const ScopedAssignment &a) = de
                                                                >      ScopedAssignment &operator=(ScopedAssignment &&a) = delete;
                                                                >
                                                                >      Type *const addr;
                                                                >      Type &old_value;
                                                                >
                                                                >  public:
                                                                >      ScopedAssignment(Type *const addr, Type &&temp_value,
                                                                >                       std::function<void(void)> lambda) :
                                                                >          addr(addr), old_value(*addr)
                                                                >      {
                                                                >          *addr = temp_value;
                                                                >          lambda();
                                                                >          *addr = old_value;
                                                                >      }
                                                                >  };
                                                                >
                                                                >  class NormalAlloc {
                                                                >  public:
                                                                >      NormalAlloc() {}
                                                                >      virtual ~NormalAlloc() {}
                                                                >
                                                                >      void *operator new(size_t n);
                                                                >      void operator delete(void *const p);
                                                                >  };
                                                                >
                                                                >  inline std::string
                                                                >  quoteText(const std::string &text)
                                                                >  {
                                                                >      return "`" + text + "`";
                                                                >  }
                                                                >
                                                                >  template <typename T> void
                                                                >  destructThenFree(void *const p)
                                                                >  {
                                                                >      if (p) {
                                                                >          static_cast<T *>(p)->~T();
                                                                >          free(static_cast<T *>(p));
                                                                >      }
                                                                >  }
                                                                >
                                                                >  bool test64bitZZConversions();
Only in cryptdb-popa/util: .vimrc
Only in Practical-Cryptdb/util: yield.hpp
Only in Practical-Cryptdb: verify.sh
Only in Practical-Cryptdb: wrapper.lua
